// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: base

// Package base is a simple single-file test of vdl functionality.
//nolint:golint
package base

import (
	"fmt"
	"io"

	v23 "v.io/v23"
	"v.io/v23/context"
	"v.io/v23/i18n"
	"v.io/v23/rpc"
	"v.io/v23/vdl"
	"v.io/v23/verror"
	"v.io/v23/vom"
)

var _ = initializeVDL() // Must be first; see initializeVDL comments for details.

// Type definitions
// ================

type NamedBool bool

func (NamedBool) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedBool"`
}) {
}

func (x NamedBool) VDLIsZero() bool { //nolint:gocyclo
	return bool(!x)
}

func (x NamedBool) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueBool(vdlTypeBool1, bool(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedBool) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueBool(); {
	case err != nil:
		return err
	default:
		*x = NamedBool(value)
	}
	return nil
}

type NamedByte byte

func (NamedByte) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedByte"`
}) {
}

func (x NamedByte) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x NamedByte) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueUint(vdlTypeByte2, uint64(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedByte) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueUint(8); {
	case err != nil:
		return err
	default:
		*x = NamedByte(value)
	}
	return nil
}

type NamedUint16 uint16

func (NamedUint16) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedUint16"`
}) {
}

func (x NamedUint16) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x NamedUint16) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueUint(vdlTypeUint163, uint64(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedUint16) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueUint(16); {
	case err != nil:
		return err
	default:
		*x = NamedUint16(value)
	}
	return nil
}

type NamedUint32 uint32

func (NamedUint32) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedUint32"`
}) {
}

func (x NamedUint32) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x NamedUint32) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueUint(vdlTypeUint324, uint64(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedUint32) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueUint(32); {
	case err != nil:
		return err
	default:
		*x = NamedUint32(value)
	}
	return nil
}

type NamedUint64 uint64

func (NamedUint64) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedUint64"`
}) {
}

func (x NamedUint64) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x NamedUint64) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueUint(vdlTypeUint645, uint64(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedUint64) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueUint(64); {
	case err != nil:
		return err
	default:
		*x = NamedUint64(value)
	}
	return nil
}

type NamedInt8 int8

func (NamedInt8) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedInt8"`
}) {
}

func (x NamedInt8) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x NamedInt8) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueInt(vdlTypeInt86, int64(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedInt8) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueInt(8); {
	case err != nil:
		return err
	default:
		*x = NamedInt8(value)
	}
	return nil
}

type NamedInt16 int16

func (NamedInt16) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedInt16"`
}) {
}

func (x NamedInt16) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x NamedInt16) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueInt(vdlTypeInt167, int64(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedInt16) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueInt(16); {
	case err != nil:
		return err
	default:
		*x = NamedInt16(value)
	}
	return nil
}

type NamedInt32 int32

func (NamedInt32) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedInt32"`
}) {
}

func (x NamedInt32) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x NamedInt32) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueInt(vdlTypeInt328, int64(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedInt32) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueInt(32); {
	case err != nil:
		return err
	default:
		*x = NamedInt32(value)
	}
	return nil
}

type NamedInt64 int64

func (NamedInt64) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedInt64"`
}) {
}

func (x NamedInt64) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x NamedInt64) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueInt(vdlTypeInt649, int64(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedInt64) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueInt(64); {
	case err != nil:
		return err
	default:
		*x = NamedInt64(value)
	}
	return nil
}

type NamedFloat32 float32

func (NamedFloat32) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedFloat32"`
}) {
}

func (x NamedFloat32) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x NamedFloat32) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueFloat(vdlTypeFloat3210, float64(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedFloat32) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueFloat(32); {
	case err != nil:
		return err
	default:
		*x = NamedFloat32(value)
	}
	return nil
}

type NamedFloat64 float64

func (NamedFloat64) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedFloat64"`
}) {
}

func (x NamedFloat64) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x NamedFloat64) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueFloat(vdlTypeFloat6411, float64(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedFloat64) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueFloat(64); {
	case err != nil:
		return err
	default:
		*x = NamedFloat64(value)
	}
	return nil
}

type NamedString string

func (NamedString) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedString"`
}) {
}

func (x NamedString) VDLIsZero() bool { //nolint:gocyclo
	return x == ""
}

func (x NamedString) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueString(vdlTypeString12, string(x)); err != nil {
		return err
	}
	return nil
}

func (x *NamedString) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		*x = NamedString(value)
	}
	return nil
}

type NamedEnum int

const (
	NamedEnumA NamedEnum = iota
	NamedEnumB
	NamedEnumC
)

// NamedEnumAll holds all labels for NamedEnum.
var NamedEnumAll = [...]NamedEnum{NamedEnumA, NamedEnumB, NamedEnumC}

// NamedEnumFromString creates a NamedEnum from a string label.
//nolint:deadcode,unused
func NamedEnumFromString(label string) (x NamedEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *NamedEnum) Set(label string) error {
	switch label {
	case "A", "a":
		*x = NamedEnumA
		return nil
	case "B", "b":
		*x = NamedEnumB
		return nil
	case "C", "c":
		*x = NamedEnumC
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in base.NamedEnum", label)
}

// String returns the string label of x.
func (x NamedEnum) String() string {
	switch x {
	case NamedEnumA:
		return "A"
	case NamedEnumB:
		return "B"
	case NamedEnumC:
		return "C"
	}
	return ""
}

func (NamedEnum) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedEnum"`
	Enum struct{ A, B, C string }
}) {
}

func (x NamedEnum) VDLIsZero() bool { //nolint:gocyclo
	return x == NamedEnumA
}

func (x NamedEnum) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueString(vdlTypeEnum13, x.String()); err != nil {
		return err
	}
	return nil
}

func (x *NamedEnum) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		if err := x.Set(value); err != nil {
			return err
		}
	}
	return nil
}

type NamedArray [2]bool

func (NamedArray) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedArray"`
}) {
}

func (x NamedArray) VDLIsZero() bool { //nolint:gocyclo
	return x == NamedArray{}
}

func (x NamedArray) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeArray14); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntryValueBool(vdl.BoolType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NamedArray) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeArray14); err != nil {
		return err
	}
	for index := 0; index < 2; index++ {
		switch done, elem, err := dec.NextEntryValueBool(); {
		case err != nil:
			return err
		case done:
			return fmt.Errorf("short array, got len %d < 2 %T)", index, *x)
		default:
			x[index] = elem
		}
	}
	switch done, err := dec.NextEntry(); {
	case err != nil:
		return err
	case !done:
		return fmt.Errorf("long array, got len > 2 %T", *x)
	}
	return dec.FinishValue()
}

type NamedList []uint32

func (NamedList) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedList"`
}) {
}

func (x NamedList) VDLIsZero() bool { //nolint:gocyclo
	return len(x) == 0
}

func (x NamedList) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeList15); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntryValueUint(vdl.Uint32Type, uint64(elem)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NamedList) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeList15); err != nil {
		return err
	}
	if len := dec.LenHint(); len > 0 {
		*x = make(NamedList, 0, len)
	} else {
		*x = nil
	}
	for {
		switch done, elem, err := dec.NextEntryValueUint(32); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		default:
			*x = append(*x, uint32(elem))
		}
	}
}

type NamedSet map[string]struct{}

func (NamedSet) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedSet"`
}) {
}

func (x NamedSet) VDLIsZero() bool { //nolint:gocyclo
	return len(x) == 0
}

func (x NamedSet) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeSet16); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NamedSet) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeSet16); err != nil {
		return err
	}
	var tmpMap NamedSet
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(NamedSet, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(NamedSet)
			}
			tmpMap[key] = struct{}{}
		}
	}
}

type NamedMap map[string]float32

func (NamedMap) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedMap"`
}) {
}

func (x NamedMap) VDLIsZero() bool { //nolint:gocyclo
	return len(x) == 0
}

func (x NamedMap) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeMap17); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
		if err := enc.WriteValueFloat(vdl.Float32Type, float64(elem)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NamedMap) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeMap17); err != nil {
		return err
	}
	var tmpMap NamedMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(NamedMap, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem float32
			switch value, err := dec.ReadValueFloat(32); {
			case err != nil:
				return err
			default:
				elem = float32(value)
			}
			if tmpMap == nil {
				tmpMap = make(NamedMap)
			}
			tmpMap[key] = elem
		}
	}
}

type NamedStruct struct {
	A bool
	B string
	C int32
}

func (NamedStruct) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedStruct"`
}) {
}

func (x NamedStruct) VDLIsZero() bool { //nolint:gocyclo
	return x == NamedStruct{}
}

func (x NamedStruct) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct18); err != nil {
		return err
	}
	if x.A {
		if err := enc.NextFieldValueBool(0, vdl.BoolType, x.A); err != nil {
			return err
		}
	}
	if x.B != "" {
		if err := enc.NextFieldValueString(1, vdl.StringType, x.B); err != nil {
			return err
		}
	}
	if x.C != 0 {
		if err := enc.NextFieldValueInt(2, vdl.Int32Type, int64(x.C)); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NamedStruct) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = NamedStruct{}
	if err := dec.StartValue(vdlTypeStruct18); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct18 {
			index = vdlTypeStruct18.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueBool(); {
			case err != nil:
				return err
			default:
				x.A = value
			}
		case 1:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.B = value
			}
		case 2:
			switch value, err := dec.ReadValueInt(32); {
			case err != nil:
				return err
			default:
				x.C = int32(value)
			}
		}
	}
}

type (
	// NamedUnion represents any single field of the NamedUnion union type.
	NamedUnion interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// VDLReflect describes the NamedUnion union type.
		VDLReflect(vdlNamedUnionReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// NamedUnionA represents field A of the NamedUnion union type.
	NamedUnionA struct{ Value bool }
	// NamedUnionB represents field B of the NamedUnion union type.
	NamedUnionB struct{ Value string }
	// NamedUnionC represents field C of the NamedUnion union type.
	NamedUnionC struct{ Value int32 }
	// vdlNamedUnionReflect describes the NamedUnion union type.
	vdlNamedUnionReflect struct {
		Name  string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NamedUnion"`
		Type  NamedUnion
		Union struct {
			A NamedUnionA
			B NamedUnionB
			C NamedUnionC
		}
	}
)

func (x NamedUnionA) Index() int                      { return 0 }
func (x NamedUnionA) Interface() interface{}          { return x.Value }
func (x NamedUnionA) Name() string                    { return "A" }
func (x NamedUnionA) VDLReflect(vdlNamedUnionReflect) {}

func (x NamedUnionB) Index() int                      { return 1 }
func (x NamedUnionB) Interface() interface{}          { return x.Value }
func (x NamedUnionB) Name() string                    { return "B" }
func (x NamedUnionB) VDLReflect(vdlNamedUnionReflect) {}

func (x NamedUnionC) Index() int                      { return 2 }
func (x NamedUnionC) Interface() interface{}          { return x.Value }
func (x NamedUnionC) Name() string                    { return "C" }
func (x NamedUnionC) VDLReflect(vdlNamedUnionReflect) {}

func (x NamedUnionA) VDLIsZero() bool { //nolint:gocyclo
	return !x.Value
}

func (x NamedUnionB) VDLIsZero() bool {
	return false
}

func (x NamedUnionC) VDLIsZero() bool {
	return false
}

func (x NamedUnionA) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion19); err != nil {
		return err
	}
	if err := enc.NextFieldValueBool(0, vdl.BoolType, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x NamedUnionB) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion19); err != nil {
		return err
	}
	if err := enc.NextFieldValueString(1, vdl.StringType, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x NamedUnionC) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion19); err != nil {
		return err
	}
	if err := enc.NextFieldValueInt(2, vdl.Int32Type, int64(x.Value)); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadNamedUnion(dec vdl.Decoder, x *NamedUnion) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeUnion19); err != nil {
		return err
	}
	decType := dec.Type()
	index, err := dec.NextField()
	switch {
	case err != nil:
		return err
	case index == -1:
		return fmt.Errorf("missing field in union %T, from %v", x, decType)
	}
	if decType != vdlTypeUnion19 {
		name := decType.Field(index).Name
		index = vdlTypeUnion19.FieldIndexByName(name)
		if index == -1 {
			return fmt.Errorf("field %q not in union %T, from %v", name, x, decType)
		}
	}
	switch index {
	case 0:
		var field NamedUnionA
		switch value, err := dec.ReadValueBool(); {
		case err != nil:
			return err
		default:
			field.Value = value
		}
		*x = field
	case 1:
		var field NamedUnionB
		switch value, err := dec.ReadValueString(); {
		case err != nil:
			return err
		default:
			field.Value = value
		}
		*x = field
	case 2:
		var field NamedUnionC
		switch value, err := dec.ReadValueInt(32); {
		case err != nil:
			return err
		default:
			field.Value = int32(value)
		}
		*x = field
	}
	switch index, err := dec.NextField(); {
	case err != nil:
		return err
	case index != -1:
		return fmt.Errorf("extra field %d in union %T, from %v", index, x, dec.Type())
	}
	return dec.FinishValue()
}

type Scalars struct {
	A0  bool
	A1  byte
	A2  uint16
	A3  uint32
	A4  uint64
	A5  int8
	A6  int16
	A7  int32
	A8  int64
	A9  float32
	A10 float64
	A11 string
	A12 error
	A13 *vom.RawBytes
	A14 *vdl.Type
	B0  NamedBool
	B1  NamedByte
	B2  NamedUint16
	B3  NamedUint32
	B4  NamedUint64
	B5  NamedInt8
	B6  NamedInt16
	B7  NamedInt32
	B8  NamedInt64
	B9  NamedFloat32
	B10 NamedFloat64
	B11 NamedString
	B12 NamedEnum
	B13 NamedUnion
}

func (Scalars) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.Scalars"`
}) {
}

func (x Scalars) VDLIsZero() bool { //nolint:gocyclo
	if x.A0 {
		return false
	}
	if x.A1 != 0 {
		return false
	}
	if x.A2 != 0 {
		return false
	}
	if x.A3 != 0 {
		return false
	}
	if x.A4 != 0 {
		return false
	}
	if x.A5 != 0 {
		return false
	}
	if x.A6 != 0 {
		return false
	}
	if x.A7 != 0 {
		return false
	}
	if x.A8 != 0 {
		return false
	}
	if x.A9 != 0 {
		return false
	}
	if x.A10 != 0 {
		return false
	}
	if x.A11 != "" {
		return false
	}
	if x.A12 != nil {
		return false
	}
	if x.A13 != nil && !x.A13.VDLIsZero() {
		return false
	}
	if x.A14 != nil && x.A14 != vdl.AnyType {
		return false
	}
	if x.B0 {
		return false
	}
	if x.B1 != 0 {
		return false
	}
	if x.B2 != 0 {
		return false
	}
	if x.B3 != 0 {
		return false
	}
	if x.B4 != 0 {
		return false
	}
	if x.B5 != 0 {
		return false
	}
	if x.B6 != 0 {
		return false
	}
	if x.B7 != 0 {
		return false
	}
	if x.B8 != 0 {
		return false
	}
	if x.B9 != 0 {
		return false
	}
	if x.B10 != 0 {
		return false
	}
	if x.B11 != "" {
		return false
	}
	if x.B12 != NamedEnumA {
		return false
	}
	if x.B13 != nil && !x.B13.VDLIsZero() {
		return false
	}
	return true
}

func (x Scalars) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct20); err != nil {
		return err
	}
	if x.A0 {
		if err := enc.NextFieldValueBool(0, vdl.BoolType, x.A0); err != nil {
			return err
		}
	}
	if x.A1 != 0 {
		if err := enc.NextFieldValueUint(1, vdl.ByteType, uint64(x.A1)); err != nil {
			return err
		}
	}
	if x.A2 != 0 {
		if err := enc.NextFieldValueUint(2, vdl.Uint16Type, uint64(x.A2)); err != nil {
			return err
		}
	}
	if x.A3 != 0 {
		if err := enc.NextFieldValueUint(3, vdl.Uint32Type, uint64(x.A3)); err != nil {
			return err
		}
	}
	if x.A4 != 0 {
		if err := enc.NextFieldValueUint(4, vdl.Uint64Type, x.A4); err != nil {
			return err
		}
	}
	if x.A5 != 0 {
		if err := enc.NextFieldValueInt(5, vdl.Int8Type, int64(x.A5)); err != nil {
			return err
		}
	}
	if x.A6 != 0 {
		if err := enc.NextFieldValueInt(6, vdl.Int16Type, int64(x.A6)); err != nil {
			return err
		}
	}
	if x.A7 != 0 {
		if err := enc.NextFieldValueInt(7, vdl.Int32Type, int64(x.A7)); err != nil {
			return err
		}
	}
	if x.A8 != 0 {
		if err := enc.NextFieldValueInt(8, vdl.Int64Type, x.A8); err != nil {
			return err
		}
	}
	if x.A9 != 0 {
		if err := enc.NextFieldValueFloat(9, vdl.Float32Type, float64(x.A9)); err != nil {
			return err
		}
	}
	if x.A10 != 0 {
		if err := enc.NextFieldValueFloat(10, vdl.Float64Type, x.A10); err != nil {
			return err
		}
	}
	if x.A11 != "" {
		if err := enc.NextFieldValueString(11, vdl.StringType, x.A11); err != nil {
			return err
		}
	}
	if x.A12 != nil {
		if err := enc.NextField(12); err != nil {
			return err
		}
		if err := verror.VDLWrite(enc, x.A12); err != nil {
			return err
		}
	}
	if x.A13 != nil && !x.A13.VDLIsZero() {
		if err := enc.NextField(13); err != nil {
			return err
		}
		if err := x.A13.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.A14 != nil && x.A14 != vdl.AnyType {
		if err := enc.NextFieldValueTypeObject(14, x.A14); err != nil {
			return err
		}
	}
	if x.B0 {
		if err := enc.NextFieldValueBool(15, vdlTypeBool1, bool(x.B0)); err != nil {
			return err
		}
	}
	if x.B1 != 0 {
		if err := enc.NextFieldValueUint(16, vdlTypeByte2, uint64(x.B1)); err != nil {
			return err
		}
	}
	if x.B2 != 0 {
		if err := enc.NextFieldValueUint(17, vdlTypeUint163, uint64(x.B2)); err != nil {
			return err
		}
	}
	if x.B3 != 0 {
		if err := enc.NextFieldValueUint(18, vdlTypeUint324, uint64(x.B3)); err != nil {
			return err
		}
	}
	if x.B4 != 0 {
		if err := enc.NextFieldValueUint(19, vdlTypeUint645, uint64(x.B4)); err != nil {
			return err
		}
	}
	if x.B5 != 0 {
		if err := enc.NextFieldValueInt(20, vdlTypeInt86, int64(x.B5)); err != nil {
			return err
		}
	}
	if x.B6 != 0 {
		if err := enc.NextFieldValueInt(21, vdlTypeInt167, int64(x.B6)); err != nil {
			return err
		}
	}
	if x.B7 != 0 {
		if err := enc.NextFieldValueInt(22, vdlTypeInt328, int64(x.B7)); err != nil {
			return err
		}
	}
	if x.B8 != 0 {
		if err := enc.NextFieldValueInt(23, vdlTypeInt649, int64(x.B8)); err != nil {
			return err
		}
	}
	if x.B9 != 0 {
		if err := enc.NextFieldValueFloat(24, vdlTypeFloat3210, float64(x.B9)); err != nil {
			return err
		}
	}
	if x.B10 != 0 {
		if err := enc.NextFieldValueFloat(25, vdlTypeFloat6411, float64(x.B10)); err != nil {
			return err
		}
	}
	if x.B11 != "" {
		if err := enc.NextFieldValueString(26, vdlTypeString12, string(x.B11)); err != nil {
			return err
		}
	}
	if x.B12 != NamedEnumA {
		if err := enc.NextFieldValueString(27, vdlTypeEnum13, x.B12.String()); err != nil {
			return err
		}
	}
	if x.B13 != nil && !x.B13.VDLIsZero() {
		if err := enc.NextField(28); err != nil {
			return err
		}
		if err := x.B13.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Scalars) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = Scalars{
		A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
		A14: vdl.AnyType,
		B13: NamedUnionA{},
	}
	if err := dec.StartValue(vdlTypeStruct20); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct20 {
			index = vdlTypeStruct20.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueBool(); {
			case err != nil:
				return err
			default:
				x.A0 = value
			}
		case 1:
			switch value, err := dec.ReadValueUint(8); {
			case err != nil:
				return err
			default:
				x.A1 = byte(value)
			}
		case 2:
			switch value, err := dec.ReadValueUint(16); {
			case err != nil:
				return err
			default:
				x.A2 = uint16(value)
			}
		case 3:
			switch value, err := dec.ReadValueUint(32); {
			case err != nil:
				return err
			default:
				x.A3 = uint32(value)
			}
		case 4:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.A4 = value
			}
		case 5:
			switch value, err := dec.ReadValueInt(8); {
			case err != nil:
				return err
			default:
				x.A5 = int8(value)
			}
		case 6:
			switch value, err := dec.ReadValueInt(16); {
			case err != nil:
				return err
			default:
				x.A6 = int16(value)
			}
		case 7:
			switch value, err := dec.ReadValueInt(32); {
			case err != nil:
				return err
			default:
				x.A7 = int32(value)
			}
		case 8:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.A8 = value
			}
		case 9:
			switch value, err := dec.ReadValueFloat(32); {
			case err != nil:
				return err
			default:
				x.A9 = float32(value)
			}
		case 10:
			switch value, err := dec.ReadValueFloat(64); {
			case err != nil:
				return err
			default:
				x.A10 = value
			}
		case 11:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.A11 = value
			}
		case 12:
			if err := verror.VDLRead(dec, &x.A12); err != nil {
				return err
			}
		case 13:
			x.A13 = new(vom.RawBytes)
			if err := x.A13.VDLRead(dec); err != nil {
				return err
			}
		case 14:
			switch value, err := dec.ReadValueTypeObject(); {
			case err != nil:
				return err
			default:
				x.A14 = value
			}
		case 15:
			switch value, err := dec.ReadValueBool(); {
			case err != nil:
				return err
			default:
				x.B0 = NamedBool(value)
			}
		case 16:
			switch value, err := dec.ReadValueUint(8); {
			case err != nil:
				return err
			default:
				x.B1 = NamedByte(value)
			}
		case 17:
			switch value, err := dec.ReadValueUint(16); {
			case err != nil:
				return err
			default:
				x.B2 = NamedUint16(value)
			}
		case 18:
			switch value, err := dec.ReadValueUint(32); {
			case err != nil:
				return err
			default:
				x.B3 = NamedUint32(value)
			}
		case 19:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.B4 = NamedUint64(value)
			}
		case 20:
			switch value, err := dec.ReadValueInt(8); {
			case err != nil:
				return err
			default:
				x.B5 = NamedInt8(value)
			}
		case 21:
			switch value, err := dec.ReadValueInt(16); {
			case err != nil:
				return err
			default:
				x.B6 = NamedInt16(value)
			}
		case 22:
			switch value, err := dec.ReadValueInt(32); {
			case err != nil:
				return err
			default:
				x.B7 = NamedInt32(value)
			}
		case 23:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.B8 = NamedInt64(value)
			}
		case 24:
			switch value, err := dec.ReadValueFloat(32); {
			case err != nil:
				return err
			default:
				x.B9 = NamedFloat32(value)
			}
		case 25:
			switch value, err := dec.ReadValueFloat(64); {
			case err != nil:
				return err
			default:
				x.B10 = NamedFloat64(value)
			}
		case 26:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.B11 = NamedString(value)
			}
		case 27:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				if err := x.B12.Set(value); err != nil {
					return err
				}
			}
		case 28:
			if err := VDLReadNamedUnion(dec, &x.B13); err != nil {
				return err
			}
		}
	}
}

// These are all scalars that may be used as map or set keys.
type KeyScalars struct {
	A0  bool
	A1  byte
	A2  uint16
	A3  uint32
	A4  uint64
	A5  int8
	A6  int16
	A7  int32
	A8  int64
	A9  float32
	A10 float64
	A11 string
	B0  NamedBool
	B1  NamedByte
	B2  NamedUint16
	B3  NamedUint32
	B4  NamedUint64
	B5  NamedInt8
	B6  NamedInt16
	B7  NamedInt32
	B8  NamedInt64
	B9  NamedFloat32
	B10 NamedFloat64
	B13 NamedString
}

func (KeyScalars) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.KeyScalars"`
}) {
}

func (x KeyScalars) VDLIsZero() bool { //nolint:gocyclo
	return x == KeyScalars{}
}

func (x KeyScalars) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct21); err != nil {
		return err
	}
	if x.A0 {
		if err := enc.NextFieldValueBool(0, vdl.BoolType, x.A0); err != nil {
			return err
		}
	}
	if x.A1 != 0 {
		if err := enc.NextFieldValueUint(1, vdl.ByteType, uint64(x.A1)); err != nil {
			return err
		}
	}
	if x.A2 != 0 {
		if err := enc.NextFieldValueUint(2, vdl.Uint16Type, uint64(x.A2)); err != nil {
			return err
		}
	}
	if x.A3 != 0 {
		if err := enc.NextFieldValueUint(3, vdl.Uint32Type, uint64(x.A3)); err != nil {
			return err
		}
	}
	if x.A4 != 0 {
		if err := enc.NextFieldValueUint(4, vdl.Uint64Type, x.A4); err != nil {
			return err
		}
	}
	if x.A5 != 0 {
		if err := enc.NextFieldValueInt(5, vdl.Int8Type, int64(x.A5)); err != nil {
			return err
		}
	}
	if x.A6 != 0 {
		if err := enc.NextFieldValueInt(6, vdl.Int16Type, int64(x.A6)); err != nil {
			return err
		}
	}
	if x.A7 != 0 {
		if err := enc.NextFieldValueInt(7, vdl.Int32Type, int64(x.A7)); err != nil {
			return err
		}
	}
	if x.A8 != 0 {
		if err := enc.NextFieldValueInt(8, vdl.Int64Type, x.A8); err != nil {
			return err
		}
	}
	if x.A9 != 0 {
		if err := enc.NextFieldValueFloat(9, vdl.Float32Type, float64(x.A9)); err != nil {
			return err
		}
	}
	if x.A10 != 0 {
		if err := enc.NextFieldValueFloat(10, vdl.Float64Type, x.A10); err != nil {
			return err
		}
	}
	if x.A11 != "" {
		if err := enc.NextFieldValueString(11, vdl.StringType, x.A11); err != nil {
			return err
		}
	}
	if x.B0 {
		if err := enc.NextFieldValueBool(12, vdlTypeBool1, bool(x.B0)); err != nil {
			return err
		}
	}
	if x.B1 != 0 {
		if err := enc.NextFieldValueUint(13, vdlTypeByte2, uint64(x.B1)); err != nil {
			return err
		}
	}
	if x.B2 != 0 {
		if err := enc.NextFieldValueUint(14, vdlTypeUint163, uint64(x.B2)); err != nil {
			return err
		}
	}
	if x.B3 != 0 {
		if err := enc.NextFieldValueUint(15, vdlTypeUint324, uint64(x.B3)); err != nil {
			return err
		}
	}
	if x.B4 != 0 {
		if err := enc.NextFieldValueUint(16, vdlTypeUint645, uint64(x.B4)); err != nil {
			return err
		}
	}
	if x.B5 != 0 {
		if err := enc.NextFieldValueInt(17, vdlTypeInt86, int64(x.B5)); err != nil {
			return err
		}
	}
	if x.B6 != 0 {
		if err := enc.NextFieldValueInt(18, vdlTypeInt167, int64(x.B6)); err != nil {
			return err
		}
	}
	if x.B7 != 0 {
		if err := enc.NextFieldValueInt(19, vdlTypeInt328, int64(x.B7)); err != nil {
			return err
		}
	}
	if x.B8 != 0 {
		if err := enc.NextFieldValueInt(20, vdlTypeInt649, int64(x.B8)); err != nil {
			return err
		}
	}
	if x.B9 != 0 {
		if err := enc.NextFieldValueFloat(21, vdlTypeFloat3210, float64(x.B9)); err != nil {
			return err
		}
	}
	if x.B10 != 0 {
		if err := enc.NextFieldValueFloat(22, vdlTypeFloat6411, float64(x.B10)); err != nil {
			return err
		}
	}
	if x.B13 != "" {
		if err := enc.NextFieldValueString(23, vdlTypeString12, string(x.B13)); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *KeyScalars) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = KeyScalars{}
	if err := dec.StartValue(vdlTypeStruct21); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct21 {
			index = vdlTypeStruct21.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueBool(); {
			case err != nil:
				return err
			default:
				x.A0 = value
			}
		case 1:
			switch value, err := dec.ReadValueUint(8); {
			case err != nil:
				return err
			default:
				x.A1 = byte(value)
			}
		case 2:
			switch value, err := dec.ReadValueUint(16); {
			case err != nil:
				return err
			default:
				x.A2 = uint16(value)
			}
		case 3:
			switch value, err := dec.ReadValueUint(32); {
			case err != nil:
				return err
			default:
				x.A3 = uint32(value)
			}
		case 4:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.A4 = value
			}
		case 5:
			switch value, err := dec.ReadValueInt(8); {
			case err != nil:
				return err
			default:
				x.A5 = int8(value)
			}
		case 6:
			switch value, err := dec.ReadValueInt(16); {
			case err != nil:
				return err
			default:
				x.A6 = int16(value)
			}
		case 7:
			switch value, err := dec.ReadValueInt(32); {
			case err != nil:
				return err
			default:
				x.A7 = int32(value)
			}
		case 8:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.A8 = value
			}
		case 9:
			switch value, err := dec.ReadValueFloat(32); {
			case err != nil:
				return err
			default:
				x.A9 = float32(value)
			}
		case 10:
			switch value, err := dec.ReadValueFloat(64); {
			case err != nil:
				return err
			default:
				x.A10 = value
			}
		case 11:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.A11 = value
			}
		case 12:
			switch value, err := dec.ReadValueBool(); {
			case err != nil:
				return err
			default:
				x.B0 = NamedBool(value)
			}
		case 13:
			switch value, err := dec.ReadValueUint(8); {
			case err != nil:
				return err
			default:
				x.B1 = NamedByte(value)
			}
		case 14:
			switch value, err := dec.ReadValueUint(16); {
			case err != nil:
				return err
			default:
				x.B2 = NamedUint16(value)
			}
		case 15:
			switch value, err := dec.ReadValueUint(32); {
			case err != nil:
				return err
			default:
				x.B3 = NamedUint32(value)
			}
		case 16:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.B4 = NamedUint64(value)
			}
		case 17:
			switch value, err := dec.ReadValueInt(8); {
			case err != nil:
				return err
			default:
				x.B5 = NamedInt8(value)
			}
		case 18:
			switch value, err := dec.ReadValueInt(16); {
			case err != nil:
				return err
			default:
				x.B6 = NamedInt16(value)
			}
		case 19:
			switch value, err := dec.ReadValueInt(32); {
			case err != nil:
				return err
			default:
				x.B7 = NamedInt32(value)
			}
		case 20:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.B8 = NamedInt64(value)
			}
		case 21:
			switch value, err := dec.ReadValueFloat(32); {
			case err != nil:
				return err
			default:
				x.B9 = NamedFloat32(value)
			}
		case 22:
			switch value, err := dec.ReadValueFloat(64); {
			case err != nil:
				return err
			default:
				x.B10 = NamedFloat64(value)
			}
		case 23:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.B13 = NamedString(value)
			}
		}
	}
}

type ScalarsArray [2]Scalars

func (ScalarsArray) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.ScalarsArray"`
}) {
}

func (x ScalarsArray) VDLIsZero() bool { //nolint:gocyclo
	for _, elem := range x {
		if !elem.VDLIsZero() {
			return false
		}
	}
	return true
}

func (x ScalarsArray) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeArray22); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ScalarsArray) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeArray22); err != nil {
		return err
	}
	for index := 0; index < 2; index++ {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return fmt.Errorf("short array, got len %d < 2 %T)", index, *x)
		default:
			if err := x[index].VDLRead(dec); err != nil {
				return err
			}
		}
	}
	switch done, err := dec.NextEntry(); {
	case err != nil:
		return err
	case !done:
		return fmt.Errorf("long array, got len > 2 %T", *x)
	}
	return dec.FinishValue()
}

type Composites struct {
	A0 Scalars
	A1 ScalarsArray
	A2 []Scalars
	A3 map[KeyScalars]struct{}
	A4 map[string]Scalars
}

func (Composites) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.Composites"`
}) {
}

func (x Composites) VDLIsZero() bool { //nolint:gocyclo
	if !x.A0.VDLIsZero() {
		return false
	}
	if !x.A1.VDLIsZero() {
		return false
	}
	if len(x.A2) != 0 {
		return false
	}
	if len(x.A3) != 0 {
		return false
	}
	if len(x.A4) != 0 {
		return false
	}
	return true
}

func (x Composites) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct23); err != nil {
		return err
	}
	if !x.A0.VDLIsZero() {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := x.A0.VDLWrite(enc); err != nil {
			return err
		}
	}
	if !x.A1.VDLIsZero() {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := x.A1.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.A2) != 0 {
		if err := enc.NextField(2); err != nil {
			return err
		}
		if err := vdlWriteAnonList1(enc, x.A2); err != nil {
			return err
		}
	}
	if len(x.A3) != 0 {
		if err := enc.NextField(3); err != nil {
			return err
		}
		if err := vdlWriteAnonSet2(enc, x.A3); err != nil {
			return err
		}
	}
	if len(x.A4) != 0 {
		if err := enc.NextField(4); err != nil {
			return err
		}
		if err := vdlWriteAnonMap3(enc, x.A4); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonList1(enc vdl.Encoder, x []Scalars) error {
	if err := enc.StartValue(vdlTypeList24); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet2(enc vdl.Encoder, x map[KeyScalars]struct{}) error {
	if err := enc.StartValue(vdlTypeSet25); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap3(enc vdl.Encoder, x map[string]Scalars) error {
	if err := enc.StartValue(vdlTypeMap26); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Composites) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = Composites{
		A0: Scalars{
			A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
			A14: vdl.AnyType,
			B13: NamedUnionA{},
		},
		A1: ScalarsArray{
			{
				A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
				A14: vdl.AnyType,
				B13: NamedUnionA{},
			},
			{
				A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
				A14: vdl.AnyType,
				B13: NamedUnionA{},
			},
		},
	}
	if err := dec.StartValue(vdlTypeStruct23); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct23 {
			index = vdlTypeStruct23.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			if err := x.A0.VDLRead(dec); err != nil {
				return err
			}
		case 1:
			if err := x.A1.VDLRead(dec); err != nil {
				return err
			}
		case 2:
			if err := vdlReadAnonList1(dec, &x.A2); err != nil {
				return err
			}
		case 3:
			if err := vdlReadAnonSet2(dec, &x.A3); err != nil {
				return err
			}
		case 4:
			if err := vdlReadAnonMap3(dec, &x.A4); err != nil {
				return err
			}
		}
	}
}

func vdlReadAnonList1(dec vdl.Decoder, x *[]Scalars) error {
	if err := dec.StartValue(vdlTypeList24); err != nil {
		return err
	}
	if len := dec.LenHint(); len > 0 {
		*x = make([]Scalars, 0, len)
	} else {
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		default:
			var elem Scalars
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
			*x = append(*x, elem)
		}
	}
}

func vdlReadAnonSet2(dec vdl.Decoder, x *map[KeyScalars]struct{}) error {
	if err := dec.StartValue(vdlTypeSet25); err != nil {
		return err
	}
	var tmpMap map[KeyScalars]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[KeyScalars]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var key KeyScalars
			if err := key.VDLRead(dec); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[KeyScalars]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

func vdlReadAnonMap3(dec vdl.Decoder, x *map[string]Scalars) error {
	if err := dec.StartValue(vdlTypeMap26); err != nil {
		return err
	}
	var tmpMap map[string]Scalars
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]Scalars, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem Scalars
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[string]Scalars)
			}
			tmpMap[key] = elem
		}
	}
}

type CompositesArray [2]Composites

func (CompositesArray) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.CompositesArray"`
}) {
}

func (x CompositesArray) VDLIsZero() bool { //nolint:gocyclo
	for _, elem := range x {
		if !elem.VDLIsZero() {
			return false
		}
	}
	return true
}

func (x CompositesArray) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeArray27); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *CompositesArray) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeArray27); err != nil {
		return err
	}
	for index := 0; index < 2; index++ {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return fmt.Errorf("short array, got len %d < 2 %T)", index, *x)
		default:
			if err := x[index].VDLRead(dec); err != nil {
				return err
			}
		}
	}
	switch done, err := dec.NextEntry(); {
	case err != nil:
		return err
	case !done:
		return fmt.Errorf("long array, got len > 2 %T", *x)
	}
	return dec.FinishValue()
}

type CompComp struct {
	A0 Composites
	A1 CompositesArray
	A2 []Composites
	A3 map[string]Composites
	A4 map[KeyScalars][]map[string]Composites
}

func (CompComp) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.CompComp"`
}) {
}

func (x CompComp) VDLIsZero() bool { //nolint:gocyclo
	if !x.A0.VDLIsZero() {
		return false
	}
	if !x.A1.VDLIsZero() {
		return false
	}
	if len(x.A2) != 0 {
		return false
	}
	if len(x.A3) != 0 {
		return false
	}
	if len(x.A4) != 0 {
		return false
	}
	return true
}

func (x CompComp) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct28); err != nil {
		return err
	}
	if !x.A0.VDLIsZero() {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := x.A0.VDLWrite(enc); err != nil {
			return err
		}
	}
	if !x.A1.VDLIsZero() {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := x.A1.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.A2) != 0 {
		if err := enc.NextField(2); err != nil {
			return err
		}
		if err := vdlWriteAnonList4(enc, x.A2); err != nil {
			return err
		}
	}
	if len(x.A3) != 0 {
		if err := enc.NextField(3); err != nil {
			return err
		}
		if err := vdlWriteAnonMap5(enc, x.A3); err != nil {
			return err
		}
	}
	if len(x.A4) != 0 {
		if err := enc.NextField(4); err != nil {
			return err
		}
		if err := vdlWriteAnonMap6(enc, x.A4); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonList4(enc vdl.Encoder, x []Composites) error {
	if err := enc.StartValue(vdlTypeList29); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap5(enc vdl.Encoder, x map[string]Composites) error {
	if err := enc.StartValue(vdlTypeMap30); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap6(enc vdl.Encoder, x map[KeyScalars][]map[string]Composites) error {
	if err := enc.StartValue(vdlTypeMap31); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
		if err := vdlWriteAnonList7(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonList7(enc vdl.Encoder, x []map[string]Composites) error {
	if err := enc.StartValue(vdlTypeList32); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := vdlWriteAnonMap5(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *CompComp) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = CompComp{
		A0: Composites{
			A0: Scalars{
				A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
				A14: vdl.AnyType,
				B13: NamedUnionA{},
			},
			A1: ScalarsArray{
				{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
				{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
			},
		},
		A1: CompositesArray{
			{
				A0: Scalars{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
				A1: ScalarsArray{
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
				},
			},
			{
				A0: Scalars{
					A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
					A14: vdl.AnyType,
					B13: NamedUnionA{},
				},
				A1: ScalarsArray{
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
					{
						A13: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
						A14: vdl.AnyType,
						B13: NamedUnionA{},
					},
				},
			},
		},
	}
	if err := dec.StartValue(vdlTypeStruct28); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct28 {
			index = vdlTypeStruct28.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			if err := x.A0.VDLRead(dec); err != nil {
				return err
			}
		case 1:
			if err := x.A1.VDLRead(dec); err != nil {
				return err
			}
		case 2:
			if err := vdlReadAnonList4(dec, &x.A2); err != nil {
				return err
			}
		case 3:
			if err := vdlReadAnonMap5(dec, &x.A3); err != nil {
				return err
			}
		case 4:
			if err := vdlReadAnonMap6(dec, &x.A4); err != nil {
				return err
			}
		}
	}
}

func vdlReadAnonList4(dec vdl.Decoder, x *[]Composites) error {
	if err := dec.StartValue(vdlTypeList29); err != nil {
		return err
	}
	if len := dec.LenHint(); len > 0 {
		*x = make([]Composites, 0, len)
	} else {
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		default:
			var elem Composites
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
			*x = append(*x, elem)
		}
	}
}

func vdlReadAnonMap5(dec vdl.Decoder, x *map[string]Composites) error {
	if err := dec.StartValue(vdlTypeMap30); err != nil {
		return err
	}
	var tmpMap map[string]Composites
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]Composites, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem Composites
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[string]Composites)
			}
			tmpMap[key] = elem
		}
	}
}

func vdlReadAnonMap6(dec vdl.Decoder, x *map[KeyScalars][]map[string]Composites) error {
	if err := dec.StartValue(vdlTypeMap31); err != nil {
		return err
	}
	var tmpMap map[KeyScalars][]map[string]Composites
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[KeyScalars][]map[string]Composites, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var key KeyScalars
			if err := key.VDLRead(dec); err != nil {
				return err
			}
			var elem []map[string]Composites
			if err := vdlReadAnonList7(dec, &elem); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[KeyScalars][]map[string]Composites)
			}
			tmpMap[key] = elem
		}
	}
}

func vdlReadAnonList7(dec vdl.Decoder, x *[]map[string]Composites) error {
	if err := dec.StartValue(vdlTypeList32); err != nil {
		return err
	}
	if len := dec.LenHint(); len > 0 {
		*x = make([]map[string]Composites, 0, len)
	} else {
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		default:
			var elem map[string]Composites
			if err := vdlReadAnonMap5(dec, &elem); err != nil {
				return err
			}
			*x = append(*x, elem)
		}
	}
}

// Args will be reordered to show up before NestedArgs in the generated output.
type Args struct {
	A int32
	B int32
}

func (Args) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.Args"`
}) {
}

func (x Args) VDLIsZero() bool { //nolint:gocyclo
	return x == Args{}
}

func (x Args) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct33); err != nil {
		return err
	}
	if x.A != 0 {
		if err := enc.NextFieldValueInt(0, vdl.Int32Type, int64(x.A)); err != nil {
			return err
		}
	}
	if x.B != 0 {
		if err := enc.NextFieldValueInt(1, vdl.Int32Type, int64(x.B)); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Args) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = Args{}
	if err := dec.StartValue(vdlTypeStruct33); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct33 {
			index = vdlTypeStruct33.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueInt(32); {
			case err != nil:
				return err
			default:
				x.A = int32(value)
			}
		case 1:
			switch value, err := dec.ReadValueInt(32); {
			case err != nil:
				return err
			default:
				x.B = int32(value)
			}
		}
	}
}

// NestedArgs is defined before Args; that's allowed in regular Go, and also
// allowed in our vdl files.  The compiler will re-order dependent types to ease
// code generation in other languages.
type NestedArgs struct {
	Args Args
}

func (NestedArgs) VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/lib/vdl/testdata/base.NestedArgs"`
}) {
}

func (x NestedArgs) VDLIsZero() bool { //nolint:gocyclo
	return x == NestedArgs{}
}

func (x NestedArgs) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct34); err != nil {
		return err
	}
	if x.Args != (Args{}) {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := x.Args.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NestedArgs) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = NestedArgs{}
	if err := dec.StartValue(vdlTypeStruct34); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct34 {
			index = vdlTypeStruct34.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		if index == 0 {

			if err := x.Args.VDLRead(dec); err != nil {
				return err
			}
		}
	}
}

// Const definitions
// =================

const Cbool = true
const Cbyte = byte(1)
const Cint32 = int32(2)
const Cint64 = int64(3)
const Cuint32 = uint32(4)
const Cuint64 = uint64(5)
const Cfloat32 = float32(6)
const Cfloat64 = float64(7)
const CNamedBool = NamedBool(true)

var CNamedStruct = NamedStruct{
	A: true,
	B: "test",
}

const Cstring = "foo"
const Cenum = NamedEnumA

var Cunion = NamedUnion(NamedUnionA{Value: true})
var Carray = NamedArray{
	true,
	false,
}
var Clist = []int32{
	1,
	2,
	3,
}
var Cset = map[int32]struct{}{
	1: {},
	2: {},
	3: {},
}
var cmap = map[int32]string{
	1: "A",
	2: "B",
	3: "C",
}
var Cargs = Args{
	A: 1,
	B: 2,
}
var CScalars = Scalars{
	A0:  true,
	A1:  1,
	A2:  2,
	A3:  3,
	A4:  4,
	A5:  5,
	A6:  6,
	A7:  7,
	A8:  8,
	A9:  9,
	A10: 10,
	A11: "abc",
	A13: vom.RawBytesOf(false),
	A14: vdl.BoolType,
	B0:  true,
	B1:  1,
	B2:  2,
	B3:  3,
	B4:  4,
	B5:  5,
	B6:  6,
	B7:  7,
	B8:  8,
	B9:  9,
	B10: 10,
	B11: "abc",
	B12: NamedEnumB,
	B13: NamedUnionC{Value: 123},
}

const True = true
const Foo = "foo"
const Five = int32(5)
const Six = uint64(6)
const SixSquared = uint64(36)
const FiveSquared = int32(25)

var CTypeObject_bool = vdl.BoolType
var CTypeObject_string = vdl.StringType
var CTypeObject_bytes = vdl.TypeOf((*[]byte)(nil))
var CTypeObject_byte = vdl.ByteType
var CTypeObject_uint16 = vdl.Uint16Type
var CTypeObject_int8 = vdl.Int8Type
var CTypeObject_int16 = vdl.Int16Type
var CTypeObject_float32 = vdl.Float32Type
var CTypeObject_enum = vdl.TypeOf((*NamedEnum)(nil))
var CTypeObject_Array = vdl.TypeOf((*NamedArray)(nil))
var CTypeObject_List = vdl.TypeOf((*[]string)(nil))
var CTypeObject_Set = vdl.TypeOf((*map[string]struct{})(nil))
var CTypeObject_Map = vdl.TypeOf((*map[string]int64)(nil))
var CTypeObject_Struct = vdl.TypeOf((*Scalars)(nil)).Elem()
var CTypeObject_Union = vdl.TypeOf((*NamedUnion)(nil))
var CTypeObject_TypeObject = vdl.TypeObjectType
var CTypeObject_Any = vdl.AnyType

// Error definitions
// =================

var (
	ErrNoParams1   = verror.NewIDAction("v.io/x/ref/lib/vdl/testdata/base.NoParams1", verror.NoRetry)
	ErrNoParams2   = verror.NewIDAction("v.io/x/ref/lib/vdl/testdata/base.NoParams2", verror.RetryRefetch)
	ErrWithParams1 = verror.NewIDAction("v.io/x/ref/lib/vdl/testdata/base.WithParams1", verror.NoRetry)
	ErrWithParams2 = verror.NewIDAction("v.io/x/ref/lib/vdl/testdata/base.WithParams2", verror.RetryRefetch)
	errNotExported = verror.NewIDAction("v.io/x/ref/lib/vdl/testdata/base.notExported", verror.NoRetry)
)

// NewErrNoParams1 returns an error with the ErrNoParams1 ID.
// Deprecated: this function will be removed in the future,
// use ErrorfNoParams1 or MessageNoParams1 instead.
func NewErrNoParams1(ctx *context.T) error {
	return verror.New(ErrNoParams1, ctx)
}

// ErrorfNoParams1 calls ErrNoParams1.Errorf with the supplied arguments.
func ErrorfNoParams1(ctx *context.T, format string) error {
	return ErrNoParams1.Errorf(ctx, format)
}

// MessageNoParams1 calls ErrNoParams1.Message with the supplied arguments.
func MessageNoParams1(ctx *context.T, message string) error {
	return ErrNoParams1.Message(ctx, message)
}

// ParamsErrNoParams1 extracts the expected parameters from the error's ParameterList.
func ParamsErrNoParams1(argumentError error) (verrorComponent string, verrorOperation string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	return
}

// NewErrNoParams2 returns an error with the ErrNoParams2 ID.
// Deprecated: this function will be removed in the future,
// use ErrorfNoParams2 or MessageNoParams2 instead.
func NewErrNoParams2(ctx *context.T) error {
	return verror.New(ErrNoParams2, ctx)
}

// ErrorfNoParams2 calls ErrNoParams2.Errorf with the supplied arguments.
func ErrorfNoParams2(ctx *context.T, format string) error {
	return ErrNoParams2.Errorf(ctx, format)
}

// MessageNoParams2 calls ErrNoParams2.Message with the supplied arguments.
func MessageNoParams2(ctx *context.T, message string) error {
	return ErrNoParams2.Message(ctx, message)
}

// ParamsErrNoParams2 extracts the expected parameters from the error's ParameterList.
func ParamsErrNoParams2(argumentError error) (verrorComponent string, verrorOperation string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	return
}

// NewErrWithParams1 returns an error with the ErrWithParams1 ID.
// Deprecated: this function will be removed in the future,
// use ErrorfWithParams1 or MessageWithParams1 instead.
func NewErrWithParams1(ctx *context.T, x string, y int32) error {
	return verror.New(ErrWithParams1, ctx, x, y)
}

// ErrorfWithParams1 calls ErrWithParams1.Errorf with the supplied arguments.
func ErrorfWithParams1(ctx *context.T, format string, x string, y int32) error {
	return ErrWithParams1.Errorf(ctx, format, x, y)
}

// MessageWithParams1 calls ErrWithParams1.Message with the supplied arguments.
func MessageWithParams1(ctx *context.T, message string, x string, y int32) error {
	return ErrWithParams1.Message(ctx, message, x, y)
}

// ParamsErrWithParams1 extracts the expected parameters from the error's ParameterList.
func ParamsErrWithParams1(argumentError error) (verrorComponent string, verrorOperation string, x string, y int32, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if x, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value x, has %T and not string", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if y, ok = tmp.(int32); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value y, has %T and not int32", tmp)
		return
	}

	return
}

// NewErrWithParams2 returns an error with the ErrWithParams2 ID.
// Deprecated: this function will be removed in the future,
// use ErrorfWithParams2 or MessageWithParams2 instead.
func NewErrWithParams2(ctx *context.T, x string, y int32) error {
	return verror.New(ErrWithParams2, ctx, x, y)
}

// ErrorfWithParams2 calls ErrWithParams2.Errorf with the supplied arguments.
func ErrorfWithParams2(ctx *context.T, format string, x string, y int32) error {
	return ErrWithParams2.Errorf(ctx, format, x, y)
}

// MessageWithParams2 calls ErrWithParams2.Message with the supplied arguments.
func MessageWithParams2(ctx *context.T, message string, x string, y int32) error {
	return ErrWithParams2.Message(ctx, message, x, y)
}

// ParamsErrWithParams2 extracts the expected parameters from the error's ParameterList.
func ParamsErrWithParams2(argumentError error) (verrorComponent string, verrorOperation string, x string, y int32, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if x, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value x, has %T and not string", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if y, ok = tmp.(int32); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value y, has %T and not int32", tmp)
		return
	}

	return
}

// newErrNotExported returns an error with the errNotExported ID.
// Deprecated: this function will be removed in the future,
// use errorfNotExported or messageNotExported instead.
func newErrNotExported(ctx *context.T, x string, y int32) error {
	return verror.New(errNotExported, ctx, x, y)
}

// errorfNotExported calls errNotExported.Errorf with the supplied arguments.
func errorfNotExported(ctx *context.T, format string, x string, y int32) error {
	return errNotExported.Errorf(ctx, format, x, y)
}

// messageNotExported calls errNotExported.Message with the supplied arguments.
func messageNotExported(ctx *context.T, message string, x string, y int32) error {
	return errNotExported.Message(ctx, message, x, y)
}

// paramsErrNotExported extracts the expected parameters from the error's ParameterList.
func paramsErrNotExported(argumentError error) (verrorComponent string, verrorOperation string, x string, y int32, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if x, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value x, has %T and not string", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if y, ok = tmp.(int32); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value y, has %T and not int32", tmp)
		return
	}

	return
}

type paramListIterator struct {
	err      error
	idx, max int
	params   []interface{}
}

func (pl *paramListIterator) next() (interface{}, error) {
	if pl.err != nil {
		return nil, pl.err
	}
	if pl.idx+1 > pl.max {
		pl.err = fmt.Errorf("too few parameters: have %v", pl.max)
		return nil, pl.err
	}
	pl.idx++
	return pl.params[pl.idx-1], nil
}

func (pl *paramListIterator) preamble() (component, operation string, err error) {
	var tmp interface{}
	if tmp, err = pl.next(); err != nil {
		return
	}
	var ok bool
	if component, ok = tmp.(string); !ok {
		return "", "", fmt.Errorf("ParamList[0]: component name is not a string: %T", tmp)
	}
	if tmp, err = pl.next(); err != nil {
		return
	}
	if operation, ok = tmp.(string); !ok {
		return "", "", fmt.Errorf("ParamList[1]: operation name is not a string: %T", tmp)
	}
	return
}

// Interface definitions
// =====================

// ServiceAClientMethods is the client interface
// containing ServiceA methods.
type ServiceAClientMethods interface {
	MethodA1(*context.T, ...rpc.CallOpt) error
	MethodA2(_ *context.T, a int32, b string, _ ...rpc.CallOpt) (s string, _ error)
	MethodA3(_ *context.T, a int32, _ ...rpc.CallOpt) (ServiceAMethodA3ClientCall, error)
	MethodA4(_ *context.T, a int32, _ ...rpc.CallOpt) (ServiceAMethodA4ClientCall, error)
}

// ServiceAClientStub embeds ServiceAClientMethods and is a
// placeholder for additional management operations.
type ServiceAClientStub interface {
	ServiceAClientMethods
}

// ServiceAClient returns a client stub for ServiceA.
func ServiceAClient(name string) ServiceAClientStub {
	return implServiceAClientStub{name}
}

type implServiceAClientStub struct {
	name string
}

func (c implServiceAClientStub) MethodA1(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "MethodA1", nil, nil, opts...)
	return
}

func (c implServiceAClientStub) MethodA2(ctx *context.T, i0 int32, i1 string, opts ...rpc.CallOpt) (o0 string, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "MethodA2", []interface{}{i0, i1}, []interface{}{&o0}, opts...)
	return
}

func (c implServiceAClientStub) MethodA3(ctx *context.T, i0 int32, opts ...rpc.CallOpt) (ocall ServiceAMethodA3ClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "MethodA3", []interface{}{i0}, opts...); err != nil {
		return
	}
	ocall = &implServiceAMethodA3ClientCall{ClientCall: call}
	return
}

func (c implServiceAClientStub) MethodA4(ctx *context.T, i0 int32, opts ...rpc.CallOpt) (ocall ServiceAMethodA4ClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "MethodA4", []interface{}{i0}, opts...); err != nil {
		return
	}
	ocall = &implServiceAMethodA4ClientCall{ClientCall: call}
	return
}

// ServiceAMethodA3ClientStream is the client stream for ServiceA.MethodA3.
type ServiceAMethodA3ClientStream interface {
	// RecvStream returns the receiver side of the ServiceA.MethodA3 client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() Scalars
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// ServiceAMethodA3ClientCall represents the call returned from ServiceA.MethodA3.
type ServiceAMethodA3ClientCall interface {
	ServiceAMethodA3ClientStream
	// Finish blocks until the server is done, and returns the positional return
	// values for call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() (s string, _ error)
}

type implServiceAMethodA3ClientCall struct {
	rpc.ClientCall
	valRecv Scalars
	errRecv error
}

func (c *implServiceAMethodA3ClientCall) RecvStream() interface {
	Advance() bool
	Value() Scalars
	Err() error
} {
	return implServiceAMethodA3ClientCallRecv{c}
}

type implServiceAMethodA3ClientCallRecv struct {
	c *implServiceAMethodA3ClientCall
}

func (c implServiceAMethodA3ClientCallRecv) Advance() bool {
	c.c.valRecv = Scalars{}
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implServiceAMethodA3ClientCallRecv) Value() Scalars {
	return c.c.valRecv
}
func (c implServiceAMethodA3ClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implServiceAMethodA3ClientCall) Finish() (o0 string, err error) {
	err = c.ClientCall.Finish(&o0)
	return
}

// ServiceAMethodA4ClientStream is the client stream for ServiceA.MethodA4.
type ServiceAMethodA4ClientStream interface {
	// RecvStream returns the receiver side of the ServiceA.MethodA4 client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() string
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the ServiceA.MethodA4 client stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors
		// encountered while sending, or if Send is called after Close or
		// the stream has been canceled.  Blocks if there is no buffer
		// space; will unblock when buffer space is available or after
		// the stream has been canceled.
		Send(item int32) error
		// Close indicates to the server that no more items will be sent;
		// server Recv calls will receive io.EOF after all sent items.
		// This is an optional call - e.g. a client might call Close if it
		// needs to continue receiving items from the server after it's
		// done sending.  Returns errors encountered while closing, or if
		// Close is called after the stream has been canceled.  Like Send,
		// blocks if there is no buffer space available.
		Close() error
	}
}

// ServiceAMethodA4ClientCall represents the call returned from ServiceA.MethodA4.
type ServiceAMethodA4ClientCall interface {
	ServiceAMethodA4ClientStream
	// Finish performs the equivalent of SendStream().Close, then blocks until
	// the server is done, and returns the positional return values for the call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implServiceAMethodA4ClientCall struct {
	rpc.ClientCall
	valRecv string
	errRecv error
}

func (c *implServiceAMethodA4ClientCall) RecvStream() interface {
	Advance() bool
	Value() string
	Err() error
} {
	return implServiceAMethodA4ClientCallRecv{c}
}

type implServiceAMethodA4ClientCallRecv struct {
	c *implServiceAMethodA4ClientCall
}

func (c implServiceAMethodA4ClientCallRecv) Advance() bool {
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implServiceAMethodA4ClientCallRecv) Value() string {
	return c.c.valRecv
}
func (c implServiceAMethodA4ClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implServiceAMethodA4ClientCall) SendStream() interface {
	Send(item int32) error
	Close() error
} {
	return implServiceAMethodA4ClientCallSend{c}
}

type implServiceAMethodA4ClientCallSend struct {
	c *implServiceAMethodA4ClientCall
}

func (c implServiceAMethodA4ClientCallSend) Send(item int32) error {
	return c.c.Send(item)
}
func (c implServiceAMethodA4ClientCallSend) Close() error {
	return c.c.CloseSend()
}
func (c *implServiceAMethodA4ClientCall) Finish() (err error) {
	err = c.ClientCall.Finish()
	return
}

// ServiceAServerMethods is the interface a server writer
// implements for ServiceA.
type ServiceAServerMethods interface {
	MethodA1(*context.T, rpc.ServerCall) error
	MethodA2(_ *context.T, _ rpc.ServerCall, a int32, b string) (s string, _ error)
	MethodA3(_ *context.T, _ ServiceAMethodA3ServerCall, a int32) (s string, _ error)
	MethodA4(_ *context.T, _ ServiceAMethodA4ServerCall, a int32) error
}

// ServiceAServerStubMethods is the server interface containing
// ServiceA methods, as expected by rpc.Server.
// The only difference between this interface and ServiceAServerMethods
// is the streaming methods.
type ServiceAServerStubMethods interface {
	MethodA1(*context.T, rpc.ServerCall) error
	MethodA2(_ *context.T, _ rpc.ServerCall, a int32, b string) (s string, _ error)
	MethodA3(_ *context.T, _ *ServiceAMethodA3ServerCallStub, a int32) (s string, _ error)
	MethodA4(_ *context.T, _ *ServiceAMethodA4ServerCallStub, a int32) error
}

// ServiceAServerStub adds universal methods to ServiceAServerStubMethods.
type ServiceAServerStub interface {
	ServiceAServerStubMethods
	// DescribeInterfaces the ServiceA interfaces.
	Describe__() []rpc.InterfaceDesc
}

// ServiceAServer returns a server stub for ServiceA.
// It converts an implementation of ServiceAServerMethods into
// an object that may be used by rpc.Server.
func ServiceAServer(impl ServiceAServerMethods) ServiceAServerStub {
	stub := implServiceAServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implServiceAServerStub struct {
	impl ServiceAServerMethods
	gs   *rpc.GlobState
}

func (s implServiceAServerStub) MethodA1(ctx *context.T, call rpc.ServerCall) error {
	return s.impl.MethodA1(ctx, call)
}

func (s implServiceAServerStub) MethodA2(ctx *context.T, call rpc.ServerCall, i0 int32, i1 string) (string, error) {
	return s.impl.MethodA2(ctx, call, i0, i1)
}

func (s implServiceAServerStub) MethodA3(ctx *context.T, call *ServiceAMethodA3ServerCallStub, i0 int32) (string, error) {
	return s.impl.MethodA3(ctx, call, i0)
}

func (s implServiceAServerStub) MethodA4(ctx *context.T, call *ServiceAMethodA4ServerCallStub, i0 int32) error {
	return s.impl.MethodA4(ctx, call, i0)
}

func (s implServiceAServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implServiceAServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{ServiceADesc}
}

// ServiceADesc describes the ServiceA interface.
var ServiceADesc rpc.InterfaceDesc = descServiceA

// descServiceA hides the desc to keep godoc clean.
var descServiceA = rpc.InterfaceDesc{
	Name:    "ServiceA",
	PkgPath: "v.io/x/ref/lib/vdl/testdata/base",
	Methods: []rpc.MethodDesc{
		{
			Name: "MethodA1",
		},
		{
			Name: "MethodA2",
			InArgs: []rpc.ArgDesc{
				{Name: "a", Doc: ``}, // int32
				{Name: "b", Doc: ``}, // string
			},
			OutArgs: []rpc.ArgDesc{
				{Name: "s", Doc: ``}, // string
			},
		},
		{
			Name: "MethodA3",
			InArgs: []rpc.ArgDesc{
				{Name: "a", Doc: ``}, // int32
			},
			OutArgs: []rpc.ArgDesc{
				{Name: "s", Doc: ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf("tag"), vdl.ValueOf(uint64(6))},
		},
		{
			Name: "MethodA4",
			InArgs: []rpc.ArgDesc{
				{Name: "a", Doc: ``}, // int32
			},
		},
	},
}

// ServiceAMethodA3ServerStream is the server stream for ServiceA.MethodA3.
type ServiceAMethodA3ServerStream interface {
	// SendStream returns the send side of the ServiceA.MethodA3 server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item Scalars) error
	}
}

// ServiceAMethodA3ServerCall represents the context passed to ServiceA.MethodA3.
type ServiceAMethodA3ServerCall interface {
	rpc.ServerCall
	ServiceAMethodA3ServerStream
}

// ServiceAMethodA3ServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements ServiceAMethodA3ServerCall.
type ServiceAMethodA3ServerCallStub struct {
	rpc.StreamServerCall
}

// Init initializes ServiceAMethodA3ServerCallStub from rpc.StreamServerCall.
func (s *ServiceAMethodA3ServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// SendStream returns the send side of the ServiceA.MethodA3 server stream.
func (s *ServiceAMethodA3ServerCallStub) SendStream() interface {
	Send(item Scalars) error
} {
	return implServiceAMethodA3ServerCallSend{s}
}

type implServiceAMethodA3ServerCallSend struct {
	s *ServiceAMethodA3ServerCallStub
}

func (s implServiceAMethodA3ServerCallSend) Send(item Scalars) error {
	return s.s.Send(item)
}

// ServiceAMethodA4ServerStream is the server stream for ServiceA.MethodA4.
type ServiceAMethodA4ServerStream interface {
	// RecvStream returns the receiver side of the ServiceA.MethodA4 server stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() int32
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the ServiceA.MethodA4 server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item string) error
	}
}

// ServiceAMethodA4ServerCall represents the context passed to ServiceA.MethodA4.
type ServiceAMethodA4ServerCall interface {
	rpc.ServerCall
	ServiceAMethodA4ServerStream
}

// ServiceAMethodA4ServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements ServiceAMethodA4ServerCall.
type ServiceAMethodA4ServerCallStub struct {
	rpc.StreamServerCall
	valRecv int32
	errRecv error
}

// Init initializes ServiceAMethodA4ServerCallStub from rpc.StreamServerCall.
func (s *ServiceAMethodA4ServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// RecvStream returns the receiver side of the ServiceA.MethodA4 server stream.
func (s *ServiceAMethodA4ServerCallStub) RecvStream() interface {
	Advance() bool
	Value() int32
	Err() error
} {
	return implServiceAMethodA4ServerCallRecv{s}
}

type implServiceAMethodA4ServerCallRecv struct {
	s *ServiceAMethodA4ServerCallStub
}

func (s implServiceAMethodA4ServerCallRecv) Advance() bool {
	s.s.errRecv = s.s.Recv(&s.s.valRecv)
	return s.s.errRecv == nil
}
func (s implServiceAMethodA4ServerCallRecv) Value() int32 {
	return s.s.valRecv
}
func (s implServiceAMethodA4ServerCallRecv) Err() error {
	if s.s.errRecv == io.EOF {
		return nil
	}
	return s.s.errRecv
}

// SendStream returns the send side of the ServiceA.MethodA4 server stream.
func (s *ServiceAMethodA4ServerCallStub) SendStream() interface {
	Send(item string) error
} {
	return implServiceAMethodA4ServerCallSend{s}
}

type implServiceAMethodA4ServerCallSend struct {
	s *ServiceAMethodA4ServerCallStub
}

func (s implServiceAMethodA4ServerCallSend) Send(item string) error {
	return s.s.Send(item)
}

// ServiceBClientMethods is the client interface
// containing ServiceB methods.
type ServiceBClientMethods interface {
	ServiceAClientMethods
	MethodB1(_ *context.T, a Scalars, b Composites, _ ...rpc.CallOpt) (c CompComp, _ error)
}

// ServiceBClientStub embeds ServiceBClientMethods and is a
// placeholder for additional management operations.
type ServiceBClientStub interface {
	ServiceBClientMethods
}

// ServiceBClient returns a client stub for ServiceB.
func ServiceBClient(name string) ServiceBClientStub {
	return implServiceBClientStub{name, ServiceAClient(name)}
}

type implServiceBClientStub struct {
	name string

	ServiceAClientStub
}

func (c implServiceBClientStub) MethodB1(ctx *context.T, i0 Scalars, i1 Composites, opts ...rpc.CallOpt) (o0 CompComp, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "MethodB1", []interface{}{i0, i1}, []interface{}{&o0}, opts...)
	return
}

// ServiceBServerMethods is the interface a server writer
// implements for ServiceB.
type ServiceBServerMethods interface {
	ServiceAServerMethods
	MethodB1(_ *context.T, _ rpc.ServerCall, a Scalars, b Composites) (c CompComp, _ error)
}

// ServiceBServerStubMethods is the server interface containing
// ServiceB methods, as expected by rpc.Server.
// The only difference between this interface and ServiceBServerMethods
// is the streaming methods.
type ServiceBServerStubMethods interface {
	ServiceAServerStubMethods
	MethodB1(_ *context.T, _ rpc.ServerCall, a Scalars, b Composites) (c CompComp, _ error)
}

// ServiceBServerStub adds universal methods to ServiceBServerStubMethods.
type ServiceBServerStub interface {
	ServiceBServerStubMethods
	// DescribeInterfaces the ServiceB interfaces.
	Describe__() []rpc.InterfaceDesc
}

// ServiceBServer returns a server stub for ServiceB.
// It converts an implementation of ServiceBServerMethods into
// an object that may be used by rpc.Server.
func ServiceBServer(impl ServiceBServerMethods) ServiceBServerStub {
	stub := implServiceBServerStub{
		impl:               impl,
		ServiceAServerStub: ServiceAServer(impl),
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implServiceBServerStub struct {
	impl ServiceBServerMethods
	ServiceAServerStub
	gs *rpc.GlobState
}

func (s implServiceBServerStub) MethodB1(ctx *context.T, call rpc.ServerCall, i0 Scalars, i1 Composites) (CompComp, error) {
	return s.impl.MethodB1(ctx, call, i0, i1)
}

func (s implServiceBServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implServiceBServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{ServiceBDesc, ServiceADesc}
}

// ServiceBDesc describes the ServiceB interface.
var ServiceBDesc rpc.InterfaceDesc = descServiceB

// descServiceB hides the desc to keep godoc clean.
var descServiceB = rpc.InterfaceDesc{
	Name:    "ServiceB",
	PkgPath: "v.io/x/ref/lib/vdl/testdata/base",
	Embeds: []rpc.EmbedDesc{
		{Name: "ServiceA", PkgPath: "v.io/x/ref/lib/vdl/testdata/base", Doc: ``},
	},
	Methods: []rpc.MethodDesc{
		{
			Name: "MethodB1",
			InArgs: []rpc.ArgDesc{
				{Name: "a", Doc: ``}, // Scalars
				{Name: "b", Doc: ``}, // Composites
			},
			OutArgs: []rpc.ArgDesc{
				{Name: "c", Doc: ``}, // CompComp
			},
		},
	},
}

// Hold type definitions in package-level variables, for better performance.
//nolint:unused
var (
	vdlTypeBool1     *vdl.Type
	vdlTypeByte2     *vdl.Type
	vdlTypeUint163   *vdl.Type
	vdlTypeUint324   *vdl.Type
	vdlTypeUint645   *vdl.Type
	vdlTypeInt86     *vdl.Type
	vdlTypeInt167    *vdl.Type
	vdlTypeInt328    *vdl.Type
	vdlTypeInt649    *vdl.Type
	vdlTypeFloat3210 *vdl.Type
	vdlTypeFloat6411 *vdl.Type
	vdlTypeString12  *vdl.Type
	vdlTypeEnum13    *vdl.Type
	vdlTypeArray14   *vdl.Type
	vdlTypeList15    *vdl.Type
	vdlTypeSet16     *vdl.Type
	vdlTypeMap17     *vdl.Type
	vdlTypeStruct18  *vdl.Type
	vdlTypeUnion19   *vdl.Type
	vdlTypeStruct20  *vdl.Type
	vdlTypeStruct21  *vdl.Type
	vdlTypeArray22   *vdl.Type
	vdlTypeStruct23  *vdl.Type
	vdlTypeList24    *vdl.Type
	vdlTypeSet25     *vdl.Type
	vdlTypeMap26     *vdl.Type
	vdlTypeArray27   *vdl.Type
	vdlTypeStruct28  *vdl.Type
	vdlTypeList29    *vdl.Type
	vdlTypeMap30     *vdl.Type
	vdlTypeMap31     *vdl.Type
	vdlTypeList32    *vdl.Type
	vdlTypeStruct33  *vdl.Type
	vdlTypeStruct34  *vdl.Type
)

var initializeVDLCalled bool

// initializeVDL performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = initializeVDL()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func initializeVDL() struct{} {
	if initializeVDLCalled {
		return struct{}{}
	}
	initializeVDLCalled = true

	// Register types.
	vdl.Register((*NamedBool)(nil))
	vdl.Register((*NamedByte)(nil))
	vdl.Register((*NamedUint16)(nil))
	vdl.Register((*NamedUint32)(nil))
	vdl.Register((*NamedUint64)(nil))
	vdl.Register((*NamedInt8)(nil))
	vdl.Register((*NamedInt16)(nil))
	vdl.Register((*NamedInt32)(nil))
	vdl.Register((*NamedInt64)(nil))
	vdl.Register((*NamedFloat32)(nil))
	vdl.Register((*NamedFloat64)(nil))
	vdl.Register((*NamedString)(nil))
	vdl.Register((*NamedEnum)(nil))
	vdl.Register((*NamedArray)(nil))
	vdl.Register((*NamedList)(nil))
	vdl.Register((*NamedSet)(nil))
	vdl.Register((*NamedMap)(nil))
	vdl.Register((*NamedStruct)(nil))
	vdl.Register((*NamedUnion)(nil))
	vdl.Register((*Scalars)(nil))
	vdl.Register((*KeyScalars)(nil))
	vdl.Register((*ScalarsArray)(nil))
	vdl.Register((*Composites)(nil))
	vdl.Register((*CompositesArray)(nil))
	vdl.Register((*CompComp)(nil))
	vdl.Register((*Args)(nil))
	vdl.Register((*NestedArgs)(nil))

	// Initialize type definitions.
	vdlTypeBool1 = vdl.TypeOf((*NamedBool)(nil))
	vdlTypeByte2 = vdl.TypeOf((*NamedByte)(nil))
	vdlTypeUint163 = vdl.TypeOf((*NamedUint16)(nil))
	vdlTypeUint324 = vdl.TypeOf((*NamedUint32)(nil))
	vdlTypeUint645 = vdl.TypeOf((*NamedUint64)(nil))
	vdlTypeInt86 = vdl.TypeOf((*NamedInt8)(nil))
	vdlTypeInt167 = vdl.TypeOf((*NamedInt16)(nil))
	vdlTypeInt328 = vdl.TypeOf((*NamedInt32)(nil))
	vdlTypeInt649 = vdl.TypeOf((*NamedInt64)(nil))
	vdlTypeFloat3210 = vdl.TypeOf((*NamedFloat32)(nil))
	vdlTypeFloat6411 = vdl.TypeOf((*NamedFloat64)(nil))
	vdlTypeString12 = vdl.TypeOf((*NamedString)(nil))
	vdlTypeEnum13 = vdl.TypeOf((*NamedEnum)(nil))
	vdlTypeArray14 = vdl.TypeOf((*NamedArray)(nil))
	vdlTypeList15 = vdl.TypeOf((*NamedList)(nil))
	vdlTypeSet16 = vdl.TypeOf((*NamedSet)(nil))
	vdlTypeMap17 = vdl.TypeOf((*NamedMap)(nil))
	vdlTypeStruct18 = vdl.TypeOf((*NamedStruct)(nil)).Elem()
	vdlTypeUnion19 = vdl.TypeOf((*NamedUnion)(nil))
	vdlTypeStruct20 = vdl.TypeOf((*Scalars)(nil)).Elem()
	vdlTypeStruct21 = vdl.TypeOf((*KeyScalars)(nil)).Elem()
	vdlTypeArray22 = vdl.TypeOf((*ScalarsArray)(nil))
	vdlTypeStruct23 = vdl.TypeOf((*Composites)(nil)).Elem()
	vdlTypeList24 = vdl.TypeOf((*[]Scalars)(nil))
	vdlTypeSet25 = vdl.TypeOf((*map[KeyScalars]struct{})(nil))
	vdlTypeMap26 = vdl.TypeOf((*map[string]Scalars)(nil))
	vdlTypeArray27 = vdl.TypeOf((*CompositesArray)(nil))
	vdlTypeStruct28 = vdl.TypeOf((*CompComp)(nil)).Elem()
	vdlTypeList29 = vdl.TypeOf((*[]Composites)(nil))
	vdlTypeMap30 = vdl.TypeOf((*map[string]Composites)(nil))
	vdlTypeMap31 = vdl.TypeOf((*map[KeyScalars][]map[string]Composites)(nil))
	vdlTypeList32 = vdl.TypeOf((*[]map[string]Composites)(nil))
	vdlTypeStruct33 = vdl.TypeOf((*Args)(nil)).Elem()
	vdlTypeStruct34 = vdl.TypeOf((*NestedArgs)(nil)).Elem()

	// Set error format strings.
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrNoParams1.ID), "{1:}{2:} en msg")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrNoParams2.ID), "{1:}{2:} en msg")
	i18n.Cat().SetWithBase(i18n.LangID("fr"), i18n.MsgID(ErrNoParams2.ID), "{1:}{2:} fr msg")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrWithParams1.ID), "{1:}{2:} en x={3} y={4}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrWithParams2.ID), "{1:}{2:} en x={3} y={4}")
	i18n.Cat().SetWithBase(i18n.LangID("fr"), i18n.MsgID(ErrWithParams2.ID), "{1:}{2:} fr y={4} x={3}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(errNotExported.ID), "{1:}{2:} en x={3} y={4}")

	return struct{}{}
}
