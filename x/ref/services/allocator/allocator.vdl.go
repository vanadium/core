// Copyright 2016 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: allocator

package allocator

import (
	"time"
	"v.io/v23"
	"v.io/v23/context"
	"v.io/v23/rpc"
	"v.io/v23/vdl"
	vdltime "v.io/v23/vdlroot/time"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// Instance describes a service instance.
type Instance struct {
	Handle        string
	MountName     string
	BlessingNames []string
	CreationTime  time.Time
	Replicas      int32
	Version       string
}

func (Instance) __VDLReflect(struct {
	Name string `vdl:"v.io/x/ref/services/allocator.Instance"`
}) {
}

func (x Instance) VDLIsZero() bool {
	if x.Handle != "" {
		return false
	}
	if x.MountName != "" {
		return false
	}
	if len(x.BlessingNames) != 0 {
		return false
	}
	if !x.CreationTime.IsZero() {
		return false
	}
	if x.Replicas != 0 {
		return false
	}
	if x.Version != "" {
		return false
	}
	return true
}

func (x Instance) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_1); err != nil {
		return err
	}
	if x.Handle != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Handle); err != nil {
			return err
		}
	}
	if x.MountName != "" {
		if err := enc.NextFieldValueString(1, vdl.StringType, x.MountName); err != nil {
			return err
		}
	}
	if len(x.BlessingNames) != 0 {
		if err := enc.NextField(2); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_1(enc, x.BlessingNames); err != nil {
			return err
		}
	}
	if !x.CreationTime.IsZero() {
		if err := enc.NextField(3); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, x.CreationTime); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Replicas != 0 {
		if err := enc.NextFieldValueInt(4, vdl.Int32Type, int64(x.Replicas)); err != nil {
			return err
		}
	}
	if x.Version != "" {
		if err := enc.NextFieldValueString(5, vdl.StringType, x.Version); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_1(enc vdl.Encoder, x []string) error {
	if err := enc.StartValue(__VDLType_list_2); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Instance) VDLRead(dec vdl.Decoder) error {
	*x = Instance{}
	if err := dec.StartValue(__VDLType_struct_1); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_1 {
			index = __VDLType_struct_1.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Handle = value
			}
		case 1:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.MountName = value
			}
		case 2:
			if err := __VDLReadAnon_list_1(dec, &x.BlessingNames); err != nil {
				return err
			}
		case 3:
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &x.CreationTime); err != nil {
				return err
			}
		case 4:
			switch value, err := dec.ReadValueInt(32); {
			case err != nil:
				return err
			default:
				x.Replicas = int32(value)
			}
		case 5:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Version = value
			}
		}
	}
}

func __VDLReadAnon_list_1(dec vdl.Decoder, x *[]string) error {
	if err := dec.StartValue(__VDLType_list_2); err != nil {
		return err
	}
	if len := dec.LenHint(); len > 0 {
		*x = make([]string, 0, len)
	} else {
		*x = nil
	}
	for {
		switch done, elem, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		default:
			*x = append(*x, elem)
		}
	}
}

//////////////////////////////////////////////////
// Interface definitions

// AllocatorClientMethods is the client interface
// containing Allocator methods.
type AllocatorClientMethods interface {
	// Create creates a new instance of the service.
	// It returns a handle for the new instance.
	Create(*context.T, ...rpc.CallOpt) (handle string, _ error)
	// Destroy destroys the instance with the given handle.
	Destroy(_ *context.T, handle string, _ ...rpc.CallOpt) error
	// List returns a list of all the instances owned by the caller.
	List(*context.T, ...rpc.CallOpt) (instances []Instance, _ error)
}

// AllocatorClientStub adds universal methods to AllocatorClientMethods.
type AllocatorClientStub interface {
	AllocatorClientMethods
	rpc.UniversalServiceMethods
}

// AllocatorClient returns a client stub for Allocator.
func AllocatorClient(name string) AllocatorClientStub {
	return implAllocatorClientStub{name}
}

type implAllocatorClientStub struct {
	name string
}

func (c implAllocatorClientStub) Create(ctx *context.T, opts ...rpc.CallOpt) (o0 string, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Create", nil, []interface{}{&o0}, opts...)
	return
}

func (c implAllocatorClientStub) Destroy(ctx *context.T, i0 string, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Destroy", []interface{}{i0}, nil, opts...)
	return
}

func (c implAllocatorClientStub) List(ctx *context.T, opts ...rpc.CallOpt) (o0 []Instance, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "List", nil, []interface{}{&o0}, opts...)
	return
}

// AllocatorServerMethods is the interface a server writer
// implements for Allocator.
type AllocatorServerMethods interface {
	// Create creates a new instance of the service.
	// It returns a handle for the new instance.
	Create(*context.T, rpc.ServerCall) (handle string, _ error)
	// Destroy destroys the instance with the given handle.
	Destroy(_ *context.T, _ rpc.ServerCall, handle string) error
	// List returns a list of all the instances owned by the caller.
	List(*context.T, rpc.ServerCall) (instances []Instance, _ error)
}

// AllocatorServerStubMethods is the server interface containing
// Allocator methods, as expected by rpc.Server.
// There is no difference between this interface and AllocatorServerMethods
// since there are no streaming methods.
type AllocatorServerStubMethods AllocatorServerMethods

// AllocatorServerStub adds universal methods to AllocatorServerStubMethods.
type AllocatorServerStub interface {
	AllocatorServerStubMethods
	// Describe the Allocator interfaces.
	Describe__() []rpc.InterfaceDesc
}

// AllocatorServer returns a server stub for Allocator.
// It converts an implementation of AllocatorServerMethods into
// an object that may be used by rpc.Server.
func AllocatorServer(impl AllocatorServerMethods) AllocatorServerStub {
	stub := implAllocatorServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implAllocatorServerStub struct {
	impl AllocatorServerMethods
	gs   *rpc.GlobState
}

func (s implAllocatorServerStub) Create(ctx *context.T, call rpc.ServerCall) (string, error) {
	return s.impl.Create(ctx, call)
}

func (s implAllocatorServerStub) Destroy(ctx *context.T, call rpc.ServerCall, i0 string) error {
	return s.impl.Destroy(ctx, call, i0)
}

func (s implAllocatorServerStub) List(ctx *context.T, call rpc.ServerCall) ([]Instance, error) {
	return s.impl.List(ctx, call)
}

func (s implAllocatorServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implAllocatorServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{AllocatorDesc}
}

// AllocatorDesc describes the Allocator interface.
var AllocatorDesc rpc.InterfaceDesc = descAllocator

// descAllocator hides the desc to keep godoc clean.
var descAllocator = rpc.InterfaceDesc{
	Name:    "Allocator",
	PkgPath: "v.io/x/ref/services/allocator",
	Methods: []rpc.MethodDesc{
		{
			Name: "Create",
			Doc:  "// Create creates a new instance of the service.\n// It returns a handle for the new instance.",
			OutArgs: []rpc.ArgDesc{
				{"handle", ``}, // string
			},
		},
		{
			Name: "Destroy",
			Doc:  "// Destroy destroys the instance with the given handle.",
			InArgs: []rpc.ArgDesc{
				{"handle", ``}, // string
			},
		},
		{
			Name: "List",
			Doc:  "// List returns a list of all the instances owned by the caller.",
			OutArgs: []rpc.ArgDesc{
				{"instances", ``}, // []Instance
			},
		},
	},
}

// Hold type definitions in package-level variables, for better performance.
var (
	__VDLType_struct_1 *vdl.Type
	__VDLType_list_2   *vdl.Type
	__VDLType_struct_3 *vdl.Type
)

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*Instance)(nil))

	// Initialize type definitions.
	__VDLType_struct_1 = vdl.TypeOf((*Instance)(nil)).Elem()
	__VDLType_list_2 = vdl.TypeOf((*[]string)(nil))
	__VDLType_struct_3 = vdl.TypeOf((*vdltime.Time)(nil)).Elem()

	return struct{}{}
}
