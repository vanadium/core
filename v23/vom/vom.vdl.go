// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: vom

//nolint:golint
package vom

import (
	"fmt"

	"v.io/v23/vdl"
)

var _ = initializeVDL() // Must be first; see initializeVDL comments for details.

// Type definitions
// ================

// ControlKind enumerates the different kinds of control bytes.
type ControlKind int

const (
	ControlKindNil ControlKind = iota
	ControlKindEnd
	ControlKindIncompleteType
)

// ControlKindAll holds all labels for ControlKind.
var ControlKindAll = [...]ControlKind{ControlKindNil, ControlKindEnd, ControlKindIncompleteType}

// ControlKindFromString creates a ControlKind from a string label.
//nolint:deadcode,unused
func ControlKindFromString(label string) (x ControlKind, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ControlKind) Set(label string) error {
	switch label {
	case "Nil", "nil":
		*x = ControlKindNil
		return nil
	case "End", "end":
		*x = ControlKindEnd
		return nil
	case "IncompleteType", "incompletetype":
		*x = ControlKindIncompleteType
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in vom.ControlKind", label)
}

// String returns the string label of x.
func (x ControlKind) String() string {
	switch x {
	case ControlKindNil:
		return "Nil"
	case ControlKindEnd:
		return "End"
	case ControlKindIncompleteType:
		return "IncompleteType"
	}
	return ""
}

func (ControlKind) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.ControlKind"`
	Enum struct{ Nil, End, IncompleteType string }
}) {
}

func (x ControlKind) VDLIsZero() bool { //nolint:gocyclo
	return x == ControlKindNil
}

func (x ControlKind) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueString(vdlTypeEnum1, x.String()); err != nil {
		return err
	}
	return nil
}

func (x *ControlKind) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		if err := x.Set(value); err != nil {
			return err
		}
	}
	return nil
}

type (
	// Primitive represents any single field of the Primitive union type.
	//
	// Primitive represents one of the primitive vom values.  All vom values are
	// composed of combinations of these primitives.
	Primitive interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// VDLReflect describes the Primitive union type.
		VDLReflect(vdlPrimitiveReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// PrimitivePBool represents field PBool of the Primitive union type.
	PrimitivePBool struct{ Value bool }
	// PrimitivePByte represents field PByte of the Primitive union type.
	PrimitivePByte struct{ Value byte }
	// PrimitivePUint represents field PUint of the Primitive union type.
	PrimitivePUint struct{ Value uint64 }
	// PrimitivePInt represents field PInt of the Primitive union type.
	PrimitivePInt struct{ Value int64 }
	// PrimitivePFloat represents field PFloat of the Primitive union type.
	PrimitivePFloat struct{ Value float64 }
	// PrimitivePString represents field PString of the Primitive union type.
	PrimitivePString struct{ Value string }
	// PrimitivePControl represents field PControl of the Primitive union type.
	PrimitivePControl struct{ Value ControlKind }
	// vdlPrimitiveReflect describes the Primitive union type.
	vdlPrimitiveReflect struct {
		Name  string `vdl:"v.io/v23/vom.Primitive"`
		Type  Primitive
		Union struct {
			PBool    PrimitivePBool
			PByte    PrimitivePByte
			PUint    PrimitivePUint
			PInt     PrimitivePInt
			PFloat   PrimitivePFloat
			PString  PrimitivePString
			PControl PrimitivePControl
		}
	}
)

func (x PrimitivePBool) Index() int                     { return 0 }
func (x PrimitivePBool) Interface() interface{}         { return x.Value }
func (x PrimitivePBool) Name() string                   { return "PBool" }
func (x PrimitivePBool) VDLReflect(vdlPrimitiveReflect) {}

func (x PrimitivePByte) Index() int                     { return 1 }
func (x PrimitivePByte) Interface() interface{}         { return x.Value }
func (x PrimitivePByte) Name() string                   { return "PByte" }
func (x PrimitivePByte) VDLReflect(vdlPrimitiveReflect) {}

func (x PrimitivePUint) Index() int                     { return 2 }
func (x PrimitivePUint) Interface() interface{}         { return x.Value }
func (x PrimitivePUint) Name() string                   { return "PUint" }
func (x PrimitivePUint) VDLReflect(vdlPrimitiveReflect) {}

func (x PrimitivePInt) Index() int                     { return 3 }
func (x PrimitivePInt) Interface() interface{}         { return x.Value }
func (x PrimitivePInt) Name() string                   { return "PInt" }
func (x PrimitivePInt) VDLReflect(vdlPrimitiveReflect) {}

func (x PrimitivePFloat) Index() int                     { return 4 }
func (x PrimitivePFloat) Interface() interface{}         { return x.Value }
func (x PrimitivePFloat) Name() string                   { return "PFloat" }
func (x PrimitivePFloat) VDLReflect(vdlPrimitiveReflect) {}

func (x PrimitivePString) Index() int                     { return 5 }
func (x PrimitivePString) Interface() interface{}         { return x.Value }
func (x PrimitivePString) Name() string                   { return "PString" }
func (x PrimitivePString) VDLReflect(vdlPrimitiveReflect) {}

func (x PrimitivePControl) Index() int                     { return 6 }
func (x PrimitivePControl) Interface() interface{}         { return x.Value }
func (x PrimitivePControl) Name() string                   { return "PControl" }
func (x PrimitivePControl) VDLReflect(vdlPrimitiveReflect) {}

func (x PrimitivePBool) VDLIsZero() bool { //nolint:gocyclo
	return !x.Value
}

func (x PrimitivePByte) VDLIsZero() bool {
	return false
}

func (x PrimitivePUint) VDLIsZero() bool {
	return false
}

func (x PrimitivePInt) VDLIsZero() bool {
	return false
}

func (x PrimitivePFloat) VDLIsZero() bool {
	return false
}

func (x PrimitivePString) VDLIsZero() bool {
	return false
}

func (x PrimitivePControl) VDLIsZero() bool {
	return false
}

func (x PrimitivePBool) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion2); err != nil {
		return err
	}
	if err := enc.NextFieldValueBool(0, vdl.BoolType, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePByte) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion2); err != nil {
		return err
	}
	if err := enc.NextFieldValueUint(1, vdl.ByteType, uint64(x.Value)); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePUint) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion2); err != nil {
		return err
	}
	if err := enc.NextFieldValueUint(2, vdl.Uint64Type, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePInt) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion2); err != nil {
		return err
	}
	if err := enc.NextFieldValueInt(3, vdl.Int64Type, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePFloat) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion2); err != nil {
		return err
	}
	if err := enc.NextFieldValueFloat(4, vdl.Float64Type, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePString) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion2); err != nil {
		return err
	}
	if err := enc.NextFieldValueString(5, vdl.StringType, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePControl) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion2); err != nil {
		return err
	}
	if err := enc.NextFieldValueString(6, vdlTypeEnum1, x.Value.String()); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadPrimitive(dec vdl.Decoder, x *Primitive) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeUnion2); err != nil {
		return err
	}
	decType := dec.Type()
	index, err := dec.NextField()
	switch {
	case err != nil:
		return err
	case index == -1:
		return fmt.Errorf("missing field in union %T, from %v", x, decType)
	}
	if decType != vdlTypeUnion2 {
		name := decType.Field(index).Name
		index = vdlTypeUnion2.FieldIndexByName(name)
		if index == -1 {
			return fmt.Errorf("field %q not in union %T, from %v", name, x, decType)
		}
	}
	switch index {
	case 0:
		var field PrimitivePBool
		switch value, err := dec.ReadValueBool(); {
		case err != nil:
			return err
		default:
			field.Value = value
		}
		*x = field
	case 1:
		var field PrimitivePByte
		switch value, err := dec.ReadValueUint(8); {
		case err != nil:
			return err
		default:
			field.Value = byte(value)
		}
		*x = field
	case 2:
		var field PrimitivePUint
		switch value, err := dec.ReadValueUint(64); {
		case err != nil:
			return err
		default:
			field.Value = value
		}
		*x = field
	case 3:
		var field PrimitivePInt
		switch value, err := dec.ReadValueInt(64); {
		case err != nil:
			return err
		default:
			field.Value = value
		}
		*x = field
	case 4:
		var field PrimitivePFloat
		switch value, err := dec.ReadValueFloat(64); {
		case err != nil:
			return err
		default:
			field.Value = value
		}
		*x = field
	case 5:
		var field PrimitivePString
		switch value, err := dec.ReadValueString(); {
		case err != nil:
			return err
		default:
			field.Value = value
		}
		*x = field
	case 6:
		var field PrimitivePControl
		switch value, err := dec.ReadValueString(); {
		case err != nil:
			return err
		default:
			if err := field.Value.Set(value); err != nil {
				return err
			}
		}
		*x = field
	}
	switch index, err := dec.NextField(); {
	case err != nil:
		return err
	case index != -1:
		return fmt.Errorf("extra field %d in union %T, from %v", index, x, dec.Type())
	}
	return dec.FinishValue()
}

// DumpKind enumerates the different kinds of dump atoms.
type DumpKind int

const (
	DumpKindVersion DumpKind = iota
	DumpKindControl
	DumpKindMsgId
	DumpKindTypeMsg
	DumpKindValueMsg
	DumpKindMsgLen
	DumpKindAnyMsgLen
	DumpKindAnyLensLen
	DumpKindTypeIdsLen
	DumpKindTypeId
	DumpKindPrimValue
	DumpKindByteLen
	DumpKindValueLen
	DumpKindIndex
	DumpKindWireTypeIndex
)

// DumpKindAll holds all labels for DumpKind.
var DumpKindAll = [...]DumpKind{DumpKindVersion, DumpKindControl, DumpKindMsgId, DumpKindTypeMsg, DumpKindValueMsg, DumpKindMsgLen, DumpKindAnyMsgLen, DumpKindAnyLensLen, DumpKindTypeIdsLen, DumpKindTypeId, DumpKindPrimValue, DumpKindByteLen, DumpKindValueLen, DumpKindIndex, DumpKindWireTypeIndex}

// DumpKindFromString creates a DumpKind from a string label.
//nolint:deadcode,unused
func DumpKindFromString(label string) (x DumpKind, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *DumpKind) Set(label string) error { //nolint:gocyclo
	switch label {
	case "Version", "version":
		*x = DumpKindVersion
		return nil
	case "Control", "control":
		*x = DumpKindControl
		return nil
	case "MsgId", "msgid":
		*x = DumpKindMsgId
		return nil
	case "TypeMsg", "typemsg":
		*x = DumpKindTypeMsg
		return nil
	case "ValueMsg", "valuemsg":
		*x = DumpKindValueMsg
		return nil
	case "MsgLen", "msglen":
		*x = DumpKindMsgLen
		return nil
	case "AnyMsgLen", "anymsglen":
		*x = DumpKindAnyMsgLen
		return nil
	case "AnyLensLen", "anylenslen":
		*x = DumpKindAnyLensLen
		return nil
	case "TypeIdsLen", "typeidslen":
		*x = DumpKindTypeIdsLen
		return nil
	case "TypeId", "typeid":
		*x = DumpKindTypeId
		return nil
	case "PrimValue", "primvalue":
		*x = DumpKindPrimValue
		return nil
	case "ByteLen", "bytelen":
		*x = DumpKindByteLen
		return nil
	case "ValueLen", "valuelen":
		*x = DumpKindValueLen
		return nil
	case "Index", "index":
		*x = DumpKindIndex
		return nil
	case "WireTypeIndex", "wiretypeindex":
		*x = DumpKindWireTypeIndex
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in vom.DumpKind", label)
}

// String returns the string label of x.
func (x DumpKind) String() string { //nolint:gocyclo
	switch x {
	case DumpKindVersion:
		return "Version"
	case DumpKindControl:
		return "Control"
	case DumpKindMsgId:
		return "MsgId"
	case DumpKindTypeMsg:
		return "TypeMsg"
	case DumpKindValueMsg:
		return "ValueMsg"
	case DumpKindMsgLen:
		return "MsgLen"
	case DumpKindAnyMsgLen:
		return "AnyMsgLen"
	case DumpKindAnyLensLen:
		return "AnyLensLen"
	case DumpKindTypeIdsLen:
		return "TypeIdsLen"
	case DumpKindTypeId:
		return "TypeId"
	case DumpKindPrimValue:
		return "PrimValue"
	case DumpKindByteLen:
		return "ByteLen"
	case DumpKindValueLen:
		return "ValueLen"
	case DumpKindIndex:
		return "Index"
	case DumpKindWireTypeIndex:
		return "WireTypeIndex"
	}
	return ""
}

func (DumpKind) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.DumpKind"`
	Enum struct{ Version, Control, MsgId, TypeMsg, ValueMsg, MsgLen, AnyMsgLen, AnyLensLen, TypeIdsLen, TypeId, PrimValue, ByteLen, ValueLen, Index, WireTypeIndex string }
}) {
}

func (x DumpKind) VDLIsZero() bool { //nolint:gocyclo
	return x == DumpKindVersion
}

func (x DumpKind) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueString(vdlTypeEnum3, x.String()); err != nil {
		return err
	}
	return nil
}

func (x *DumpKind) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		if err := x.Set(value); err != nil {
			return err
		}
	}
	return nil
}

// DumpAtom describes a single indivisible piece of the vom encoding.  The vom
// encoding is composed of a stream of these atoms.
type DumpAtom struct {
	Kind  DumpKind  // The kind of this atom.
	Bytes []byte    // Raw bytes in the vom encoding representing this atom.
	Data  Primitive // Primitive data corresponding to the raw bytes.
	Debug string    // Free-form debug string with more information.
}

func (DumpAtom) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.DumpAtom"`
}) {
}

func (x DumpAtom) VDLIsZero() bool { //nolint:gocyclo
	if x.Kind != DumpKindVersion {
		return false
	}
	if len(x.Bytes) != 0 {
		return false
	}
	if x.Data != nil && !x.Data.VDLIsZero() {
		return false
	}
	if x.Debug != "" {
		return false
	}
	return true
}

func (x DumpAtom) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct4); err != nil {
		return err
	}
	if x.Kind != DumpKindVersion {
		if err := enc.NextFieldValueString(0, vdlTypeEnum3, x.Kind.String()); err != nil {
			return err
		}
	}
	if len(x.Bytes) != 0 {
		if err := enc.NextFieldValueBytes(1, vdlTypeList5, x.Bytes); err != nil {
			return err
		}
	}
	if x.Data != nil && !x.Data.VDLIsZero() {
		if err := enc.NextField(2); err != nil {
			return err
		}
		if err := x.Data.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Debug != "" {
		if err := enc.NextFieldValueString(3, vdl.StringType, x.Debug); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *DumpAtom) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = DumpAtom{
		Data: PrimitivePBool{},
	}
	if err := dec.StartValue(vdlTypeStruct4); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct4 {
			index = vdlTypeStruct4.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				if err := x.Kind.Set(value); err != nil {
					return err
				}
			}
		case 1:
			if err := dec.ReadValueBytes(-1, &x.Bytes); err != nil {
				return err
			}
		case 2:
			if err := VDLReadPrimitive(dec, &x.Data); err != nil {
				return err
			}
		case 3:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Debug = value
			}
		}
	}
}

// Version is the vom version.
type Version byte

func (Version) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.Version"`
}) {
}

func (x Version) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x Version) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueUint(vdlTypeByte6, uint64(x)); err != nil {
		return err
	}
	return nil
}

func (x *Version) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueUint(8); {
	case err != nil:
		return err
	default:
		*x = Version(value)
	}
	return nil
}

// TypeId uniquely identifies a type definition within a vom stream.
type TypeId uint64

func (TypeId) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.TypeId"`
}) {
}

func (x TypeId) VDLIsZero() bool { //nolint:gocyclo
	return x == 0
}

func (x TypeId) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueUint(vdlTypeUint647, uint64(x)); err != nil {
		return err
	}
	return nil
}

func (x *TypeId) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueUint(64); {
	case err != nil:
		return err
	default:
		*x = TypeId(value)
	}
	return nil
}

// wireNamed represents a type definition for named primitives.
type wireNamed struct {
	Name string
	Base TypeId
}

func (wireNamed) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireNamed"`
}) {
}

func (x wireNamed) VDLIsZero() bool { //nolint:gocyclo
	return x == wireNamed{}
}

func (x wireNamed) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct8); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if x.Base != 0 {
		if err := enc.NextFieldValueUint(1, vdlTypeUint647, uint64(x.Base)); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireNamed) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = wireNamed{}
	if err := dec.StartValue(vdlTypeStruct8); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct8 {
			index = vdlTypeStruct8.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.Base = TypeId(value)
			}
		}
	}
}

// wireEnum represents an type definition for enum types.
type wireEnum struct {
	Name   string
	Labels []string
}

func (wireEnum) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireEnum"`
}) {
}

func (x wireEnum) VDLIsZero() bool { //nolint:gocyclo
	if x.Name != "" {
		return false
	}
	if len(x.Labels) != 0 {
		return false
	}
	return true
}

func (x wireEnum) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct9); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if len(x.Labels) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := vdlWriteAnonList1(enc, x.Labels); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonList1(enc vdl.Encoder, x []string) error {
	if err := enc.StartValue(vdlTypeList10); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireEnum) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = wireEnum{}
	if err := dec.StartValue(vdlTypeStruct9); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct9 {
			index = vdlTypeStruct9.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			if err := vdlReadAnonList1(dec, &x.Labels); err != nil {
				return err
			}
		}
	}
}

func vdlReadAnonList1(dec vdl.Decoder, x *[]string) error {
	if err := dec.StartValue(vdlTypeList10); err != nil {
		return err
	}
	if len := dec.LenHint(); len > 0 {
		*x = make([]string, 0, len)
	} else {
		*x = nil
	}
	for {
		switch done, elem, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		default:
			*x = append(*x, elem)
		}
	}
}

// wireArray represents an type definition for array types.
type wireArray struct {
	Name string
	Elem TypeId
	Len  uint64
}

func (wireArray) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireArray"`
}) {
}

func (x wireArray) VDLIsZero() bool { //nolint:gocyclo
	return x == wireArray{}
}

func (x wireArray) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct11); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if x.Elem != 0 {
		if err := enc.NextFieldValueUint(1, vdlTypeUint647, uint64(x.Elem)); err != nil {
			return err
		}
	}
	if x.Len != 0 {
		if err := enc.NextFieldValueUint(2, vdl.Uint64Type, x.Len); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireArray) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = wireArray{}
	if err := dec.StartValue(vdlTypeStruct11); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct11 {
			index = vdlTypeStruct11.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.Elem = TypeId(value)
			}
		case 2:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.Len = value
			}
		}
	}
}

// wireList represents a type definition for list types.
type wireList struct {
	Name string
	Elem TypeId
}

func (wireList) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireList"`
}) {
}

func (x wireList) VDLIsZero() bool { //nolint:gocyclo
	return x == wireList{}
}

func (x wireList) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct12); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if x.Elem != 0 {
		if err := enc.NextFieldValueUint(1, vdlTypeUint647, uint64(x.Elem)); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireList) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = wireList{}
	if err := dec.StartValue(vdlTypeStruct12); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct12 {
			index = vdlTypeStruct12.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.Elem = TypeId(value)
			}
		}
	}
}

// wireSet represents a type definition for set types.
type wireSet struct {
	Name string
	Key  TypeId
}

func (wireSet) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireSet"`
}) {
}

func (x wireSet) VDLIsZero() bool { //nolint:gocyclo
	return x == wireSet{}
}

func (x wireSet) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct13); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if x.Key != 0 {
		if err := enc.NextFieldValueUint(1, vdlTypeUint647, uint64(x.Key)); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireSet) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = wireSet{}
	if err := dec.StartValue(vdlTypeStruct13); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct13 {
			index = vdlTypeStruct13.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.Key = TypeId(value)
			}
		}
	}
}

// wireMap represents a type definition for map types.
type wireMap struct {
	Name string
	Key  TypeId
	Elem TypeId
}

func (wireMap) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireMap"`
}) {
}

func (x wireMap) VDLIsZero() bool { //nolint:gocyclo
	return x == wireMap{}
}

func (x wireMap) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct14); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if x.Key != 0 {
		if err := enc.NextFieldValueUint(1, vdlTypeUint647, uint64(x.Key)); err != nil {
			return err
		}
	}
	if x.Elem != 0 {
		if err := enc.NextFieldValueUint(2, vdlTypeUint647, uint64(x.Elem)); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireMap) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = wireMap{}
	if err := dec.StartValue(vdlTypeStruct14); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct14 {
			index = vdlTypeStruct14.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.Key = TypeId(value)
			}
		case 2:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.Elem = TypeId(value)
			}
		}
	}
}

// wireField represents a field in a struct or union type.
type wireField struct {
	Name string
	Type TypeId
}

func (wireField) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireField"`
}) {
}

func (x wireField) VDLIsZero() bool { //nolint:gocyclo
	return x == wireField{}
}

func (x wireField) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct15); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if x.Type != 0 {
		if err := enc.NextFieldValueUint(1, vdlTypeUint647, uint64(x.Type)); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireField) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = wireField{}
	if err := dec.StartValue(vdlTypeStruct15); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct15 {
			index = vdlTypeStruct15.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.Type = TypeId(value)
			}
		}
	}
}

// wireStruct represents a type definition for struct types.
type wireStruct struct {
	Name   string
	Fields []wireField
}

func (wireStruct) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireStruct"`
}) {
}

func (x wireStruct) VDLIsZero() bool { //nolint:gocyclo
	if x.Name != "" {
		return false
	}
	if len(x.Fields) != 0 {
		return false
	}
	return true
}

func (x wireStruct) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct16); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if len(x.Fields) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := vdlWriteAnonList2(enc, x.Fields); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonList2(enc vdl.Encoder, x []wireField) error {
	if err := enc.StartValue(vdlTypeList17); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireStruct) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = wireStruct{}
	if err := dec.StartValue(vdlTypeStruct16); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct16 {
			index = vdlTypeStruct16.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			if err := vdlReadAnonList2(dec, &x.Fields); err != nil {
				return err
			}
		}
	}
}

func vdlReadAnonList2(dec vdl.Decoder, x *[]wireField) error {
	if err := dec.StartValue(vdlTypeList17); err != nil {
		return err
	}
	if len := dec.LenHint(); len > 0 {
		*x = make([]wireField, 0, len)
	} else {
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		default:
			var elem wireField
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
			*x = append(*x, elem)
		}
	}
}

// wireUnion represents a type definition for union types.
type wireUnion struct {
	Name   string
	Fields []wireField
}

func (wireUnion) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireUnion"`
}) {
}

func (x wireUnion) VDLIsZero() bool { //nolint:gocyclo
	if x.Name != "" {
		return false
	}
	if len(x.Fields) != 0 {
		return false
	}
	return true
}

func (x wireUnion) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct18); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if len(x.Fields) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := vdlWriteAnonList2(enc, x.Fields); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireUnion) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = wireUnion{}
	if err := dec.StartValue(vdlTypeStruct18); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct18 {
			index = vdlTypeStruct18.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			if err := vdlReadAnonList2(dec, &x.Fields); err != nil {
				return err
			}
		}
	}
}

// wireOptional represents an type definition for optional types.
type wireOptional struct {
	Name string
	Elem TypeId
}

func (wireOptional) VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireOptional"`
}) {
}

func (x wireOptional) VDLIsZero() bool { //nolint:gocyclo
	return x == wireOptional{}
}

func (x wireOptional) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct19); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if x.Elem != 0 {
		if err := enc.NextFieldValueUint(1, vdlTypeUint647, uint64(x.Elem)); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireOptional) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = wireOptional{}
	if err := dec.StartValue(vdlTypeStruct19); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct19 {
			index = vdlTypeStruct19.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.Elem = TypeId(value)
			}
		}
	}
}

type (
	// wireType represents any single field of the wireType union type.
	//
	// The wireType union is used to encode the payload part of each type message,
	// using the regular rules for encoding union values.  But unlike our regular
	// encoding, the type message for wireType itself (and its fields) are never
	// encoded; we need to bootstrap the system.  Thus unlike regular values, the
	// ordering of fields within the wire* types cannot be changed.
	wireType interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// VDLReflect describes the wireType union type.
		VDLReflect(vdlwireTypeReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// wireTypeNamedT represents field NamedT of the wireType union type.
	//
	// FIELD INDICES MUST NOT BE CHANGED.
	wireTypeNamedT struct{ Value wireNamed } // INDEX = 0
	// wireTypeEnumT represents field EnumT of the wireType union type.
	wireTypeEnumT struct{ Value wireEnum } // INDEX = 1
	// wireTypeArrayT represents field ArrayT of the wireType union type.
	wireTypeArrayT struct{ Value wireArray } // INDEX = 2
	// wireTypeListT represents field ListT of the wireType union type.
	wireTypeListT struct{ Value wireList } // INDEX = 3
	// wireTypeSetT represents field SetT of the wireType union type.
	wireTypeSetT struct{ Value wireSet } // INDEX = 4
	// wireTypeMapT represents field MapT of the wireType union type.
	wireTypeMapT struct{ Value wireMap } // INDEX = 5
	// wireTypeStructT represents field StructT of the wireType union type.
	wireTypeStructT struct{ Value wireStruct } // INDEX = 6
	// wireTypeUnionT represents field UnionT of the wireType union type.
	wireTypeUnionT struct{ Value wireUnion } // INDEX = 7
	// wireTypeOptionalT represents field OptionalT of the wireType union type.
	wireTypeOptionalT struct{ Value wireOptional } // INDEX = 8
	// vdlwireTypeReflect describes the wireType union type.
	vdlwireTypeReflect struct {
		Name  string `vdl:"v.io/v23/vom.wireType"`
		Type  wireType
		Union struct {
			NamedT    wireTypeNamedT
			EnumT     wireTypeEnumT
			ArrayT    wireTypeArrayT
			ListT     wireTypeListT
			SetT      wireTypeSetT
			MapT      wireTypeMapT
			StructT   wireTypeStructT
			UnionT    wireTypeUnionT
			OptionalT wireTypeOptionalT
		}
	}
)

func (x wireTypeNamedT) Index() int                    { return 0 }
func (x wireTypeNamedT) Interface() interface{}        { return x.Value }
func (x wireTypeNamedT) Name() string                  { return "NamedT" }
func (x wireTypeNamedT) VDLReflect(vdlwireTypeReflect) {}

func (x wireTypeEnumT) Index() int                    { return 1 }
func (x wireTypeEnumT) Interface() interface{}        { return x.Value }
func (x wireTypeEnumT) Name() string                  { return "EnumT" }
func (x wireTypeEnumT) VDLReflect(vdlwireTypeReflect) {}

func (x wireTypeArrayT) Index() int                    { return 2 }
func (x wireTypeArrayT) Interface() interface{}        { return x.Value }
func (x wireTypeArrayT) Name() string                  { return "ArrayT" }
func (x wireTypeArrayT) VDLReflect(vdlwireTypeReflect) {}

func (x wireTypeListT) Index() int                    { return 3 }
func (x wireTypeListT) Interface() interface{}        { return x.Value }
func (x wireTypeListT) Name() string                  { return "ListT" }
func (x wireTypeListT) VDLReflect(vdlwireTypeReflect) {}

func (x wireTypeSetT) Index() int                    { return 4 }
func (x wireTypeSetT) Interface() interface{}        { return x.Value }
func (x wireTypeSetT) Name() string                  { return "SetT" }
func (x wireTypeSetT) VDLReflect(vdlwireTypeReflect) {}

func (x wireTypeMapT) Index() int                    { return 5 }
func (x wireTypeMapT) Interface() interface{}        { return x.Value }
func (x wireTypeMapT) Name() string                  { return "MapT" }
func (x wireTypeMapT) VDLReflect(vdlwireTypeReflect) {}

func (x wireTypeStructT) Index() int                    { return 6 }
func (x wireTypeStructT) Interface() interface{}        { return x.Value }
func (x wireTypeStructT) Name() string                  { return "StructT" }
func (x wireTypeStructT) VDLReflect(vdlwireTypeReflect) {}

func (x wireTypeUnionT) Index() int                    { return 7 }
func (x wireTypeUnionT) Interface() interface{}        { return x.Value }
func (x wireTypeUnionT) Name() string                  { return "UnionT" }
func (x wireTypeUnionT) VDLReflect(vdlwireTypeReflect) {}

func (x wireTypeOptionalT) Index() int                    { return 8 }
func (x wireTypeOptionalT) Interface() interface{}        { return x.Value }
func (x wireTypeOptionalT) Name() string                  { return "OptionalT" }
func (x wireTypeOptionalT) VDLReflect(vdlwireTypeReflect) {}

func (x wireTypeNamedT) VDLIsZero() bool { //nolint:gocyclo
	return x.Value == wireNamed{}
}

func (x wireTypeEnumT) VDLIsZero() bool {
	return false
}

func (x wireTypeArrayT) VDLIsZero() bool {
	return false
}

func (x wireTypeListT) VDLIsZero() bool {
	return false
}

func (x wireTypeSetT) VDLIsZero() bool {
	return false
}

func (x wireTypeMapT) VDLIsZero() bool {
	return false
}

func (x wireTypeStructT) VDLIsZero() bool {
	return false
}

func (x wireTypeUnionT) VDLIsZero() bool {
	return false
}

func (x wireTypeOptionalT) VDLIsZero() bool {
	return false
}

func (x wireTypeNamedT) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion20); err != nil {
		return err
	}
	if err := enc.NextField(0); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeEnumT) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion20); err != nil {
		return err
	}
	if err := enc.NextField(1); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeArrayT) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion20); err != nil {
		return err
	}
	if err := enc.NextField(2); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeListT) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion20); err != nil {
		return err
	}
	if err := enc.NextField(3); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeSetT) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion20); err != nil {
		return err
	}
	if err := enc.NextField(4); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeMapT) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion20); err != nil {
		return err
	}
	if err := enc.NextField(5); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeStructT) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion20); err != nil {
		return err
	}
	if err := enc.NextField(6); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeUnionT) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion20); err != nil {
		return err
	}
	if err := enc.NextField(7); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeOptionalT) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion20); err != nil {
		return err
	}
	if err := enc.NextField(8); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlReadwireType(dec vdl.Decoder, x *wireType) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeUnion20); err != nil {
		return err
	}
	decType := dec.Type()
	index, err := dec.NextField()
	switch {
	case err != nil:
		return err
	case index == -1:
		return fmt.Errorf("missing field in union %T, from %v", x, decType)
	}
	if decType != vdlTypeUnion20 {
		name := decType.Field(index).Name
		index = vdlTypeUnion20.FieldIndexByName(name)
		if index == -1 {
			return fmt.Errorf("field %q not in union %T, from %v", name, x, decType)
		}
	}
	switch index {
	case 0:
		var field wireTypeNamedT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 1:
		var field wireTypeEnumT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 2:
		var field wireTypeArrayT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 3:
		var field wireTypeListT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 4:
		var field wireTypeSetT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 5:
		var field wireTypeMapT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 6:
		var field wireTypeStructT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 7:
		var field wireTypeUnionT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 8:
		var field wireTypeOptionalT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	}
	switch index, err := dec.NextField(); {
	case err != nil:
		return err
	case index != -1:
		return fmt.Errorf("extra field %d in union %T, from %v", index, x, dec.Type())
	}
	return dec.FinishValue()
}

// Const definitions
// =================

const Version80 = Version(128)
const Version81 = Version(129)
const DefaultVersion = Version(129)

// Primitive types.
const WireIdBool = TypeId(1)
const WireIdByte = TypeId(2)
const WireIdString = TypeId(3)
const WireIdUint16 = TypeId(4)
const WireIdUint32 = TypeId(5)
const WireIdUint64 = TypeId(6)
const WireIdInt16 = TypeId(7)
const WireIdInt32 = TypeId(8)
const WireIdInt64 = TypeId(9)
const WireIdFloat32 = TypeId(10)
const WireIdFloat64 = TypeId(11)

// Wire ids 12 and 13 were previously used for complex64 and complex 128.
const WireIdTypeObject = TypeId(14)
const WireIdAny = TypeId(15)
const WireIdInt8 = TypeId(16)

// Other commonly used composites.
const WireIdByteList = TypeId(39)
const WireIdStringList = TypeId(40)

// The first user-defined TypeId is 41.
const WireIdFirstUserType = TypeId(41)
const WireCtrlNil = byte(224)            // Nil in optional or any
const WireCtrlEnd = byte(225)            // End of struct or union
const WireCtrlTypeIncomplete = byte(226) // Marks that the type message is incomplete until future messages are received

// Hold type definitions in package-level variables, for better performance.
//nolint:unused
var (
	vdlTypeEnum1    *vdl.Type
	vdlTypeUnion2   *vdl.Type
	vdlTypeEnum3    *vdl.Type
	vdlTypeStruct4  *vdl.Type
	vdlTypeList5    *vdl.Type
	vdlTypeByte6    *vdl.Type
	vdlTypeUint647  *vdl.Type
	vdlTypeStruct8  *vdl.Type
	vdlTypeStruct9  *vdl.Type
	vdlTypeList10   *vdl.Type
	vdlTypeStruct11 *vdl.Type
	vdlTypeStruct12 *vdl.Type
	vdlTypeStruct13 *vdl.Type
	vdlTypeStruct14 *vdl.Type
	vdlTypeStruct15 *vdl.Type
	vdlTypeStruct16 *vdl.Type
	vdlTypeList17   *vdl.Type
	vdlTypeStruct18 *vdl.Type
	vdlTypeStruct19 *vdl.Type
	vdlTypeUnion20  *vdl.Type
)

var initializeVDLCalled bool

// initializeVDL performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = initializeVDL()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func initializeVDL() struct{} {
	if initializeVDLCalled {
		return struct{}{}
	}
	initializeVDLCalled = true

	// Register types.
	vdl.Register((*ControlKind)(nil))
	vdl.Register((*Primitive)(nil))
	vdl.Register((*DumpKind)(nil))
	vdl.Register((*DumpAtom)(nil))
	vdl.Register((*Version)(nil))
	vdl.Register((*TypeId)(nil))
	vdl.Register((*wireNamed)(nil))
	vdl.Register((*wireEnum)(nil))
	vdl.Register((*wireArray)(nil))
	vdl.Register((*wireList)(nil))
	vdl.Register((*wireSet)(nil))
	vdl.Register((*wireMap)(nil))
	vdl.Register((*wireField)(nil))
	vdl.Register((*wireStruct)(nil))
	vdl.Register((*wireUnion)(nil))
	vdl.Register((*wireOptional)(nil))
	vdl.Register((*wireType)(nil))

	// Initialize type definitions.
	vdlTypeEnum1 = vdl.TypeOf((*ControlKind)(nil))
	vdlTypeUnion2 = vdl.TypeOf((*Primitive)(nil))
	vdlTypeEnum3 = vdl.TypeOf((*DumpKind)(nil))
	vdlTypeStruct4 = vdl.TypeOf((*DumpAtom)(nil)).Elem()
	vdlTypeList5 = vdl.TypeOf((*[]byte)(nil))
	vdlTypeByte6 = vdl.TypeOf((*Version)(nil))
	vdlTypeUint647 = vdl.TypeOf((*TypeId)(nil))
	vdlTypeStruct8 = vdl.TypeOf((*wireNamed)(nil)).Elem()
	vdlTypeStruct9 = vdl.TypeOf((*wireEnum)(nil)).Elem()
	vdlTypeList10 = vdl.TypeOf((*[]string)(nil))
	vdlTypeStruct11 = vdl.TypeOf((*wireArray)(nil)).Elem()
	vdlTypeStruct12 = vdl.TypeOf((*wireList)(nil)).Elem()
	vdlTypeStruct13 = vdl.TypeOf((*wireSet)(nil)).Elem()
	vdlTypeStruct14 = vdl.TypeOf((*wireMap)(nil)).Elem()
	vdlTypeStruct15 = vdl.TypeOf((*wireField)(nil)).Elem()
	vdlTypeStruct16 = vdl.TypeOf((*wireStruct)(nil)).Elem()
	vdlTypeList17 = vdl.TypeOf((*[]wireField)(nil))
	vdlTypeStruct18 = vdl.TypeOf((*wireUnion)(nil)).Elem()
	vdlTypeStruct19 = vdl.TypeOf((*wireOptional)(nil)).Elem()
	vdlTypeUnion20 = vdl.TypeOf((*wireType)(nil))

	return struct{}{}
}
