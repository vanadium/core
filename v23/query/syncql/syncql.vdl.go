// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: syncql

//nolint:revive
package syncql

import (
	"fmt"

	"v.io/v23/context"
	"v.io/v23/verror"
)

var _ = initializeVDL() // Must be first; see initializeVDL comments for details.

// Error definitions
// =================

var (
	ErrBadFieldInWhere                 = verror.NewIDAction("v.io/v23/query/syncql.BadFieldInWhere", verror.NoRetry)
	ErrBoolInvalidExpression           = verror.NewIDAction("v.io/v23/query/syncql.BoolInvalidExpression", verror.NoRetry)
	ErrCheckOfUnknownStatementType     = verror.NewIDAction("v.io/v23/query/syncql.CheckOfUnknownStatementType", verror.NoRetry)
	ErrCouldNotConvert                 = verror.NewIDAction("v.io/v23/query/syncql.CouldNotConvert", verror.NoRetry)
	ErrDotNotationDisallowedForKey     = verror.NewIDAction("v.io/v23/query/syncql.DotNotationDisallowedForKey", verror.NoRetry)
	ErrExecOfUnknownStatementType      = verror.NewIDAction("v.io/v23/query/syncql.ExecOfUnknownStatementType", verror.NoRetry)
	ErrExpected                        = verror.NewIDAction("v.io/v23/query/syncql.Expected", verror.NoRetry)
	ErrExpectedFrom                    = verror.NewIDAction("v.io/v23/query/syncql.ExpectedFrom", verror.NoRetry)
	ErrExpectedIdentifier              = verror.NewIDAction("v.io/v23/query/syncql.ExpectedIdentifier", verror.NoRetry)
	ErrExpectedOperand                 = verror.NewIDAction("v.io/v23/query/syncql.ExpectedOperand", verror.NoRetry)
	ErrExpectedOperator                = verror.NewIDAction("v.io/v23/query/syncql.ExpectedOperator", verror.NoRetry)
	ErrFunctionArgCount                = verror.NewIDAction("v.io/v23/query/syncql.FunctionArgCount", verror.NoRetry)
	ErrFunctionAtLeastArgCount         = verror.NewIDAction("v.io/v23/query/syncql.FunctionAtLeastArgCount", verror.NoRetry)
	ErrFunctionTypeInvalidArg          = verror.NewIDAction("v.io/v23/query/syncql.FunctionTypeInvalidArg", verror.NoRetry)
	ErrFunctionLenInvalidArg           = verror.NewIDAction("v.io/v23/query/syncql.FunctionLenInvalidArg", verror.NoRetry)
	ErrFunctionArgBad                  = verror.NewIDAction("v.io/v23/query/syncql.FunctionArgBad", verror.NoRetry)
	ErrFunctionNotFound                = verror.NewIDAction("v.io/v23/query/syncql.FunctionNotFound", verror.NoRetry)
	ErrArgMustBeField                  = verror.NewIDAction("v.io/v23/query/syncql.ArgMustBeField", verror.NoRetry)
	ErrBigIntConversionError           = verror.NewIDAction("v.io/v23/query/syncql.BigIntConversionError", verror.NoRetry)
	ErrBigRatConversionError           = verror.NewIDAction("v.io/v23/query/syncql.BigRatConversionError", verror.NoRetry)
	ErrBoolConversionError             = verror.NewIDAction("v.io/v23/query/syncql.BoolConversionError", verror.NoRetry)
	ErrComplexConversionError          = verror.NewIDAction("v.io/v23/query/syncql.ComplexConversionError", verror.NoRetry)
	ErrUintConversionError             = verror.NewIDAction("v.io/v23/query/syncql.UintConversionError", verror.NoRetry)
	ErrTimeConversionError             = verror.NewIDAction("v.io/v23/query/syncql.TimeConversionError", verror.NoRetry)
	ErrLocationConversionError         = verror.NewIDAction("v.io/v23/query/syncql.LocationConversionError", verror.NoRetry)
	ErrStringConversionError           = verror.NewIDAction("v.io/v23/query/syncql.StringConversionError", verror.NoRetry)
	ErrFloatConversionError            = verror.NewIDAction("v.io/v23/query/syncql.FloatConversionError", verror.NoRetry)
	ErrIntConversionError              = verror.NewIDAction("v.io/v23/query/syncql.IntConversionError", verror.NoRetry)
	ErrIsIsNotRequireLhsValue          = verror.NewIDAction("v.io/v23/query/syncql.IsIsNotRequireLhsValue", verror.NoRetry)
	ErrIsIsNotRequireRhsNil            = verror.NewIDAction("v.io/v23/query/syncql.IsIsNotRequireRhsNil", verror.NoRetry)
	ErrInvalidLikePattern              = verror.NewIDAction("v.io/v23/query/syncql.InvalidLikePattern", verror.NoRetry)
	ErrInvalidSelectField              = verror.NewIDAction("v.io/v23/query/syncql.InvalidSelectField", verror.NoRetry)
	ErrKeyExpressionLiteral            = verror.NewIDAction("v.io/v23/query/syncql.KeyExpressionLiteral", verror.NoRetry)
	ErrKeyValueStreamError             = verror.NewIDAction("v.io/v23/query/syncql.KeyValueStreamError", verror.NoRetry)
	ErrLikeExpressionsRequireRhsString = verror.NewIDAction("v.io/v23/query/syncql.LikeExpressionsRequireRhsString", verror.NoRetry)
	ErrLimitMustBeGt0                  = verror.NewIDAction("v.io/v23/query/syncql.LimitMustBeGt0", verror.NoRetry)
	ErrMaxStatementLenExceeded         = verror.NewIDAction("v.io/v23/query/syncql.MaxStatementLenExceeded", verror.NoRetry)
	ErrNoStatementFound                = verror.NewIDAction("v.io/v23/query/syncql.NoStatementFound", verror.NoRetry)
	ErrOffsetMustBeGe0                 = verror.NewIDAction("v.io/v23/query/syncql.OffsetMustBeGe0", verror.NoRetry)
	ErrScanError                       = verror.NewIDAction("v.io/v23/query/syncql.ScanError", verror.NoRetry)
	ErrTableCantAccess                 = verror.NewIDAction("v.io/v23/query/syncql.TableCantAccess", verror.NoRetry)
	ErrUnexpected                      = verror.NewIDAction("v.io/v23/query/syncql.Unexpected", verror.NoRetry)
	ErrUnexpectedEndOfStatement        = verror.NewIDAction("v.io/v23/query/syncql.UnexpectedEndOfStatement", verror.NoRetry)
	ErrUnknownIdentifier               = verror.NewIDAction("v.io/v23/query/syncql.UnknownIdentifier", verror.NoRetry)
	ErrInvalidEscapeChar               = verror.NewIDAction("v.io/v23/query/syncql.InvalidEscapeChar", verror.NoRetry)
	ErrDidYouMeanLowercaseK            = verror.NewIDAction("v.io/v23/query/syncql.DidYouMeanLowercaseK", verror.NoRetry)
	ErrDidYouMeanLowercaseV            = verror.NewIDAction("v.io/v23/query/syncql.DidYouMeanLowercaseV", verror.NoRetry)
	ErrDidYouMeanFunction              = verror.NewIDAction("v.io/v23/query/syncql.DidYouMeanFunction", verror.NoRetry)
	ErrNotEnoughParamValuesSpecified   = verror.NewIDAction("v.io/v23/query/syncql.NotEnoughParamValuesSpecified", verror.NoRetry)
	ErrTooManyParamValuesSpecified     = verror.NewIDAction("v.io/v23/query/syncql.TooManyParamValuesSpecified", verror.NoRetry)
	ErrPreparedStatementNotFound       = verror.NewIDAction("v.io/v23/query/syncql.PreparedStatementNotFound", verror.NoRetry)
	ErrIndexKindNotSupported           = verror.NewIDAction("v.io/v23/query/syncql.IndexKindNotSupported", verror.NoRetry)
	ErrInvalidIndexField               = verror.NewIDAction("v.io/v23/query/syncql.InvalidIndexField", verror.NoRetry)
	ErrNotWritable                     = verror.NewIDAction("v.io/v23/query/syncql.NotWritable", verror.NoRetry)
	ErrOperationNotSupported           = verror.NewIDAction("v.io/v23/query/syncql.OperationNotSupported", verror.NoRetry)
)

// ErrorfBadFieldInWhere calls ErrBadFieldInWhere.Errorf with the supplied arguments.
func ErrorfBadFieldInWhere(ctx *context.T, format string, off int64) error {
	return ErrBadFieldInWhere.Errorf(ctx, format, off)
}

// MessageBadFieldInWhere calls ErrBadFieldInWhere.Message with the supplied arguments.
func MessageBadFieldInWhere(ctx *context.T, message string, off int64) error {
	return ErrBadFieldInWhere.Message(ctx, message, off)
}

// ParamsErrBadFieldInWhere extracts the expected parameters from the error's ParameterList.
func ParamsErrBadFieldInWhere(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfBoolInvalidExpression calls ErrBoolInvalidExpression.Errorf with the supplied arguments.
func ErrorfBoolInvalidExpression(ctx *context.T, format string, off int64) error {
	return ErrBoolInvalidExpression.Errorf(ctx, format, off)
}

// MessageBoolInvalidExpression calls ErrBoolInvalidExpression.Message with the supplied arguments.
func MessageBoolInvalidExpression(ctx *context.T, message string, off int64) error {
	return ErrBoolInvalidExpression.Message(ctx, message, off)
}

// ParamsErrBoolInvalidExpression extracts the expected parameters from the error's ParameterList.
func ParamsErrBoolInvalidExpression(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfCheckOfUnknownStatementType calls ErrCheckOfUnknownStatementType.Errorf with the supplied arguments.
func ErrorfCheckOfUnknownStatementType(ctx *context.T, format string, off int64) error {
	return ErrCheckOfUnknownStatementType.Errorf(ctx, format, off)
}

// MessageCheckOfUnknownStatementType calls ErrCheckOfUnknownStatementType.Message with the supplied arguments.
func MessageCheckOfUnknownStatementType(ctx *context.T, message string, off int64) error {
	return ErrCheckOfUnknownStatementType.Message(ctx, message, off)
}

// ParamsErrCheckOfUnknownStatementType extracts the expected parameters from the error's ParameterList.
func ParamsErrCheckOfUnknownStatementType(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfCouldNotConvert calls ErrCouldNotConvert.Errorf with the supplied arguments.
func ErrorfCouldNotConvert(ctx *context.T, format string, off int64, from string, to string) error {
	return ErrCouldNotConvert.Errorf(ctx, format, off, from, to)
}

// MessageCouldNotConvert calls ErrCouldNotConvert.Message with the supplied arguments.
func MessageCouldNotConvert(ctx *context.T, message string, off int64, from string, to string) error {
	return ErrCouldNotConvert.Message(ctx, message, off, from, to)
}

// ParamsErrCouldNotConvert extracts the expected parameters from the error's ParameterList.
func ParamsErrCouldNotConvert(argumentError error) (verrorComponent string, verrorOperation string, off int64, from string, to string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if from, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value from, has %T and not string", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if to, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value to, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfDotNotationDisallowedForKey calls ErrDotNotationDisallowedForKey.Errorf with the supplied arguments.
func ErrorfDotNotationDisallowedForKey(ctx *context.T, format string, off int64) error {
	return ErrDotNotationDisallowedForKey.Errorf(ctx, format, off)
}

// MessageDotNotationDisallowedForKey calls ErrDotNotationDisallowedForKey.Message with the supplied arguments.
func MessageDotNotationDisallowedForKey(ctx *context.T, message string, off int64) error {
	return ErrDotNotationDisallowedForKey.Message(ctx, message, off)
}

// ParamsErrDotNotationDisallowedForKey extracts the expected parameters from the error's ParameterList.
func ParamsErrDotNotationDisallowedForKey(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfExecOfUnknownStatementType calls ErrExecOfUnknownStatementType.Errorf with the supplied arguments.
func ErrorfExecOfUnknownStatementType(ctx *context.T, format string, off int64, statementType string) error {
	return ErrExecOfUnknownStatementType.Errorf(ctx, format, off, statementType)
}

// MessageExecOfUnknownStatementType calls ErrExecOfUnknownStatementType.Message with the supplied arguments.
func MessageExecOfUnknownStatementType(ctx *context.T, message string, off int64, statementType string) error {
	return ErrExecOfUnknownStatementType.Message(ctx, message, off, statementType)
}

// ParamsErrExecOfUnknownStatementType extracts the expected parameters from the error's ParameterList.
func ParamsErrExecOfUnknownStatementType(argumentError error) (verrorComponent string, verrorOperation string, off int64, statementType string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if statementType, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value statementType, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfExpected calls ErrExpected.Errorf with the supplied arguments.
func ErrorfExpected(ctx *context.T, format string, off int64, expected string) error {
	return ErrExpected.Errorf(ctx, format, off, expected)
}

// MessageExpected calls ErrExpected.Message with the supplied arguments.
func MessageExpected(ctx *context.T, message string, off int64, expected string) error {
	return ErrExpected.Message(ctx, message, off, expected)
}

// ParamsErrExpected extracts the expected parameters from the error's ParameterList.
func ParamsErrExpected(argumentError error) (verrorComponent string, verrorOperation string, off int64, expected string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if expected, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value expected, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfExpectedFrom calls ErrExpectedFrom.Errorf with the supplied arguments.
func ErrorfExpectedFrom(ctx *context.T, format string, off int64, found string) error {
	return ErrExpectedFrom.Errorf(ctx, format, off, found)
}

// MessageExpectedFrom calls ErrExpectedFrom.Message with the supplied arguments.
func MessageExpectedFrom(ctx *context.T, message string, off int64, found string) error {
	return ErrExpectedFrom.Message(ctx, message, off, found)
}

// ParamsErrExpectedFrom extracts the expected parameters from the error's ParameterList.
func ParamsErrExpectedFrom(argumentError error) (verrorComponent string, verrorOperation string, off int64, found string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if found, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value found, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfExpectedIdentifier calls ErrExpectedIdentifier.Errorf with the supplied arguments.
func ErrorfExpectedIdentifier(ctx *context.T, format string, off int64, found string) error {
	return ErrExpectedIdentifier.Errorf(ctx, format, off, found)
}

// MessageExpectedIdentifier calls ErrExpectedIdentifier.Message with the supplied arguments.
func MessageExpectedIdentifier(ctx *context.T, message string, off int64, found string) error {
	return ErrExpectedIdentifier.Message(ctx, message, off, found)
}

// ParamsErrExpectedIdentifier extracts the expected parameters from the error's ParameterList.
func ParamsErrExpectedIdentifier(argumentError error) (verrorComponent string, verrorOperation string, off int64, found string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if found, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value found, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfExpectedOperand calls ErrExpectedOperand.Errorf with the supplied arguments.
func ErrorfExpectedOperand(ctx *context.T, format string, off int64, found string) error {
	return ErrExpectedOperand.Errorf(ctx, format, off, found)
}

// MessageExpectedOperand calls ErrExpectedOperand.Message with the supplied arguments.
func MessageExpectedOperand(ctx *context.T, message string, off int64, found string) error {
	return ErrExpectedOperand.Message(ctx, message, off, found)
}

// ParamsErrExpectedOperand extracts the expected parameters from the error's ParameterList.
func ParamsErrExpectedOperand(argumentError error) (verrorComponent string, verrorOperation string, off int64, found string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if found, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value found, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfExpectedOperator calls ErrExpectedOperator.Errorf with the supplied arguments.
func ErrorfExpectedOperator(ctx *context.T, format string, off int64, found string) error {
	return ErrExpectedOperator.Errorf(ctx, format, off, found)
}

// MessageExpectedOperator calls ErrExpectedOperator.Message with the supplied arguments.
func MessageExpectedOperator(ctx *context.T, message string, off int64, found string) error {
	return ErrExpectedOperator.Message(ctx, message, off, found)
}

// ParamsErrExpectedOperator extracts the expected parameters from the error's ParameterList.
func ParamsErrExpectedOperator(argumentError error) (verrorComponent string, verrorOperation string, off int64, found string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if found, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value found, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfFunctionArgCount calls ErrFunctionArgCount.Errorf with the supplied arguments.
func ErrorfFunctionArgCount(ctx *context.T, format string, off int64, name string, expected int64, found int64) error {
	return ErrFunctionArgCount.Errorf(ctx, format, off, name, expected, found)
}

// MessageFunctionArgCount calls ErrFunctionArgCount.Message with the supplied arguments.
func MessageFunctionArgCount(ctx *context.T, message string, off int64, name string, expected int64, found int64) error {
	return ErrFunctionArgCount.Message(ctx, message, off, name, expected, found)
}

// ParamsErrFunctionArgCount extracts the expected parameters from the error's ParameterList.
func ParamsErrFunctionArgCount(argumentError error) (verrorComponent string, verrorOperation string, off int64, name string, expected int64, found int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if name, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value name, has %T and not string", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if expected, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value expected, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if found, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value found, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfFunctionAtLeastArgCount calls ErrFunctionAtLeastArgCount.Errorf with the supplied arguments.
func ErrorfFunctionAtLeastArgCount(ctx *context.T, format string, off int64, name string, expected int64, found int64) error {
	return ErrFunctionAtLeastArgCount.Errorf(ctx, format, off, name, expected, found)
}

// MessageFunctionAtLeastArgCount calls ErrFunctionAtLeastArgCount.Message with the supplied arguments.
func MessageFunctionAtLeastArgCount(ctx *context.T, message string, off int64, name string, expected int64, found int64) error {
	return ErrFunctionAtLeastArgCount.Message(ctx, message, off, name, expected, found)
}

// ParamsErrFunctionAtLeastArgCount extracts the expected parameters from the error's ParameterList.
func ParamsErrFunctionAtLeastArgCount(argumentError error) (verrorComponent string, verrorOperation string, off int64, name string, expected int64, found int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if name, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value name, has %T and not string", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if expected, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value expected, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if found, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value found, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfFunctionTypeInvalidArg calls ErrFunctionTypeInvalidArg.Errorf with the supplied arguments.
func ErrorfFunctionTypeInvalidArg(ctx *context.T, format string, off int64) error {
	return ErrFunctionTypeInvalidArg.Errorf(ctx, format, off)
}

// MessageFunctionTypeInvalidArg calls ErrFunctionTypeInvalidArg.Message with the supplied arguments.
func MessageFunctionTypeInvalidArg(ctx *context.T, message string, off int64) error {
	return ErrFunctionTypeInvalidArg.Message(ctx, message, off)
}

// ParamsErrFunctionTypeInvalidArg extracts the expected parameters from the error's ParameterList.
func ParamsErrFunctionTypeInvalidArg(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfFunctionLenInvalidArg calls ErrFunctionLenInvalidArg.Errorf with the supplied arguments.
func ErrorfFunctionLenInvalidArg(ctx *context.T, format string, off int64) error {
	return ErrFunctionLenInvalidArg.Errorf(ctx, format, off)
}

// MessageFunctionLenInvalidArg calls ErrFunctionLenInvalidArg.Message with the supplied arguments.
func MessageFunctionLenInvalidArg(ctx *context.T, message string, off int64) error {
	return ErrFunctionLenInvalidArg.Message(ctx, message, off)
}

// ParamsErrFunctionLenInvalidArg extracts the expected parameters from the error's ParameterList.
func ParamsErrFunctionLenInvalidArg(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfFunctionArgBad calls ErrFunctionArgBad.Errorf with the supplied arguments.
func ErrorfFunctionArgBad(ctx *context.T, format string, off int64, funcName string, argName string) error {
	return ErrFunctionArgBad.Errorf(ctx, format, off, funcName, argName)
}

// MessageFunctionArgBad calls ErrFunctionArgBad.Message with the supplied arguments.
func MessageFunctionArgBad(ctx *context.T, message string, off int64, funcName string, argName string) error {
	return ErrFunctionArgBad.Message(ctx, message, off, funcName, argName)
}

// ParamsErrFunctionArgBad extracts the expected parameters from the error's ParameterList.
func ParamsErrFunctionArgBad(argumentError error) (verrorComponent string, verrorOperation string, off int64, funcName string, argName string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if funcName, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value funcName, has %T and not string", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if argName, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value argName, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfFunctionNotFound calls ErrFunctionNotFound.Errorf with the supplied arguments.
func ErrorfFunctionNotFound(ctx *context.T, format string, off int64, name string) error {
	return ErrFunctionNotFound.Errorf(ctx, format, off, name)
}

// MessageFunctionNotFound calls ErrFunctionNotFound.Message with the supplied arguments.
func MessageFunctionNotFound(ctx *context.T, message string, off int64, name string) error {
	return ErrFunctionNotFound.Message(ctx, message, off, name)
}

// ParamsErrFunctionNotFound extracts the expected parameters from the error's ParameterList.
func ParamsErrFunctionNotFound(argumentError error) (verrorComponent string, verrorOperation string, off int64, name string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if name, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value name, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfArgMustBeField calls ErrArgMustBeField.Errorf with the supplied arguments.
func ErrorfArgMustBeField(ctx *context.T, format string, off int64) error {
	return ErrArgMustBeField.Errorf(ctx, format, off)
}

// MessageArgMustBeField calls ErrArgMustBeField.Message with the supplied arguments.
func MessageArgMustBeField(ctx *context.T, message string, off int64) error {
	return ErrArgMustBeField.Message(ctx, message, off)
}

// ParamsErrArgMustBeField extracts the expected parameters from the error's ParameterList.
func ParamsErrArgMustBeField(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfBigIntConversionError calls ErrBigIntConversionError.Errorf with the supplied arguments.
func ErrorfBigIntConversionError(ctx *context.T, format string, off int64, err error) error {
	return ErrBigIntConversionError.Errorf(ctx, format, off, err)
}

// MessageBigIntConversionError calls ErrBigIntConversionError.Message with the supplied arguments.
func MessageBigIntConversionError(ctx *context.T, message string, off int64, err error) error {
	return ErrBigIntConversionError.Message(ctx, message, off, err)
}

// ParamsErrBigIntConversionError extracts the expected parameters from the error's ParameterList.
func ParamsErrBigIntConversionError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfBigRatConversionError calls ErrBigRatConversionError.Errorf with the supplied arguments.
func ErrorfBigRatConversionError(ctx *context.T, format string, off int64, err error) error {
	return ErrBigRatConversionError.Errorf(ctx, format, off, err)
}

// MessageBigRatConversionError calls ErrBigRatConversionError.Message with the supplied arguments.
func MessageBigRatConversionError(ctx *context.T, message string, off int64, err error) error {
	return ErrBigRatConversionError.Message(ctx, message, off, err)
}

// ParamsErrBigRatConversionError extracts the expected parameters from the error's ParameterList.
func ParamsErrBigRatConversionError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfBoolConversionError calls ErrBoolConversionError.Errorf with the supplied arguments.
func ErrorfBoolConversionError(ctx *context.T, format string, off int64, err error) error {
	return ErrBoolConversionError.Errorf(ctx, format, off, err)
}

// MessageBoolConversionError calls ErrBoolConversionError.Message with the supplied arguments.
func MessageBoolConversionError(ctx *context.T, message string, off int64, err error) error {
	return ErrBoolConversionError.Message(ctx, message, off, err)
}

// ParamsErrBoolConversionError extracts the expected parameters from the error's ParameterList.
func ParamsErrBoolConversionError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfComplexConversionError calls ErrComplexConversionError.Errorf with the supplied arguments.
func ErrorfComplexConversionError(ctx *context.T, format string, off int64, err error) error {
	return ErrComplexConversionError.Errorf(ctx, format, off, err)
}

// MessageComplexConversionError calls ErrComplexConversionError.Message with the supplied arguments.
func MessageComplexConversionError(ctx *context.T, message string, off int64, err error) error {
	return ErrComplexConversionError.Message(ctx, message, off, err)
}

// ParamsErrComplexConversionError extracts the expected parameters from the error's ParameterList.
func ParamsErrComplexConversionError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfUintConversionError calls ErrUintConversionError.Errorf with the supplied arguments.
func ErrorfUintConversionError(ctx *context.T, format string, off int64, err error) error {
	return ErrUintConversionError.Errorf(ctx, format, off, err)
}

// MessageUintConversionError calls ErrUintConversionError.Message with the supplied arguments.
func MessageUintConversionError(ctx *context.T, message string, off int64, err error) error {
	return ErrUintConversionError.Message(ctx, message, off, err)
}

// ParamsErrUintConversionError extracts the expected parameters from the error's ParameterList.
func ParamsErrUintConversionError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfTimeConversionError calls ErrTimeConversionError.Errorf with the supplied arguments.
func ErrorfTimeConversionError(ctx *context.T, format string, off int64, err error) error {
	return ErrTimeConversionError.Errorf(ctx, format, off, err)
}

// MessageTimeConversionError calls ErrTimeConversionError.Message with the supplied arguments.
func MessageTimeConversionError(ctx *context.T, message string, off int64, err error) error {
	return ErrTimeConversionError.Message(ctx, message, off, err)
}

// ParamsErrTimeConversionError extracts the expected parameters from the error's ParameterList.
func ParamsErrTimeConversionError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfLocationConversionError calls ErrLocationConversionError.Errorf with the supplied arguments.
func ErrorfLocationConversionError(ctx *context.T, format string, off int64, err error) error {
	return ErrLocationConversionError.Errorf(ctx, format, off, err)
}

// MessageLocationConversionError calls ErrLocationConversionError.Message with the supplied arguments.
func MessageLocationConversionError(ctx *context.T, message string, off int64, err error) error {
	return ErrLocationConversionError.Message(ctx, message, off, err)
}

// ParamsErrLocationConversionError extracts the expected parameters from the error's ParameterList.
func ParamsErrLocationConversionError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfStringConversionError calls ErrStringConversionError.Errorf with the supplied arguments.
func ErrorfStringConversionError(ctx *context.T, format string, off int64, err error) error {
	return ErrStringConversionError.Errorf(ctx, format, off, err)
}

// MessageStringConversionError calls ErrStringConversionError.Message with the supplied arguments.
func MessageStringConversionError(ctx *context.T, message string, off int64, err error) error {
	return ErrStringConversionError.Message(ctx, message, off, err)
}

// ParamsErrStringConversionError extracts the expected parameters from the error's ParameterList.
func ParamsErrStringConversionError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfFloatConversionError calls ErrFloatConversionError.Errorf with the supplied arguments.
func ErrorfFloatConversionError(ctx *context.T, format string, off int64, err error) error {
	return ErrFloatConversionError.Errorf(ctx, format, off, err)
}

// MessageFloatConversionError calls ErrFloatConversionError.Message with the supplied arguments.
func MessageFloatConversionError(ctx *context.T, message string, off int64, err error) error {
	return ErrFloatConversionError.Message(ctx, message, off, err)
}

// ParamsErrFloatConversionError extracts the expected parameters from the error's ParameterList.
func ParamsErrFloatConversionError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfIntConversionError calls ErrIntConversionError.Errorf with the supplied arguments.
func ErrorfIntConversionError(ctx *context.T, format string, off int64, err error) error {
	return ErrIntConversionError.Errorf(ctx, format, off, err)
}

// MessageIntConversionError calls ErrIntConversionError.Message with the supplied arguments.
func MessageIntConversionError(ctx *context.T, message string, off int64, err error) error {
	return ErrIntConversionError.Message(ctx, message, off, err)
}

// ParamsErrIntConversionError extracts the expected parameters from the error's ParameterList.
func ParamsErrIntConversionError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfIsIsNotRequireLhsValue calls ErrIsIsNotRequireLhsValue.Errorf with the supplied arguments.
func ErrorfIsIsNotRequireLhsValue(ctx *context.T, format string, off int64) error {
	return ErrIsIsNotRequireLhsValue.Errorf(ctx, format, off)
}

// MessageIsIsNotRequireLhsValue calls ErrIsIsNotRequireLhsValue.Message with the supplied arguments.
func MessageIsIsNotRequireLhsValue(ctx *context.T, message string, off int64) error {
	return ErrIsIsNotRequireLhsValue.Message(ctx, message, off)
}

// ParamsErrIsIsNotRequireLhsValue extracts the expected parameters from the error's ParameterList.
func ParamsErrIsIsNotRequireLhsValue(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfIsIsNotRequireRhsNil calls ErrIsIsNotRequireRhsNil.Errorf with the supplied arguments.
func ErrorfIsIsNotRequireRhsNil(ctx *context.T, format string, off int64) error {
	return ErrIsIsNotRequireRhsNil.Errorf(ctx, format, off)
}

// MessageIsIsNotRequireRhsNil calls ErrIsIsNotRequireRhsNil.Message with the supplied arguments.
func MessageIsIsNotRequireRhsNil(ctx *context.T, message string, off int64) error {
	return ErrIsIsNotRequireRhsNil.Message(ctx, message, off)
}

// ParamsErrIsIsNotRequireRhsNil extracts the expected parameters from the error's ParameterList.
func ParamsErrIsIsNotRequireRhsNil(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfInvalidLikePattern calls ErrInvalidLikePattern.Errorf with the supplied arguments.
func ErrorfInvalidLikePattern(ctx *context.T, format string, off int64, err error) error {
	return ErrInvalidLikePattern.Errorf(ctx, format, off, err)
}

// MessageInvalidLikePattern calls ErrInvalidLikePattern.Message with the supplied arguments.
func MessageInvalidLikePattern(ctx *context.T, message string, off int64, err error) error {
	return ErrInvalidLikePattern.Message(ctx, message, off, err)
}

// ParamsErrInvalidLikePattern extracts the expected parameters from the error's ParameterList.
func ParamsErrInvalidLikePattern(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfInvalidSelectField calls ErrInvalidSelectField.Errorf with the supplied arguments.
func ErrorfInvalidSelectField(ctx *context.T, format string, off int64) error {
	return ErrInvalidSelectField.Errorf(ctx, format, off)
}

// MessageInvalidSelectField calls ErrInvalidSelectField.Message with the supplied arguments.
func MessageInvalidSelectField(ctx *context.T, message string, off int64) error {
	return ErrInvalidSelectField.Message(ctx, message, off)
}

// ParamsErrInvalidSelectField extracts the expected parameters from the error's ParameterList.
func ParamsErrInvalidSelectField(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfKeyExpressionLiteral calls ErrKeyExpressionLiteral.Errorf with the supplied arguments.
func ErrorfKeyExpressionLiteral(ctx *context.T, format string, off int64) error {
	return ErrKeyExpressionLiteral.Errorf(ctx, format, off)
}

// MessageKeyExpressionLiteral calls ErrKeyExpressionLiteral.Message with the supplied arguments.
func MessageKeyExpressionLiteral(ctx *context.T, message string, off int64) error {
	return ErrKeyExpressionLiteral.Message(ctx, message, off)
}

// ParamsErrKeyExpressionLiteral extracts the expected parameters from the error's ParameterList.
func ParamsErrKeyExpressionLiteral(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfKeyValueStreamError calls ErrKeyValueStreamError.Errorf with the supplied arguments.
func ErrorfKeyValueStreamError(ctx *context.T, format string, off int64, err error) error {
	return ErrKeyValueStreamError.Errorf(ctx, format, off, err)
}

// MessageKeyValueStreamError calls ErrKeyValueStreamError.Message with the supplied arguments.
func MessageKeyValueStreamError(ctx *context.T, message string, off int64, err error) error {
	return ErrKeyValueStreamError.Message(ctx, message, off, err)
}

// ParamsErrKeyValueStreamError extracts the expected parameters from the error's ParameterList.
func ParamsErrKeyValueStreamError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfLikeExpressionsRequireRhsString calls ErrLikeExpressionsRequireRhsString.Errorf with the supplied arguments.
func ErrorfLikeExpressionsRequireRhsString(ctx *context.T, format string, off int64) error {
	return ErrLikeExpressionsRequireRhsString.Errorf(ctx, format, off)
}

// MessageLikeExpressionsRequireRhsString calls ErrLikeExpressionsRequireRhsString.Message with the supplied arguments.
func MessageLikeExpressionsRequireRhsString(ctx *context.T, message string, off int64) error {
	return ErrLikeExpressionsRequireRhsString.Message(ctx, message, off)
}

// ParamsErrLikeExpressionsRequireRhsString extracts the expected parameters from the error's ParameterList.
func ParamsErrLikeExpressionsRequireRhsString(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfLimitMustBeGt0 calls ErrLimitMustBeGt0.Errorf with the supplied arguments.
func ErrorfLimitMustBeGt0(ctx *context.T, format string, off int64) error {
	return ErrLimitMustBeGt0.Errorf(ctx, format, off)
}

// MessageLimitMustBeGt0 calls ErrLimitMustBeGt0.Message with the supplied arguments.
func MessageLimitMustBeGt0(ctx *context.T, message string, off int64) error {
	return ErrLimitMustBeGt0.Message(ctx, message, off)
}

// ParamsErrLimitMustBeGt0 extracts the expected parameters from the error's ParameterList.
func ParamsErrLimitMustBeGt0(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfMaxStatementLenExceeded calls ErrMaxStatementLenExceeded.Errorf with the supplied arguments.
func ErrorfMaxStatementLenExceeded(ctx *context.T, format string, off int64, max int64, found int64) error {
	return ErrMaxStatementLenExceeded.Errorf(ctx, format, off, max, found)
}

// MessageMaxStatementLenExceeded calls ErrMaxStatementLenExceeded.Message with the supplied arguments.
func MessageMaxStatementLenExceeded(ctx *context.T, message string, off int64, max int64, found int64) error {
	return ErrMaxStatementLenExceeded.Message(ctx, message, off, max, found)
}

// ParamsErrMaxStatementLenExceeded extracts the expected parameters from the error's ParameterList.
func ParamsErrMaxStatementLenExceeded(argumentError error) (verrorComponent string, verrorOperation string, off int64, max int64, found int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if max, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value max, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if found, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value found, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfNoStatementFound calls ErrNoStatementFound.Errorf with the supplied arguments.
func ErrorfNoStatementFound(ctx *context.T, format string, off int64) error {
	return ErrNoStatementFound.Errorf(ctx, format, off)
}

// MessageNoStatementFound calls ErrNoStatementFound.Message with the supplied arguments.
func MessageNoStatementFound(ctx *context.T, message string, off int64) error {
	return ErrNoStatementFound.Message(ctx, message, off)
}

// ParamsErrNoStatementFound extracts the expected parameters from the error's ParameterList.
func ParamsErrNoStatementFound(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfOffsetMustBeGe0 calls ErrOffsetMustBeGe0.Errorf with the supplied arguments.
func ErrorfOffsetMustBeGe0(ctx *context.T, format string, off int64) error {
	return ErrOffsetMustBeGe0.Errorf(ctx, format, off)
}

// MessageOffsetMustBeGe0 calls ErrOffsetMustBeGe0.Message with the supplied arguments.
func MessageOffsetMustBeGe0(ctx *context.T, message string, off int64) error {
	return ErrOffsetMustBeGe0.Message(ctx, message, off)
}

// ParamsErrOffsetMustBeGe0 extracts the expected parameters from the error's ParameterList.
func ParamsErrOffsetMustBeGe0(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfScanError calls ErrScanError.Errorf with the supplied arguments.
func ErrorfScanError(ctx *context.T, format string, off int64, err error) error {
	return ErrScanError.Errorf(ctx, format, off, err)
}

// MessageScanError calls ErrScanError.Message with the supplied arguments.
func MessageScanError(ctx *context.T, message string, off int64, err error) error {
	return ErrScanError.Message(ctx, message, off, err)
}

// ParamsErrScanError extracts the expected parameters from the error's ParameterList.
func ParamsErrScanError(argumentError error) (verrorComponent string, verrorOperation string, off int64, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfTableCantAccess calls ErrTableCantAccess.Errorf with the supplied arguments.
func ErrorfTableCantAccess(ctx *context.T, format string, off int64, table string, err error) error {
	return ErrTableCantAccess.Errorf(ctx, format, off, table, err)
}

// MessageTableCantAccess calls ErrTableCantAccess.Message with the supplied arguments.
func MessageTableCantAccess(ctx *context.T, message string, off int64, table string, err error) error {
	return ErrTableCantAccess.Message(ctx, message, off, table, err)
}

// ParamsErrTableCantAccess extracts the expected parameters from the error's ParameterList.
func ParamsErrTableCantAccess(argumentError error) (verrorComponent string, verrorOperation string, off int64, table string, err error, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if table, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value table, has %T and not string", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if err, ok = tmp.(error); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value err, has %T and not error", tmp)
		return
	}

	return
}

// ErrorfUnexpected calls ErrUnexpected.Errorf with the supplied arguments.
func ErrorfUnexpected(ctx *context.T, format string, off int64, found string) error {
	return ErrUnexpected.Errorf(ctx, format, off, found)
}

// MessageUnexpected calls ErrUnexpected.Message with the supplied arguments.
func MessageUnexpected(ctx *context.T, message string, off int64, found string) error {
	return ErrUnexpected.Message(ctx, message, off, found)
}

// ParamsErrUnexpected extracts the expected parameters from the error's ParameterList.
func ParamsErrUnexpected(argumentError error) (verrorComponent string, verrorOperation string, off int64, found string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if found, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value found, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfUnexpectedEndOfStatement calls ErrUnexpectedEndOfStatement.Errorf with the supplied arguments.
func ErrorfUnexpectedEndOfStatement(ctx *context.T, format string, off int64) error {
	return ErrUnexpectedEndOfStatement.Errorf(ctx, format, off)
}

// MessageUnexpectedEndOfStatement calls ErrUnexpectedEndOfStatement.Message with the supplied arguments.
func MessageUnexpectedEndOfStatement(ctx *context.T, message string, off int64) error {
	return ErrUnexpectedEndOfStatement.Message(ctx, message, off)
}

// ParamsErrUnexpectedEndOfStatement extracts the expected parameters from the error's ParameterList.
func ParamsErrUnexpectedEndOfStatement(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfUnknownIdentifier calls ErrUnknownIdentifier.Errorf with the supplied arguments.
func ErrorfUnknownIdentifier(ctx *context.T, format string, off int64, found string) error {
	return ErrUnknownIdentifier.Errorf(ctx, format, off, found)
}

// MessageUnknownIdentifier calls ErrUnknownIdentifier.Message with the supplied arguments.
func MessageUnknownIdentifier(ctx *context.T, message string, off int64, found string) error {
	return ErrUnknownIdentifier.Message(ctx, message, off, found)
}

// ParamsErrUnknownIdentifier extracts the expected parameters from the error's ParameterList.
func ParamsErrUnknownIdentifier(argumentError error) (verrorComponent string, verrorOperation string, off int64, found string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if found, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value found, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfInvalidEscapeChar calls ErrInvalidEscapeChar.Errorf with the supplied arguments.
func ErrorfInvalidEscapeChar(ctx *context.T, format string, off int64, escChar string) error {
	return ErrInvalidEscapeChar.Errorf(ctx, format, off, escChar)
}

// MessageInvalidEscapeChar calls ErrInvalidEscapeChar.Message with the supplied arguments.
func MessageInvalidEscapeChar(ctx *context.T, message string, off int64, escChar string) error {
	return ErrInvalidEscapeChar.Message(ctx, message, off, escChar)
}

// ParamsErrInvalidEscapeChar extracts the expected parameters from the error's ParameterList.
func ParamsErrInvalidEscapeChar(argumentError error) (verrorComponent string, verrorOperation string, off int64, escChar string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if escChar, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value escChar, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfDidYouMeanLowercaseK calls ErrDidYouMeanLowercaseK.Errorf with the supplied arguments.
func ErrorfDidYouMeanLowercaseK(ctx *context.T, format string, off int64) error {
	return ErrDidYouMeanLowercaseK.Errorf(ctx, format, off)
}

// MessageDidYouMeanLowercaseK calls ErrDidYouMeanLowercaseK.Message with the supplied arguments.
func MessageDidYouMeanLowercaseK(ctx *context.T, message string, off int64) error {
	return ErrDidYouMeanLowercaseK.Message(ctx, message, off)
}

// ParamsErrDidYouMeanLowercaseK extracts the expected parameters from the error's ParameterList.
func ParamsErrDidYouMeanLowercaseK(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfDidYouMeanLowercaseV calls ErrDidYouMeanLowercaseV.Errorf with the supplied arguments.
func ErrorfDidYouMeanLowercaseV(ctx *context.T, format string, off int64) error {
	return ErrDidYouMeanLowercaseV.Errorf(ctx, format, off)
}

// MessageDidYouMeanLowercaseV calls ErrDidYouMeanLowercaseV.Message with the supplied arguments.
func MessageDidYouMeanLowercaseV(ctx *context.T, message string, off int64) error {
	return ErrDidYouMeanLowercaseV.Message(ctx, message, off)
}

// ParamsErrDidYouMeanLowercaseV extracts the expected parameters from the error's ParameterList.
func ParamsErrDidYouMeanLowercaseV(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfDidYouMeanFunction calls ErrDidYouMeanFunction.Errorf with the supplied arguments.
func ErrorfDidYouMeanFunction(ctx *context.T, format string, off int64, correctName string) error {
	return ErrDidYouMeanFunction.Errorf(ctx, format, off, correctName)
}

// MessageDidYouMeanFunction calls ErrDidYouMeanFunction.Message with the supplied arguments.
func MessageDidYouMeanFunction(ctx *context.T, message string, off int64, correctName string) error {
	return ErrDidYouMeanFunction.Message(ctx, message, off, correctName)
}

// ParamsErrDidYouMeanFunction extracts the expected parameters from the error's ParameterList.
func ParamsErrDidYouMeanFunction(argumentError error) (verrorComponent string, verrorOperation string, off int64, correctName string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if correctName, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value correctName, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfNotEnoughParamValuesSpecified calls ErrNotEnoughParamValuesSpecified.Errorf with the supplied arguments.
func ErrorfNotEnoughParamValuesSpecified(ctx *context.T, format string, off int64) error {
	return ErrNotEnoughParamValuesSpecified.Errorf(ctx, format, off)
}

// MessageNotEnoughParamValuesSpecified calls ErrNotEnoughParamValuesSpecified.Message with the supplied arguments.
func MessageNotEnoughParamValuesSpecified(ctx *context.T, message string, off int64) error {
	return ErrNotEnoughParamValuesSpecified.Message(ctx, message, off)
}

// ParamsErrNotEnoughParamValuesSpecified extracts the expected parameters from the error's ParameterList.
func ParamsErrNotEnoughParamValuesSpecified(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfTooManyParamValuesSpecified calls ErrTooManyParamValuesSpecified.Errorf with the supplied arguments.
func ErrorfTooManyParamValuesSpecified(ctx *context.T, format string, off int64) error {
	return ErrTooManyParamValuesSpecified.Errorf(ctx, format, off)
}

// MessageTooManyParamValuesSpecified calls ErrTooManyParamValuesSpecified.Message with the supplied arguments.
func MessageTooManyParamValuesSpecified(ctx *context.T, message string, off int64) error {
	return ErrTooManyParamValuesSpecified.Message(ctx, message, off)
}

// ParamsErrTooManyParamValuesSpecified extracts the expected parameters from the error's ParameterList.
func ParamsErrTooManyParamValuesSpecified(argumentError error) (verrorComponent string, verrorOperation string, off int64, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}

	return
}

// ErrorfPreparedStatementNotFound calls ErrPreparedStatementNotFound.Errorf with the supplied arguments.
func ErrorfPreparedStatementNotFound(ctx *context.T, format string) error {
	return ErrPreparedStatementNotFound.Errorf(ctx, format)
}

// MessagePreparedStatementNotFound calls ErrPreparedStatementNotFound.Message with the supplied arguments.
func MessagePreparedStatementNotFound(ctx *context.T, message string) error {
	return ErrPreparedStatementNotFound.Message(ctx, message)
}

// ParamsErrPreparedStatementNotFound extracts the expected parameters from the error's ParameterList.
func ParamsErrPreparedStatementNotFound(argumentError error) (verrorComponent string, verrorOperation string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	return
}

// ErrorfIndexKindNotSupported calls ErrIndexKindNotSupported.Errorf with the supplied arguments.
func ErrorfIndexKindNotSupported(ctx *context.T, format string, off int64, kind string, fieldName string, table string) error {
	return ErrIndexKindNotSupported.Errorf(ctx, format, off, kind, fieldName, table)
}

// MessageIndexKindNotSupported calls ErrIndexKindNotSupported.Message with the supplied arguments.
func MessageIndexKindNotSupported(ctx *context.T, message string, off int64, kind string, fieldName string, table string) error {
	return ErrIndexKindNotSupported.Message(ctx, message, off, kind, fieldName, table)
}

// ParamsErrIndexKindNotSupported extracts the expected parameters from the error's ParameterList.
func ParamsErrIndexKindNotSupported(argumentError error) (verrorComponent string, verrorOperation string, off int64, kind string, fieldName string, table string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if kind, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value kind, has %T and not string", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if fieldName, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value fieldName, has %T and not string", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if table, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value table, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfInvalidIndexField calls ErrInvalidIndexField.Errorf with the supplied arguments.
func ErrorfInvalidIndexField(ctx *context.T, format string, off int64, fieldName string, table string) error {
	return ErrInvalidIndexField.Errorf(ctx, format, off, fieldName, table)
}

// MessageInvalidIndexField calls ErrInvalidIndexField.Message with the supplied arguments.
func MessageInvalidIndexField(ctx *context.T, message string, off int64, fieldName string, table string) error {
	return ErrInvalidIndexField.Message(ctx, message, off, fieldName, table)
}

// ParamsErrInvalidIndexField extracts the expected parameters from the error's ParameterList.
func ParamsErrInvalidIndexField(argumentError error) (verrorComponent string, verrorOperation string, off int64, fieldName string, table string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if off, ok = tmp.(int64); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value off, has %T and not int64", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if fieldName, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value fieldName, has %T and not string", tmp)
		return
	}
	tmp, returnErr = iter.next()
	if table, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value table, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfNotWritable calls ErrNotWritable.Errorf with the supplied arguments.
func ErrorfNotWritable(ctx *context.T, format string, table string) error {
	return ErrNotWritable.Errorf(ctx, format, table)
}

// MessageNotWritable calls ErrNotWritable.Message with the supplied arguments.
func MessageNotWritable(ctx *context.T, message string, table string) error {
	return ErrNotWritable.Message(ctx, message, table)
}

// ParamsErrNotWritable extracts the expected parameters from the error's ParameterList.
func ParamsErrNotWritable(argumentError error) (verrorComponent string, verrorOperation string, table string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if table, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value table, has %T and not string", tmp)
		return
	}

	return
}

// ErrorfOperationNotSupported calls ErrOperationNotSupported.Errorf with the supplied arguments.
func ErrorfOperationNotSupported(ctx *context.T, format string, operation string) error {
	return ErrOperationNotSupported.Errorf(ctx, format, operation)
}

// MessageOperationNotSupported calls ErrOperationNotSupported.Message with the supplied arguments.
func MessageOperationNotSupported(ctx *context.T, message string, operation string) error {
	return ErrOperationNotSupported.Message(ctx, message, operation)
}

// ParamsErrOperationNotSupported extracts the expected parameters from the error's ParameterList.
func ParamsErrOperationNotSupported(argumentError error) (verrorComponent string, verrorOperation string, operation string, returnErr error) {
	params := verror.Params(argumentError)
	if params == nil {
		returnErr = fmt.Errorf("no parameters found in: %T: %v", argumentError, argumentError)
		return
	}
	iter := &paramListIterator{params: params, max: len(params)}

	if verrorComponent, verrorOperation, returnErr = iter.preamble(); returnErr != nil {
		return
	}

	var (
		tmp interface{}
		ok  bool
	)
	tmp, returnErr = iter.next()
	if operation, ok = tmp.(string); !ok {
		if returnErr != nil {
			return
		}
		returnErr = fmt.Errorf("parameter list contains the wrong type for return value operation, has %T and not string", tmp)
		return
	}

	return
}

type paramListIterator struct {
	err      error
	idx, max int
	params   []interface{}
}

func (pl *paramListIterator) next() (interface{}, error) {
	if pl.err != nil {
		return nil, pl.err
	}
	if pl.idx+1 > pl.max {
		pl.err = fmt.Errorf("too few parameters: have %v", pl.max)
		return nil, pl.err
	}
	pl.idx++
	return pl.params[pl.idx-1], nil
}

func (pl *paramListIterator) preamble() (component, operation string, err error) {
	var tmp interface{}
	if tmp, err = pl.next(); err != nil {
		return
	}
	var ok bool
	if component, ok = tmp.(string); !ok {
		return "", "", fmt.Errorf("ParamList[0]: component name is not a string: %T", tmp)
	}
	if tmp, err = pl.next(); err != nil {
		return
	}
	if operation, ok = tmp.(string); !ok {
		return "", "", fmt.Errorf("ParamList[1]: operation name is not a string: %T", tmp)
	}
	return
}

var initializeVDLCalled bool

// initializeVDL performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = initializeVDL()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func initializeVDL() struct{} {
	if initializeVDLCalled {
		return struct{}{}
	}
	initializeVDLCalled = true

	return struct{}{}
}
