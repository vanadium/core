// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: testdata

//nolint:golint
package testdata

import (
	"fmt"
	"time"

	"v.io/v23/vdl"
	vdltime "v.io/v23/vdlroot/time"
)

var _ = initializeVDL() // Must be first; see initializeVDL comments for details.

// Type definitions
// ================

type AddressInfo struct {
	Street string
	City   string
	State  string
	Zip    string
}

func (AddressInfo) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.AddressInfo"`
}) {
}

func (x AddressInfo) VDLIsZero() bool { //nolint:gocyclo
	return x == AddressInfo{}
}

func (x AddressInfo) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct1); err != nil {
		return err
	}
	if x.Street != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Street); err != nil {
			return err
		}
	}
	if x.City != "" {
		if err := enc.NextFieldValueString(1, vdl.StringType, x.City); err != nil {
			return err
		}
	}
	if x.State != "" {
		if err := enc.NextFieldValueString(2, vdl.StringType, x.State); err != nil {
			return err
		}
	}
	if x.Zip != "" {
		if err := enc.NextFieldValueString(3, vdl.StringType, x.Zip); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *AddressInfo) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = AddressInfo{}
	if err := dec.StartValue(vdlTypeStruct1); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct1 {
			index = vdlTypeStruct1.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Street = value
			}
		case 1:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.City = value
			}
		case 2:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.State = value
			}
		case 3:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Zip = value
			}
		}
	}
}

type CreditAgency int

const (
	CreditAgencyEquifax CreditAgency = iota
	CreditAgencyExperian
	CreditAgencyTransUnion
)

// CreditAgencyAll holds all labels for CreditAgency.
var CreditAgencyAll = [...]CreditAgency{CreditAgencyEquifax, CreditAgencyExperian, CreditAgencyTransUnion}

// CreditAgencyFromString creates a CreditAgency from a string label.
//nolint:deadcode,unused
func CreditAgencyFromString(label string) (x CreditAgency, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *CreditAgency) Set(label string) error {
	switch label {
	case "Equifax", "equifax":
		*x = CreditAgencyEquifax
		return nil
	case "Experian", "experian":
		*x = CreditAgencyExperian
		return nil
	case "TransUnion", "transunion":
		*x = CreditAgencyTransUnion
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.CreditAgency", label)
}

// String returns the string label of x.
func (x CreditAgency) String() string {
	switch x {
	case CreditAgencyEquifax:
		return "Equifax"
	case CreditAgencyExperian:
		return "Experian"
	case CreditAgencyTransUnion:
		return "TransUnion"
	}
	return ""
}

func (CreditAgency) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.CreditAgency"`
	Enum struct{ Equifax, Experian, TransUnion string }
}) {
}

func (x CreditAgency) VDLIsZero() bool { //nolint:gocyclo
	return x == CreditAgencyEquifax
}

func (x CreditAgency) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueString(vdlTypeEnum2, x.String()); err != nil {
		return err
	}
	return nil
}

func (x *CreditAgency) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		if err := x.Set(value); err != nil {
			return err
		}
	}
	return nil
}

type ExperianRating int

const (
	ExperianRatingGood ExperianRating = iota
	ExperianRatingBad
)

// ExperianRatingAll holds all labels for ExperianRating.
var ExperianRatingAll = [...]ExperianRating{ExperianRatingGood, ExperianRatingBad}

// ExperianRatingFromString creates a ExperianRating from a string label.
//nolint:deadcode,unused
func ExperianRatingFromString(label string) (x ExperianRating, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ExperianRating) Set(label string) error {
	switch label {
	case "Good", "good":
		*x = ExperianRatingGood
		return nil
	case "Bad", "bad":
		*x = ExperianRatingBad
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.ExperianRating", label)
}

// String returns the string label of x.
func (x ExperianRating) String() string {
	switch x {
	case ExperianRatingGood:
		return "Good"
	case ExperianRatingBad:
		return "Bad"
	}
	return ""
}

func (ExperianRating) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ExperianRating"`
	Enum struct{ Good, Bad string }
}) {
}

func (x ExperianRating) VDLIsZero() bool { //nolint:gocyclo
	return x == ExperianRatingGood
}

func (x ExperianRating) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueString(vdlTypeEnum3, x.String()); err != nil {
		return err
	}
	return nil
}

func (x *ExperianRating) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		if err := x.Set(value); err != nil {
			return err
		}
	}
	return nil
}

type RatingsArray [4]int16

func (RatingsArray) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.RatingsArray"`
}) {
}

func (x RatingsArray) VDLIsZero() bool { //nolint:gocyclo
	return x == RatingsArray{}
}

func (x RatingsArray) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeArray4); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntryValueInt(vdl.Int16Type, int64(elem)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *RatingsArray) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeArray4); err != nil {
		return err
	}
	for index := 0; index < 4; index++ {
		switch done, elem, err := dec.NextEntryValueInt(16); {
		case err != nil:
			return err
		case done:
			return fmt.Errorf("short array, got len %d < 4 %T)", index, *x)
		default:
			x[index] = int16(elem)
		}
	}
	switch done, err := dec.NextEntry(); {
	case err != nil:
		return err
	case !done:
		return fmt.Errorf("long array, got len > 4 %T", *x)
	}
	return dec.FinishValue()
}

type EquifaxCreditReport struct {
	Rating           byte
	FourScoreRatings RatingsArray
}

func (EquifaxCreditReport) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.EquifaxCreditReport"`
}) {
}

func (x EquifaxCreditReport) VDLIsZero() bool { //nolint:gocyclo
	return x == EquifaxCreditReport{}
}

func (x EquifaxCreditReport) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct5); err != nil {
		return err
	}
	if x.Rating != 0 {
		if err := enc.NextFieldValueUint(0, vdl.ByteType, uint64(x.Rating)); err != nil {
			return err
		}
	}
	if x.FourScoreRatings != (RatingsArray{}) {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := x.FourScoreRatings.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *EquifaxCreditReport) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = EquifaxCreditReport{}
	if err := dec.StartValue(vdlTypeStruct5); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct5 {
			index = vdlTypeStruct5.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueUint(8); {
			case err != nil:
				return err
			default:
				x.Rating = byte(value)
			}
		case 1:
			if err := x.FourScoreRatings.VDLRead(dec); err != nil {
				return err
			}
		}
	}
}

type Tdh int

const (
	TdhTom Tdh = iota
	TdhDick
	TdhHarry
)

// TdhAll holds all labels for Tdh.
var TdhAll = [...]Tdh{TdhTom, TdhDick, TdhHarry}

// TdhFromString creates a Tdh from a string label.
//nolint:deadcode,unused
func TdhFromString(label string) (x Tdh, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *Tdh) Set(label string) error {
	switch label {
	case "Tom", "tom":
		*x = TdhTom
		return nil
	case "Dick", "dick":
		*x = TdhDick
		return nil
	case "Harry", "harry":
		*x = TdhHarry
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.Tdh", label)
}

// String returns the string label of x.
func (x Tdh) String() string {
	switch x {
	case TdhTom:
		return "Tom"
	case TdhDick:
		return "Dick"
	case TdhHarry:
		return "Harry"
	}
	return ""
}

func (Tdh) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Tdh"`
	Enum struct{ Tom, Dick, Harry string }
}) {
}

func (x Tdh) VDLIsZero() bool { //nolint:gocyclo
	return x == TdhTom
}

func (x Tdh) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.WriteValueString(vdlTypeEnum6, x.String()); err != nil {
		return err
	}
	return nil
}

func (x *Tdh) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		if err := x.Set(value); err != nil {
			return err
		}
	}
	return nil
}

type ExperianCreditReport struct {
	Rating       ExperianRating
	TdhApprovals map[Tdh]struct{}
	Auditor      Tdh
}

func (ExperianCreditReport) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ExperianCreditReport"`
}) {
}

func (x ExperianCreditReport) VDLIsZero() bool { //nolint:gocyclo
	if x.Rating != ExperianRatingGood {
		return false
	}
	if len(x.TdhApprovals) != 0 {
		return false
	}
	if x.Auditor != TdhTom {
		return false
	}
	return true
}

func (x ExperianCreditReport) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct7); err != nil {
		return err
	}
	if x.Rating != ExperianRatingGood {
		if err := enc.NextFieldValueString(0, vdlTypeEnum3, x.Rating.String()); err != nil {
			return err
		}
	}
	if len(x.TdhApprovals) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := vdlWriteAnonSet1(enc, x.TdhApprovals); err != nil {
			return err
		}
	}
	if x.Auditor != TdhTom {
		if err := enc.NextFieldValueString(2, vdlTypeEnum6, x.Auditor.String()); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet1(enc vdl.Encoder, x map[Tdh]struct{}) error {
	if err := enc.StartValue(vdlTypeSet8); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueString(vdlTypeEnum6, key.String()); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ExperianCreditReport) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = ExperianCreditReport{}
	if err := dec.StartValue(vdlTypeStruct7); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct7 {
			index = vdlTypeStruct7.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				if err := x.Rating.Set(value); err != nil {
					return err
				}
			}
		case 1:
			if err := vdlReadAnonSet1(dec, &x.TdhApprovals); err != nil {
				return err
			}
		case 2:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				if err := x.Auditor.Set(value); err != nil {
					return err
				}
			}
		}
	}
}

func vdlReadAnonSet1(dec vdl.Decoder, x *map[Tdh]struct{}) error {
	if err := dec.StartValue(vdlTypeSet8); err != nil {
		return err
	}
	var tmpMap map[Tdh]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[Tdh]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var keyEnum Tdh
			if err := keyEnum.Set(key); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[Tdh]struct{})
			}
			tmpMap[keyEnum] = struct{}{}
		}
	}
}

type TransUnionCreditReport struct {
	Rating          int16
	PreviousRatings map[string]int16
}

func (TransUnionCreditReport) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.TransUnionCreditReport"`
}) {
}

func (x TransUnionCreditReport) VDLIsZero() bool { //nolint:gocyclo
	if x.Rating != 0 {
		return false
	}
	if len(x.PreviousRatings) != 0 {
		return false
	}
	return true
}

func (x TransUnionCreditReport) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct9); err != nil {
		return err
	}
	if x.Rating != 0 {
		if err := enc.NextFieldValueInt(0, vdl.Int16Type, int64(x.Rating)); err != nil {
			return err
		}
	}
	if len(x.PreviousRatings) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := vdlWriteAnonMap2(enc, x.PreviousRatings); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap2(enc vdl.Encoder, x map[string]int16) error {
	if err := enc.StartValue(vdlTypeMap10); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
		if err := enc.WriteValueInt(vdl.Int16Type, int64(elem)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *TransUnionCreditReport) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = TransUnionCreditReport{}
	if err := dec.StartValue(vdlTypeStruct9); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct9 {
			index = vdlTypeStruct9.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueInt(16); {
			case err != nil:
				return err
			default:
				x.Rating = int16(value)
			}
		case 1:
			if err := vdlReadAnonMap2(dec, &x.PreviousRatings); err != nil {
				return err
			}
		}
	}
}

func vdlReadAnonMap2(dec vdl.Decoder, x *map[string]int16) error {
	if err := dec.StartValue(vdlTypeMap10); err != nil {
		return err
	}
	var tmpMap map[string]int16
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]int16, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem int16
			switch value, err := dec.ReadValueInt(16); {
			case err != nil:
				return err
			default:
				elem = int16(value)
			}
			if tmpMap == nil {
				tmpMap = make(map[string]int16)
			}
			tmpMap[key] = elem
		}
	}
}

type (
	// AgencyReport represents any single field of the AgencyReport union type.
	AgencyReport interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// VDLReflect describes the AgencyReport union type.
		VDLReflect(vdlAgencyReportReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// AgencyReportEquifaxReport represents field EquifaxReport of the AgencyReport union type.
	AgencyReportEquifaxReport struct{ Value EquifaxCreditReport }
	// AgencyReportExperianReport represents field ExperianReport of the AgencyReport union type.
	AgencyReportExperianReport struct{ Value ExperianCreditReport }
	// AgencyReportTransUnionReport represents field TransUnionReport of the AgencyReport union type.
	AgencyReportTransUnionReport struct{ Value TransUnionCreditReport }
	// vdlAgencyReportReflect describes the AgencyReport union type.
	vdlAgencyReportReflect struct {
		Name  string `vdl:"v.io/v23/query/engine/internal/testdata.AgencyReport"`
		Type  AgencyReport
		Union struct {
			EquifaxReport    AgencyReportEquifaxReport
			ExperianReport   AgencyReportExperianReport
			TransUnionReport AgencyReportTransUnionReport
		}
	}
)

func (x AgencyReportEquifaxReport) Index() int                        { return 0 }
func (x AgencyReportEquifaxReport) Interface() interface{}            { return x.Value }
func (x AgencyReportEquifaxReport) Name() string                      { return "EquifaxReport" }
func (x AgencyReportEquifaxReport) VDLReflect(vdlAgencyReportReflect) {}

func (x AgencyReportExperianReport) Index() int                        { return 1 }
func (x AgencyReportExperianReport) Interface() interface{}            { return x.Value }
func (x AgencyReportExperianReport) Name() string                      { return "ExperianReport" }
func (x AgencyReportExperianReport) VDLReflect(vdlAgencyReportReflect) {}

func (x AgencyReportTransUnionReport) Index() int                        { return 2 }
func (x AgencyReportTransUnionReport) Interface() interface{}            { return x.Value }
func (x AgencyReportTransUnionReport) Name() string                      { return "TransUnionReport" }
func (x AgencyReportTransUnionReport) VDLReflect(vdlAgencyReportReflect) {}

func (x AgencyReportEquifaxReport) VDLIsZero() bool { //nolint:gocyclo
	return x.Value == EquifaxCreditReport{}
}

func (x AgencyReportExperianReport) VDLIsZero() bool {
	return false
}

func (x AgencyReportTransUnionReport) VDLIsZero() bool {
	return false
}

func (x AgencyReportEquifaxReport) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion11); err != nil {
		return err
	}
	if err := enc.NextField(0); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x AgencyReportExperianReport) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion11); err != nil {
		return err
	}
	if err := enc.NextField(1); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x AgencyReportTransUnionReport) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion11); err != nil {
		return err
	}
	if err := enc.NextField(2); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadAgencyReport(dec vdl.Decoder, x *AgencyReport) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeUnion11); err != nil {
		return err
	}
	decType := dec.Type()
	index, err := dec.NextField()
	switch {
	case err != nil:
		return err
	case index == -1:
		return fmt.Errorf("missing field in union %T, from %v", x, decType)
	}
	if decType != vdlTypeUnion11 {
		name := decType.Field(index).Name
		index = vdlTypeUnion11.FieldIndexByName(name)
		if index == -1 {
			return fmt.Errorf("field %q not in union %T, from %v", name, x, decType)
		}
	}
	switch index {
	case 0:
		var field AgencyReportEquifaxReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 1:
		var field AgencyReportExperianReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 2:
		var field AgencyReportTransUnionReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	}
	switch index, err := dec.NextField(); {
	case err != nil:
		return err
	case index != -1:
		return fmt.Errorf("extra field %d in union %T, from %v", index, x, dec.Type())
	}
	return dec.FinishValue()
}

type CreditReport struct {
	Agency CreditAgency
	Report AgencyReport
}

func (CreditReport) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.CreditReport"`
}) {
}

func (x CreditReport) VDLIsZero() bool { //nolint:gocyclo
	if x.Agency != CreditAgencyEquifax {
		return false
	}
	if x.Report != nil && !x.Report.VDLIsZero() {
		return false
	}
	return true
}

func (x CreditReport) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct12); err != nil {
		return err
	}
	if x.Agency != CreditAgencyEquifax {
		if err := enc.NextFieldValueString(0, vdlTypeEnum2, x.Agency.String()); err != nil {
			return err
		}
	}
	if x.Report != nil && !x.Report.VDLIsZero() {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := x.Report.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *CreditReport) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = CreditReport{
		Report: AgencyReportEquifaxReport{},
	}
	if err := dec.StartValue(vdlTypeStruct12); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct12 {
			index = vdlTypeStruct12.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				if err := x.Agency.Set(value); err != nil {
					return err
				}
			}
		case 1:
			if err := VDLReadAgencyReport(dec, &x.Report); err != nil {
				return err
			}
		}
	}
}

type Customer struct {
	Name              string
	Id                int64
	Active            bool
	Address           AddressInfo
	PreviousAddresses []AddressInfo
	Credit            CreditReport
}

func (Customer) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Customer"`
}) {
}

func (x Customer) VDLIsZero() bool { //nolint:gocyclo
	if x.Name != "" {
		return false
	}
	if x.Id != 0 {
		return false
	}
	if x.Active {
		return false
	}
	if x.Address != (AddressInfo{}) {
		return false
	}
	if len(x.PreviousAddresses) != 0 {
		return false
	}
	if !x.Credit.VDLIsZero() {
		return false
	}
	return true
}

func (x Customer) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct13); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if x.Id != 0 {
		if err := enc.NextFieldValueInt(1, vdl.Int64Type, x.Id); err != nil {
			return err
		}
	}
	if x.Active {
		if err := enc.NextFieldValueBool(2, vdl.BoolType, x.Active); err != nil {
			return err
		}
	}
	if x.Address != (AddressInfo{}) {
		if err := enc.NextField(3); err != nil {
			return err
		}
		if err := x.Address.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.PreviousAddresses) != 0 {
		if err := enc.NextField(4); err != nil {
			return err
		}
		if err := vdlWriteAnonList3(enc, x.PreviousAddresses); err != nil {
			return err
		}
	}
	if !x.Credit.VDLIsZero() {
		if err := enc.NextField(5); err != nil {
			return err
		}
		if err := x.Credit.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonList3(enc vdl.Encoder, x []AddressInfo) error {
	if err := enc.StartValue(vdlTypeList14); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Customer) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = Customer{
		Credit: CreditReport{
			Report: AgencyReportEquifaxReport{},
		},
	}
	if err := dec.StartValue(vdlTypeStruct13); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct13 {
			index = vdlTypeStruct13.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.Id = value
			}
		case 2:
			switch value, err := dec.ReadValueBool(); {
			case err != nil:
				return err
			default:
				x.Active = value
			}
		case 3:
			if err := x.Address.VDLRead(dec); err != nil {
				return err
			}
		case 4:
			if err := vdlReadAnonList3(dec, &x.PreviousAddresses); err != nil {
				return err
			}
		case 5:
			if err := x.Credit.VDLRead(dec); err != nil {
				return err
			}
		}
	}
}

func vdlReadAnonList3(dec vdl.Decoder, x *[]AddressInfo) error {
	if err := dec.StartValue(vdlTypeList14); err != nil {
		return err
	}
	if len := dec.LenHint(); len > 0 {
		*x = make([]AddressInfo, 0, len)
	} else {
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		default:
			var elem AddressInfo
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
			*x = append(*x, elem)
		}
	}
}

type Invoice struct {
	CustId      int64
	InvoiceNum  int64
	InvoiceDate time.Time
	Amount      int64
	ShipTo      AddressInfo
}

func (Invoice) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Invoice"`
}) {
}

func (x Invoice) VDLIsZero() bool { //nolint:gocyclo
	if x.CustId != 0 {
		return false
	}
	if x.InvoiceNum != 0 {
		return false
	}
	if !x.InvoiceDate.IsZero() {
		return false
	}
	if x.Amount != 0 {
		return false
	}
	if x.ShipTo != (AddressInfo{}) {
		return false
	}
	return true
}

func (x Invoice) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct15); err != nil {
		return err
	}
	if x.CustId != 0 {
		if err := enc.NextFieldValueInt(0, vdl.Int64Type, x.CustId); err != nil {
			return err
		}
	}
	if x.InvoiceNum != 0 {
		if err := enc.NextFieldValueInt(1, vdl.Int64Type, x.InvoiceNum); err != nil {
			return err
		}
	}
	if !x.InvoiceDate.IsZero() {
		if err := enc.NextField(2); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, x.InvoiceDate); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Amount != 0 {
		if err := enc.NextFieldValueInt(3, vdl.Int64Type, x.Amount); err != nil {
			return err
		}
	}
	if x.ShipTo != (AddressInfo{}) {
		if err := enc.NextField(4); err != nil {
			return err
		}
		if err := x.ShipTo.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Invoice) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = Invoice{}
	if err := dec.StartValue(vdlTypeStruct15); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct15 {
			index = vdlTypeStruct15.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.CustId = value
			}
		case 1:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.InvoiceNum = value
			}
		case 2:
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &x.InvoiceDate); err != nil {
				return err
			}
		case 3:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.Amount = value
			}
		case 4:
			if err := x.ShipTo.VDLRead(dec); err != nil {
				return err
			}
		}
	}
}

type Numbers struct {
	B    byte
	Ui16 uint16
	Ui32 uint32
	Ui64 uint64
	I16  int16
	I32  int32
	I64  int64
	F32  float32
	F64  float64
}

func (Numbers) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Numbers"`
}) {
}

func (x Numbers) VDLIsZero() bool { //nolint:gocyclo
	return x == Numbers{}
}

func (x Numbers) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct17); err != nil {
		return err
	}
	if x.B != 0 {
		if err := enc.NextFieldValueUint(0, vdl.ByteType, uint64(x.B)); err != nil {
			return err
		}
	}
	if x.Ui16 != 0 {
		if err := enc.NextFieldValueUint(1, vdl.Uint16Type, uint64(x.Ui16)); err != nil {
			return err
		}
	}
	if x.Ui32 != 0 {
		if err := enc.NextFieldValueUint(2, vdl.Uint32Type, uint64(x.Ui32)); err != nil {
			return err
		}
	}
	if x.Ui64 != 0 {
		if err := enc.NextFieldValueUint(3, vdl.Uint64Type, x.Ui64); err != nil {
			return err
		}
	}
	if x.I16 != 0 {
		if err := enc.NextFieldValueInt(4, vdl.Int16Type, int64(x.I16)); err != nil {
			return err
		}
	}
	if x.I32 != 0 {
		if err := enc.NextFieldValueInt(5, vdl.Int32Type, int64(x.I32)); err != nil {
			return err
		}
	}
	if x.I64 != 0 {
		if err := enc.NextFieldValueInt(6, vdl.Int64Type, x.I64); err != nil {
			return err
		}
	}
	if x.F32 != 0 {
		if err := enc.NextFieldValueFloat(7, vdl.Float32Type, float64(x.F32)); err != nil {
			return err
		}
	}
	if x.F64 != 0 {
		if err := enc.NextFieldValueFloat(8, vdl.Float64Type, x.F64); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Numbers) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = Numbers{}
	if err := dec.StartValue(vdlTypeStruct17); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct17 {
			index = vdlTypeStruct17.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueUint(8); {
			case err != nil:
				return err
			default:
				x.B = byte(value)
			}
		case 1:
			switch value, err := dec.ReadValueUint(16); {
			case err != nil:
				return err
			default:
				x.Ui16 = uint16(value)
			}
		case 2:
			switch value, err := dec.ReadValueUint(32); {
			case err != nil:
				return err
			default:
				x.Ui32 = uint32(value)
			}
		case 3:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.Ui64 = value
			}
		case 4:
			switch value, err := dec.ReadValueInt(16); {
			case err != nil:
				return err
			default:
				x.I16 = int16(value)
			}
		case 5:
			switch value, err := dec.ReadValueInt(32); {
			case err != nil:
				return err
			default:
				x.I32 = int32(value)
			}
		case 6:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.I64 = value
			}
		case 7:
			switch value, err := dec.ReadValueFloat(32); {
			case err != nil:
				return err
			default:
				x.F32 = float32(value)
			}
		case 8:
			switch value, err := dec.ReadValueFloat(64); {
			case err != nil:
				return err
			default:
				x.F64 = value
			}
		}
	}
}

type (
	// TitleOrValueType represents any single field of the TitleOrValueType union type.
	TitleOrValueType interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// VDLReflect describes the TitleOrValueType union type.
		VDLReflect(vdlTitleOrValueTypeReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// TitleOrValueTypeTitle represents field Title of the TitleOrValueType union type.
	TitleOrValueTypeTitle struct{ Value string }
	// TitleOrValueTypeValue represents field Value of the TitleOrValueType union type.
	TitleOrValueTypeValue struct{ Value int64 }
	// vdlTitleOrValueTypeReflect describes the TitleOrValueType union type.
	vdlTitleOrValueTypeReflect struct {
		Name  string `vdl:"v.io/v23/query/engine/internal/testdata.TitleOrValueType"`
		Type  TitleOrValueType
		Union struct {
			Title TitleOrValueTypeTitle
			Value TitleOrValueTypeValue
		}
	}
)

func (x TitleOrValueTypeTitle) Index() int                            { return 0 }
func (x TitleOrValueTypeTitle) Interface() interface{}                { return x.Value }
func (x TitleOrValueTypeTitle) Name() string                          { return "Title" }
func (x TitleOrValueTypeTitle) VDLReflect(vdlTitleOrValueTypeReflect) {}

func (x TitleOrValueTypeValue) Index() int                            { return 1 }
func (x TitleOrValueTypeValue) Interface() interface{}                { return x.Value }
func (x TitleOrValueTypeValue) Name() string                          { return "Value" }
func (x TitleOrValueTypeValue) VDLReflect(vdlTitleOrValueTypeReflect) {}

func (x TitleOrValueTypeTitle) VDLIsZero() bool { //nolint:gocyclo
	return x.Value == ""
}

func (x TitleOrValueTypeValue) VDLIsZero() bool {
	return false
}

func (x TitleOrValueTypeTitle) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion18); err != nil {
		return err
	}
	if err := enc.NextFieldValueString(0, vdl.StringType, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x TitleOrValueTypeValue) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeUnion18); err != nil {
		return err
	}
	if err := enc.NextFieldValueInt(1, vdl.Int64Type, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadTitleOrValueType(dec vdl.Decoder, x *TitleOrValueType) error { //nolint:gocyclo
	if err := dec.StartValue(vdlTypeUnion18); err != nil {
		return err
	}
	decType := dec.Type()
	index, err := dec.NextField()
	switch {
	case err != nil:
		return err
	case index == -1:
		return fmt.Errorf("missing field in union %T, from %v", x, decType)
	}
	if decType != vdlTypeUnion18 {
		name := decType.Field(index).Name
		index = vdlTypeUnion18.FieldIndexByName(name)
		if index == -1 {
			return fmt.Errorf("field %q not in union %T, from %v", name, x, decType)
		}
	}
	switch index {
	case 0:
		var field TitleOrValueTypeTitle
		switch value, err := dec.ReadValueString(); {
		case err != nil:
			return err
		default:
			field.Value = value
		}
		*x = field
	case 1:
		var field TitleOrValueTypeValue
		switch value, err := dec.ReadValueInt(64); {
		case err != nil:
			return err
		default:
			field.Value = value
		}
		*x = field
	}
	switch index, err := dec.NextField(); {
	case err != nil:
		return err
	case index != -1:
		return fmt.Errorf("extra field %d in union %T, from %v", index, x, dec.Type())
	}
	return dec.FinishValue()
}

type BazType struct {
	Name         string
	TitleOrValue TitleOrValueType
}

func (BazType) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BazType"`
}) {
}

func (x BazType) VDLIsZero() bool { //nolint:gocyclo
	if x.Name != "" {
		return false
	}
	if x.TitleOrValue != nil && !x.TitleOrValue.VDLIsZero() {
		return false
	}
	return true
}

func (x BazType) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct19); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if x.TitleOrValue != nil && !x.TitleOrValue.VDLIsZero() {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := x.TitleOrValue.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BazType) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = BazType{
		TitleOrValue: TitleOrValueTypeTitle{},
	}
	if err := dec.StartValue(vdlTypeStruct19); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct19 {
			index = vdlTypeStruct19.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			if err := VDLReadTitleOrValueType(dec, &x.TitleOrValue); err != nil {
				return err
			}
		}
	}
}

type BarType struct {
	Baz BazType
}

func (BarType) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BarType"`
}) {
}

func (x BarType) VDLIsZero() bool { //nolint:gocyclo
	return x.Baz.VDLIsZero()
}

func (x BarType) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct20); err != nil {
		return err
	}
	if !x.Baz.VDLIsZero() {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := x.Baz.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BarType) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = BarType{
		Baz: BazType{
			TitleOrValue: TitleOrValueTypeTitle{},
		},
	}
	if err := dec.StartValue(vdlTypeStruct20); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct20 {
			index = vdlTypeStruct20.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		if index == 0 {

			if err := x.Baz.VDLRead(dec); err != nil {
				return err
			}
		}
	}
}

type FooType struct {
	Bar BarType
}

func (FooType) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FooType"`
}) {
}

func (x FooType) VDLIsZero() bool { //nolint:gocyclo
	return x.Bar.VDLIsZero()
}

func (x FooType) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct21); err != nil {
		return err
	}
	if !x.Bar.VDLIsZero() {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := x.Bar.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FooType) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = FooType{
		Bar: BarType{
			Baz: BazType{
				TitleOrValue: TitleOrValueTypeTitle{},
			},
		},
	}
	if err := dec.StartValue(vdlTypeStruct21); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct21 {
			index = vdlTypeStruct21.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		if index == 0 {

			if err := x.Bar.VDLRead(dec); err != nil {
				return err
			}
		}
	}
}

type K struct {
	A byte
	B string
}

func (K) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.K"`
}) {
}

func (x K) VDLIsZero() bool { //nolint:gocyclo
	return x == K{}
}

func (x K) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct22); err != nil {
		return err
	}
	if x.A != 0 {
		if err := enc.NextFieldValueUint(0, vdl.ByteType, uint64(x.A)); err != nil {
			return err
		}
	}
	if x.B != "" {
		if err := enc.NextFieldValueString(1, vdl.StringType, x.B); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *K) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = K{}
	if err := dec.StartValue(vdlTypeStruct22); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct22 {
			index = vdlTypeStruct22.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueUint(8); {
			case err != nil:
				return err
			default:
				x.A = byte(value)
			}
		case 1:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.B = value
			}
		}
	}
}

type V struct {
	A string
	B float32
}

func (V) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.V"`
}) {
}

func (x V) VDLIsZero() bool { //nolint:gocyclo
	return x == V{}
}

func (x V) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct23); err != nil {
		return err
	}
	if x.A != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.A); err != nil {
			return err
		}
	}
	if x.B != 0 {
		if err := enc.NextFieldValueFloat(1, vdl.Float32Type, float64(x.B)); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *V) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = V{}
	if err := dec.StartValue(vdlTypeStruct23); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct23 {
			index = vdlTypeStruct23.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.A = value
			}
		case 1:
			switch value, err := dec.ReadValueFloat(32); {
			case err != nil:
				return err
			default:
				x.B = float32(value)
			}
		}
	}
}

type FunWithMaps struct {
	Key       K
	Map       map[K]V
	Confusing map[int16][]map[string]struct{}
}

func (FunWithMaps) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FunWithMaps"`
}) {
}

func (x FunWithMaps) VDLIsZero() bool { //nolint:gocyclo
	if x.Key != (K{}) {
		return false
	}
	if len(x.Map) != 0 {
		return false
	}
	if len(x.Confusing) != 0 {
		return false
	}
	return true
}

func (x FunWithMaps) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct24); err != nil {
		return err
	}
	if x.Key != (K{}) {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := x.Key.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.Map) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := vdlWriteAnonMap4(enc, x.Map); err != nil {
			return err
		}
	}
	if len(x.Confusing) != 0 {
		if err := enc.NextField(2); err != nil {
			return err
		}
		if err := vdlWriteAnonMap5(enc, x.Confusing); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap4(enc vdl.Encoder, x map[K]V) error {
	if err := enc.StartValue(vdlTypeMap25); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap5(enc vdl.Encoder, x map[int16][]map[string]struct{}) error {
	if err := enc.StartValue(vdlTypeMap26); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueInt(vdl.Int16Type, int64(key)); err != nil {
			return err
		}
		if err := vdlWriteAnonList6(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonList6(enc vdl.Encoder, x []map[string]struct{}) error {
	if err := enc.StartValue(vdlTypeList27); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := vdlWriteAnonSet7(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet7(enc vdl.Encoder, x map[string]struct{}) error {
	if err := enc.StartValue(vdlTypeSet28); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FunWithMaps) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = FunWithMaps{}
	if err := dec.StartValue(vdlTypeStruct24); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct24 {
			index = vdlTypeStruct24.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			if err := x.Key.VDLRead(dec); err != nil {
				return err
			}
		case 1:
			if err := vdlReadAnonMap4(dec, &x.Map); err != nil {
				return err
			}
		case 2:
			if err := vdlReadAnonMap5(dec, &x.Confusing); err != nil {
				return err
			}
		}
	}
}

func vdlReadAnonMap4(dec vdl.Decoder, x *map[K]V) error {
	if err := dec.StartValue(vdlTypeMap25); err != nil {
		return err
	}
	var tmpMap map[K]V
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[K]V, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var key K
			if err := key.VDLRead(dec); err != nil {
				return err
			}
			var elem V
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[K]V)
			}
			tmpMap[key] = elem
		}
	}
}

func vdlReadAnonMap5(dec vdl.Decoder, x *map[int16][]map[string]struct{}) error {
	if err := dec.StartValue(vdlTypeMap26); err != nil {
		return err
	}
	var tmpMap map[int16][]map[string]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int16][]map[string]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(16); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem []map[string]struct{}
			if err := vdlReadAnonList6(dec, &elem); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[int16][]map[string]struct{})
			}
			tmpMap[int16(key)] = elem
		}
	}
}

func vdlReadAnonList6(dec vdl.Decoder, x *[]map[string]struct{}) error {
	if err := dec.StartValue(vdlTypeList27); err != nil {
		return err
	}
	if len := dec.LenHint(); len > 0 {
		*x = make([]map[string]struct{}, 0, len)
	} else {
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		default:
			var elem map[string]struct{}
			if err := vdlReadAnonSet7(dec, &elem); err != nil {
				return err
			}
			*x = append(*x, elem)
		}
	}
}

func vdlReadAnonSet7(dec vdl.Decoder, x *map[string]struct{}) error {
	if err := dec.StartValue(vdlTypeSet28); err != nil {
		return err
	}
	var tmpMap map[string]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[string]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

type FunWithTypes struct {
	T1 *vdl.Type
	T2 *vdl.Type
}

func (FunWithTypes) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FunWithTypes"`
}) {
}

func (x FunWithTypes) VDLIsZero() bool { //nolint:gocyclo
	if x.T1 != nil && x.T1 != vdl.AnyType {
		return false
	}
	if x.T2 != nil && x.T2 != vdl.AnyType {
		return false
	}
	return true
}

func (x FunWithTypes) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct29); err != nil {
		return err
	}
	if x.T1 != nil && x.T1 != vdl.AnyType {
		if err := enc.NextFieldValueTypeObject(0, x.T1); err != nil {
			return err
		}
	}
	if x.T2 != nil && x.T2 != vdl.AnyType {
		if err := enc.NextFieldValueTypeObject(1, x.T2); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FunWithTypes) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = FunWithTypes{
		T1: vdl.AnyType,
		T2: vdl.AnyType,
	}
	if err := dec.StartValue(vdlTypeStruct29); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct29 {
			index = vdlTypeStruct29.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueTypeObject(); {
			case err != nil:
				return err
			default:
				x.T1 = value
			}
		case 1:
			switch value, err := dec.ReadValueTypeObject(); {
			case err != nil:
				return err
			default:
				x.T2 = value
			}
		}
	}
}

type ManyMaps struct {
	B   map[bool]string
	By  map[byte]string
	U16 map[uint16]string
	U32 map[uint32]string
	U64 map[uint64]string
	I16 map[int16]string
	I32 map[int32]string
	I64 map[int64]string
	F32 map[float32]string
	F64 map[float64]string
	S   map[string]string
	Ms  map[string]map[string]string
	T   map[time.Time]string
}

func (ManyMaps) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ManyMaps"`
}) {
}

func (x ManyMaps) VDLIsZero() bool { //nolint:gocyclo
	if len(x.B) != 0 {
		return false
	}
	if len(x.By) != 0 {
		return false
	}
	if len(x.U16) != 0 {
		return false
	}
	if len(x.U32) != 0 {
		return false
	}
	if len(x.U64) != 0 {
		return false
	}
	if len(x.I16) != 0 {
		return false
	}
	if len(x.I32) != 0 {
		return false
	}
	if len(x.I64) != 0 {
		return false
	}
	if len(x.F32) != 0 {
		return false
	}
	if len(x.F64) != 0 {
		return false
	}
	if len(x.S) != 0 {
		return false
	}
	if len(x.Ms) != 0 {
		return false
	}
	if len(x.T) != 0 {
		return false
	}
	return true
}

func (x ManyMaps) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct30); err != nil {
		return err
	}
	if len(x.B) != 0 {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := vdlWriteAnonMap8(enc, x.B); err != nil {
			return err
		}
	}
	if len(x.By) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := vdlWriteAnonMap9(enc, x.By); err != nil {
			return err
		}
	}
	if len(x.U16) != 0 {
		if err := enc.NextField(2); err != nil {
			return err
		}
		if err := vdlWriteAnonMap10(enc, x.U16); err != nil {
			return err
		}
	}
	if len(x.U32) != 0 {
		if err := enc.NextField(3); err != nil {
			return err
		}
		if err := vdlWriteAnonMap11(enc, x.U32); err != nil {
			return err
		}
	}
	if len(x.U64) != 0 {
		if err := enc.NextField(4); err != nil {
			return err
		}
		if err := vdlWriteAnonMap12(enc, x.U64); err != nil {
			return err
		}
	}
	if len(x.I16) != 0 {
		if err := enc.NextField(5); err != nil {
			return err
		}
		if err := vdlWriteAnonMap13(enc, x.I16); err != nil {
			return err
		}
	}
	if len(x.I32) != 0 {
		if err := enc.NextField(6); err != nil {
			return err
		}
		if err := vdlWriteAnonMap14(enc, x.I32); err != nil {
			return err
		}
	}
	if len(x.I64) != 0 {
		if err := enc.NextField(7); err != nil {
			return err
		}
		if err := vdlWriteAnonMap15(enc, x.I64); err != nil {
			return err
		}
	}
	if len(x.F32) != 0 {
		if err := enc.NextField(8); err != nil {
			return err
		}
		if err := vdlWriteAnonMap16(enc, x.F32); err != nil {
			return err
		}
	}
	if len(x.F64) != 0 {
		if err := enc.NextField(9); err != nil {
			return err
		}
		if err := vdlWriteAnonMap17(enc, x.F64); err != nil {
			return err
		}
	}
	if len(x.S) != 0 {
		if err := enc.NextField(10); err != nil {
			return err
		}
		if err := vdlWriteAnonMap18(enc, x.S); err != nil {
			return err
		}
	}
	if len(x.Ms) != 0 {
		if err := enc.NextField(11); err != nil {
			return err
		}
		if err := vdlWriteAnonMap19(enc, x.Ms); err != nil {
			return err
		}
	}
	if len(x.T) != 0 {
		if err := enc.NextField(12); err != nil {
			return err
		}
		if err := vdlWriteAnonMap20(enc, x.T); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap8(enc vdl.Encoder, x map[bool]string) error {
	if err := enc.StartValue(vdlTypeMap31); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueBool(vdl.BoolType, key); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap9(enc vdl.Encoder, x map[byte]string) error {
	if err := enc.StartValue(vdlTypeMap32); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueUint(vdl.ByteType, uint64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap10(enc vdl.Encoder, x map[uint16]string) error {
	if err := enc.StartValue(vdlTypeMap33); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueUint(vdl.Uint16Type, uint64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap11(enc vdl.Encoder, x map[uint32]string) error {
	if err := enc.StartValue(vdlTypeMap34); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueUint(vdl.Uint32Type, uint64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap12(enc vdl.Encoder, x map[uint64]string) error {
	if err := enc.StartValue(vdlTypeMap35); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueUint(vdl.Uint64Type, key); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap13(enc vdl.Encoder, x map[int16]string) error {
	if err := enc.StartValue(vdlTypeMap36); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueInt(vdl.Int16Type, int64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap14(enc vdl.Encoder, x map[int32]string) error {
	if err := enc.StartValue(vdlTypeMap37); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueInt(vdl.Int32Type, int64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap15(enc vdl.Encoder, x map[int64]string) error {
	if err := enc.StartValue(vdlTypeMap38); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueInt(vdl.Int64Type, key); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap16(enc vdl.Encoder, x map[float32]string) error {
	if err := enc.StartValue(vdlTypeMap39); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueFloat(vdl.Float32Type, float64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap17(enc vdl.Encoder, x map[float64]string) error {
	if err := enc.StartValue(vdlTypeMap40); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueFloat(vdl.Float64Type, key); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap18(enc vdl.Encoder, x map[string]string) error {
	if err := enc.StartValue(vdlTypeMap41); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap19(enc vdl.Encoder, x map[string]map[string]string) error {
	if err := enc.StartValue(vdlTypeMap42); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
		if err := vdlWriteAnonMap18(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonMap20(enc vdl.Encoder, x map[time.Time]string) error {
	if err := enc.StartValue(vdlTypeMap43); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, key); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ManyMaps) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = ManyMaps{}
	if err := dec.StartValue(vdlTypeStruct30); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct30 {
			index = vdlTypeStruct30.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			if err := vdlReadAnonMap8(dec, &x.B); err != nil {
				return err
			}
		case 1:
			if err := vdlReadAnonMap9(dec, &x.By); err != nil {
				return err
			}
		case 2:
			if err := vdlReadAnonMap10(dec, &x.U16); err != nil {
				return err
			}
		case 3:
			if err := vdlReadAnonMap11(dec, &x.U32); err != nil {
				return err
			}
		case 4:
			if err := vdlReadAnonMap12(dec, &x.U64); err != nil {
				return err
			}
		case 5:
			if err := vdlReadAnonMap13(dec, &x.I16); err != nil {
				return err
			}
		case 6:
			if err := vdlReadAnonMap14(dec, &x.I32); err != nil {
				return err
			}
		case 7:
			if err := vdlReadAnonMap15(dec, &x.I64); err != nil {
				return err
			}
		case 8:
			if err := vdlReadAnonMap16(dec, &x.F32); err != nil {
				return err
			}
		case 9:
			if err := vdlReadAnonMap17(dec, &x.F64); err != nil {
				return err
			}
		case 10:
			if err := vdlReadAnonMap18(dec, &x.S); err != nil {
				return err
			}
		case 11:
			if err := vdlReadAnonMap19(dec, &x.Ms); err != nil {
				return err
			}
		case 12:
			if err := vdlReadAnonMap20(dec, &x.T); err != nil {
				return err
			}
		}
	}
}

func vdlReadAnonMap8(dec vdl.Decoder, x *map[bool]string) error {
	if err := dec.StartValue(vdlTypeMap31); err != nil {
		return err
	}
	var tmpMap map[bool]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[bool]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueBool(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[bool]string)
			}
			tmpMap[key] = elem
		}
	}
}

func vdlReadAnonMap9(dec vdl.Decoder, x *map[byte]string) error {
	if err := dec.StartValue(vdlTypeMap32); err != nil {
		return err
	}
	var tmpMap map[byte]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[byte]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(8); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[byte]string)
			}
			tmpMap[byte(key)] = elem
		}
	}
}

func vdlReadAnonMap10(dec vdl.Decoder, x *map[uint16]string) error {
	if err := dec.StartValue(vdlTypeMap33); err != nil {
		return err
	}
	var tmpMap map[uint16]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint16]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(16); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[uint16]string)
			}
			tmpMap[uint16(key)] = elem
		}
	}
}

func vdlReadAnonMap11(dec vdl.Decoder, x *map[uint32]string) error {
	if err := dec.StartValue(vdlTypeMap34); err != nil {
		return err
	}
	var tmpMap map[uint32]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint32]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[uint32]string)
			}
			tmpMap[uint32(key)] = elem
		}
	}
}

func vdlReadAnonMap12(dec vdl.Decoder, x *map[uint64]string) error {
	if err := dec.StartValue(vdlTypeMap35); err != nil {
		return err
	}
	var tmpMap map[uint64]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint64]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[uint64]string)
			}
			tmpMap[key] = elem
		}
	}
}

func vdlReadAnonMap13(dec vdl.Decoder, x *map[int16]string) error {
	if err := dec.StartValue(vdlTypeMap36); err != nil {
		return err
	}
	var tmpMap map[int16]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int16]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(16); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[int16]string)
			}
			tmpMap[int16(key)] = elem
		}
	}
}

func vdlReadAnonMap14(dec vdl.Decoder, x *map[int32]string) error {
	if err := dec.StartValue(vdlTypeMap37); err != nil {
		return err
	}
	var tmpMap map[int32]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int32]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[int32]string)
			}
			tmpMap[int32(key)] = elem
		}
	}
}

func vdlReadAnonMap15(dec vdl.Decoder, x *map[int64]string) error {
	if err := dec.StartValue(vdlTypeMap38); err != nil {
		return err
	}
	var tmpMap map[int64]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int64]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[int64]string)
			}
			tmpMap[key] = elem
		}
	}
}

func vdlReadAnonMap16(dec vdl.Decoder, x *map[float32]string) error {
	if err := dec.StartValue(vdlTypeMap39); err != nil {
		return err
	}
	var tmpMap map[float32]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float32]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueFloat(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[float32]string)
			}
			tmpMap[float32(key)] = elem
		}
	}
}

func vdlReadAnonMap17(dec vdl.Decoder, x *map[float64]string) error {
	if err := dec.StartValue(vdlTypeMap40); err != nil {
		return err
	}
	var tmpMap map[float64]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float64]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueFloat(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[float64]string)
			}
			tmpMap[key] = elem
		}
	}
}

func vdlReadAnonMap18(dec vdl.Decoder, x *map[string]string) error {
	if err := dec.StartValue(vdlTypeMap41); err != nil {
		return err
	}
	var tmpMap map[string]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[string]string)
			}
			tmpMap[key] = elem
		}
	}
}

func vdlReadAnonMap19(dec vdl.Decoder, x *map[string]map[string]string) error {
	if err := dec.StartValue(vdlTypeMap42); err != nil {
		return err
	}
	var tmpMap map[string]map[string]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]map[string]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem map[string]string
			if err := vdlReadAnonMap18(dec, &elem); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[string]map[string]string)
			}
			tmpMap[key] = elem
		}
	}
}

func vdlReadAnonMap20(dec vdl.Decoder, x *map[time.Time]string) error {
	if err := dec.StartValue(vdlTypeMap43); err != nil {
		return err
	}
	var tmpMap map[time.Time]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[time.Time]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var key time.Time
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &key); err != nil {
				return err
			}
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[time.Time]string)
			}
			tmpMap[key] = elem
		}
	}
}

type ManySets struct {
	B   map[bool]struct{}
	By  map[byte]struct{}
	U16 map[uint16]struct{}
	U32 map[uint32]struct{}
	U64 map[uint64]struct{}
	I16 map[int16]struct{}
	I32 map[int32]struct{}
	I64 map[int64]struct{}
	F32 map[float32]struct{}
	F64 map[float64]struct{}
	S   map[string]struct{}
	T   map[time.Time]struct{}
}

func (ManySets) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ManySets"`
}) {
}

func (x ManySets) VDLIsZero() bool { //nolint:gocyclo
	if len(x.B) != 0 {
		return false
	}
	if len(x.By) != 0 {
		return false
	}
	if len(x.U16) != 0 {
		return false
	}
	if len(x.U32) != 0 {
		return false
	}
	if len(x.U64) != 0 {
		return false
	}
	if len(x.I16) != 0 {
		return false
	}
	if len(x.I32) != 0 {
		return false
	}
	if len(x.I64) != 0 {
		return false
	}
	if len(x.F32) != 0 {
		return false
	}
	if len(x.F64) != 0 {
		return false
	}
	if len(x.S) != 0 {
		return false
	}
	if len(x.T) != 0 {
		return false
	}
	return true
}

func (x ManySets) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct44); err != nil {
		return err
	}
	if len(x.B) != 0 {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := vdlWriteAnonSet21(enc, x.B); err != nil {
			return err
		}
	}
	if len(x.By) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := vdlWriteAnonSet22(enc, x.By); err != nil {
			return err
		}
	}
	if len(x.U16) != 0 {
		if err := enc.NextField(2); err != nil {
			return err
		}
		if err := vdlWriteAnonSet23(enc, x.U16); err != nil {
			return err
		}
	}
	if len(x.U32) != 0 {
		if err := enc.NextField(3); err != nil {
			return err
		}
		if err := vdlWriteAnonSet24(enc, x.U32); err != nil {
			return err
		}
	}
	if len(x.U64) != 0 {
		if err := enc.NextField(4); err != nil {
			return err
		}
		if err := vdlWriteAnonSet25(enc, x.U64); err != nil {
			return err
		}
	}
	if len(x.I16) != 0 {
		if err := enc.NextField(5); err != nil {
			return err
		}
		if err := vdlWriteAnonSet26(enc, x.I16); err != nil {
			return err
		}
	}
	if len(x.I32) != 0 {
		if err := enc.NextField(6); err != nil {
			return err
		}
		if err := vdlWriteAnonSet27(enc, x.I32); err != nil {
			return err
		}
	}
	if len(x.I64) != 0 {
		if err := enc.NextField(7); err != nil {
			return err
		}
		if err := vdlWriteAnonSet28(enc, x.I64); err != nil {
			return err
		}
	}
	if len(x.F32) != 0 {
		if err := enc.NextField(8); err != nil {
			return err
		}
		if err := vdlWriteAnonSet29(enc, x.F32); err != nil {
			return err
		}
	}
	if len(x.F64) != 0 {
		if err := enc.NextField(9); err != nil {
			return err
		}
		if err := vdlWriteAnonSet30(enc, x.F64); err != nil {
			return err
		}
	}
	if len(x.S) != 0 {
		if err := enc.NextField(10); err != nil {
			return err
		}
		if err := vdlWriteAnonSet7(enc, x.S); err != nil {
			return err
		}
	}
	if len(x.T) != 0 {
		if err := enc.NextField(11); err != nil {
			return err
		}
		if err := vdlWriteAnonSet31(enc, x.T); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet21(enc vdl.Encoder, x map[bool]struct{}) error {
	if err := enc.StartValue(vdlTypeSet45); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueBool(vdl.BoolType, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet22(enc vdl.Encoder, x map[byte]struct{}) error {
	if err := enc.StartValue(vdlTypeSet46); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueUint(vdl.ByteType, uint64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet23(enc vdl.Encoder, x map[uint16]struct{}) error {
	if err := enc.StartValue(vdlTypeSet47); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueUint(vdl.Uint16Type, uint64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet24(enc vdl.Encoder, x map[uint32]struct{}) error {
	if err := enc.StartValue(vdlTypeSet48); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueUint(vdl.Uint32Type, uint64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet25(enc vdl.Encoder, x map[uint64]struct{}) error {
	if err := enc.StartValue(vdlTypeSet49); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueUint(vdl.Uint64Type, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet26(enc vdl.Encoder, x map[int16]struct{}) error {
	if err := enc.StartValue(vdlTypeSet50); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueInt(vdl.Int16Type, int64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet27(enc vdl.Encoder, x map[int32]struct{}) error {
	if err := enc.StartValue(vdlTypeSet51); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueInt(vdl.Int32Type, int64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet28(enc vdl.Encoder, x map[int64]struct{}) error {
	if err := enc.StartValue(vdlTypeSet52); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueInt(vdl.Int64Type, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet29(enc vdl.Encoder, x map[float32]struct{}) error {
	if err := enc.StartValue(vdlTypeSet53); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueFloat(vdl.Float32Type, float64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet30(enc vdl.Encoder, x map[float64]struct{}) error {
	if err := enc.StartValue(vdlTypeSet54); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueFloat(vdl.Float64Type, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func vdlWriteAnonSet31(enc vdl.Encoder, x map[time.Time]struct{}) error {
	if err := enc.StartValue(vdlTypeSet55); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, key); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ManySets) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = ManySets{}
	if err := dec.StartValue(vdlTypeStruct44); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct44 {
			index = vdlTypeStruct44.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			if err := vdlReadAnonSet21(dec, &x.B); err != nil {
				return err
			}
		case 1:
			if err := vdlReadAnonSet22(dec, &x.By); err != nil {
				return err
			}
		case 2:
			if err := vdlReadAnonSet23(dec, &x.U16); err != nil {
				return err
			}
		case 3:
			if err := vdlReadAnonSet24(dec, &x.U32); err != nil {
				return err
			}
		case 4:
			if err := vdlReadAnonSet25(dec, &x.U64); err != nil {
				return err
			}
		case 5:
			if err := vdlReadAnonSet26(dec, &x.I16); err != nil {
				return err
			}
		case 6:
			if err := vdlReadAnonSet27(dec, &x.I32); err != nil {
				return err
			}
		case 7:
			if err := vdlReadAnonSet28(dec, &x.I64); err != nil {
				return err
			}
		case 8:
			if err := vdlReadAnonSet29(dec, &x.F32); err != nil {
				return err
			}
		case 9:
			if err := vdlReadAnonSet30(dec, &x.F64); err != nil {
				return err
			}
		case 10:
			if err := vdlReadAnonSet7(dec, &x.S); err != nil {
				return err
			}
		case 11:
			if err := vdlReadAnonSet31(dec, &x.T); err != nil {
				return err
			}
		}
	}
}

func vdlReadAnonSet21(dec vdl.Decoder, x *map[bool]struct{}) error {
	if err := dec.StartValue(vdlTypeSet45); err != nil {
		return err
	}
	var tmpMap map[bool]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[bool]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueBool(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[bool]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

func vdlReadAnonSet22(dec vdl.Decoder, x *map[byte]struct{}) error {
	if err := dec.StartValue(vdlTypeSet46); err != nil {
		return err
	}
	var tmpMap map[byte]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[byte]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(8); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[byte]struct{})
			}
			tmpMap[byte(key)] = struct{}{}
		}
	}
}

func vdlReadAnonSet23(dec vdl.Decoder, x *map[uint16]struct{}) error {
	if err := dec.StartValue(vdlTypeSet47); err != nil {
		return err
	}
	var tmpMap map[uint16]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint16]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(16); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[uint16]struct{})
			}
			tmpMap[uint16(key)] = struct{}{}
		}
	}
}

func vdlReadAnonSet24(dec vdl.Decoder, x *map[uint32]struct{}) error {
	if err := dec.StartValue(vdlTypeSet48); err != nil {
		return err
	}
	var tmpMap map[uint32]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint32]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[uint32]struct{})
			}
			tmpMap[uint32(key)] = struct{}{}
		}
	}
}

func vdlReadAnonSet25(dec vdl.Decoder, x *map[uint64]struct{}) error {
	if err := dec.StartValue(vdlTypeSet49); err != nil {
		return err
	}
	var tmpMap map[uint64]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint64]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[uint64]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

func vdlReadAnonSet26(dec vdl.Decoder, x *map[int16]struct{}) error {
	if err := dec.StartValue(vdlTypeSet50); err != nil {
		return err
	}
	var tmpMap map[int16]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int16]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(16); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[int16]struct{})
			}
			tmpMap[int16(key)] = struct{}{}
		}
	}
}

func vdlReadAnonSet27(dec vdl.Decoder, x *map[int32]struct{}) error {
	if err := dec.StartValue(vdlTypeSet51); err != nil {
		return err
	}
	var tmpMap map[int32]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int32]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[int32]struct{})
			}
			tmpMap[int32(key)] = struct{}{}
		}
	}
}

func vdlReadAnonSet28(dec vdl.Decoder, x *map[int64]struct{}) error {
	if err := dec.StartValue(vdlTypeSet52); err != nil {
		return err
	}
	var tmpMap map[int64]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int64]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[int64]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

func vdlReadAnonSet29(dec vdl.Decoder, x *map[float32]struct{}) error {
	if err := dec.StartValue(vdlTypeSet53); err != nil {
		return err
	}
	var tmpMap map[float32]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float32]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueFloat(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[float32]struct{})
			}
			tmpMap[float32(key)] = struct{}{}
		}
	}
}

func vdlReadAnonSet30(dec vdl.Decoder, x *map[float64]struct{}) error {
	if err := dec.StartValue(vdlTypeSet54); err != nil {
		return err
	}
	var tmpMap map[float64]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float64]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueFloat(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[float64]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

func vdlReadAnonSet31(dec vdl.Decoder, x *map[time.Time]struct{}) error {
	if err := dec.StartValue(vdlTypeSet55); err != nil {
		return err
	}
	var tmpMap map[time.Time]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[time.Time]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var key time.Time
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &key); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[time.Time]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

type BigData struct {
	Key string // A dup of the key stored in the value.
}

func (BigData) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BigData"`
}) {
}

func (x BigData) VDLIsZero() bool { //nolint:gocyclo
	return x == BigData{}
}

func (x BigData) VDLWrite(enc vdl.Encoder) error { //nolint:gocyclo
	if err := enc.StartValue(vdlTypeStruct56); err != nil {
		return err
	}
	if x.Key != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Key); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BigData) VDLRead(dec vdl.Decoder) error { //nolint:gocyclo
	*x = BigData{}
	if err := dec.StartValue(vdlTypeStruct56); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != vdlTypeStruct56 {
			index = vdlTypeStruct56.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		if index == 0 {

			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Key = value
			}
		}
	}
}

// Hold type definitions in package-level variables, for better performance.
//nolint:unused
var (
	vdlTypeStruct1  *vdl.Type
	vdlTypeEnum2    *vdl.Type
	vdlTypeEnum3    *vdl.Type
	vdlTypeArray4   *vdl.Type
	vdlTypeStruct5  *vdl.Type
	vdlTypeEnum6    *vdl.Type
	vdlTypeStruct7  *vdl.Type
	vdlTypeSet8     *vdl.Type
	vdlTypeStruct9  *vdl.Type
	vdlTypeMap10    *vdl.Type
	vdlTypeUnion11  *vdl.Type
	vdlTypeStruct12 *vdl.Type
	vdlTypeStruct13 *vdl.Type
	vdlTypeList14   *vdl.Type
	vdlTypeStruct15 *vdl.Type
	vdlTypeStruct16 *vdl.Type
	vdlTypeStruct17 *vdl.Type
	vdlTypeUnion18  *vdl.Type
	vdlTypeStruct19 *vdl.Type
	vdlTypeStruct20 *vdl.Type
	vdlTypeStruct21 *vdl.Type
	vdlTypeStruct22 *vdl.Type
	vdlTypeStruct23 *vdl.Type
	vdlTypeStruct24 *vdl.Type
	vdlTypeMap25    *vdl.Type
	vdlTypeMap26    *vdl.Type
	vdlTypeList27   *vdl.Type
	vdlTypeSet28    *vdl.Type
	vdlTypeStruct29 *vdl.Type
	vdlTypeStruct30 *vdl.Type
	vdlTypeMap31    *vdl.Type
	vdlTypeMap32    *vdl.Type
	vdlTypeMap33    *vdl.Type
	vdlTypeMap34    *vdl.Type
	vdlTypeMap35    *vdl.Type
	vdlTypeMap36    *vdl.Type
	vdlTypeMap37    *vdl.Type
	vdlTypeMap38    *vdl.Type
	vdlTypeMap39    *vdl.Type
	vdlTypeMap40    *vdl.Type
	vdlTypeMap41    *vdl.Type
	vdlTypeMap42    *vdl.Type
	vdlTypeMap43    *vdl.Type
	vdlTypeStruct44 *vdl.Type
	vdlTypeSet45    *vdl.Type
	vdlTypeSet46    *vdl.Type
	vdlTypeSet47    *vdl.Type
	vdlTypeSet48    *vdl.Type
	vdlTypeSet49    *vdl.Type
	vdlTypeSet50    *vdl.Type
	vdlTypeSet51    *vdl.Type
	vdlTypeSet52    *vdl.Type
	vdlTypeSet53    *vdl.Type
	vdlTypeSet54    *vdl.Type
	vdlTypeSet55    *vdl.Type
	vdlTypeStruct56 *vdl.Type
)

var initializeVDLCalled bool

// initializeVDL performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = initializeVDL()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func initializeVDL() struct{} {
	if initializeVDLCalled {
		return struct{}{}
	}
	initializeVDLCalled = true

	// Register types.
	vdl.Register((*AddressInfo)(nil))
	vdl.Register((*CreditAgency)(nil))
	vdl.Register((*ExperianRating)(nil))
	vdl.Register((*RatingsArray)(nil))
	vdl.Register((*EquifaxCreditReport)(nil))
	vdl.Register((*Tdh)(nil))
	vdl.Register((*ExperianCreditReport)(nil))
	vdl.Register((*TransUnionCreditReport)(nil))
	vdl.Register((*AgencyReport)(nil))
	vdl.Register((*CreditReport)(nil))
	vdl.Register((*Customer)(nil))
	vdl.Register((*Invoice)(nil))
	vdl.Register((*Numbers)(nil))
	vdl.Register((*TitleOrValueType)(nil))
	vdl.Register((*BazType)(nil))
	vdl.Register((*BarType)(nil))
	vdl.Register((*FooType)(nil))
	vdl.Register((*K)(nil))
	vdl.Register((*V)(nil))
	vdl.Register((*FunWithMaps)(nil))
	vdl.Register((*FunWithTypes)(nil))
	vdl.Register((*ManyMaps)(nil))
	vdl.Register((*ManySets)(nil))
	vdl.Register((*BigData)(nil))

	// Initialize type definitions.
	vdlTypeStruct1 = vdl.TypeOf((*AddressInfo)(nil)).Elem()
	vdlTypeEnum2 = vdl.TypeOf((*CreditAgency)(nil))
	vdlTypeEnum3 = vdl.TypeOf((*ExperianRating)(nil))
	vdlTypeArray4 = vdl.TypeOf((*RatingsArray)(nil))
	vdlTypeStruct5 = vdl.TypeOf((*EquifaxCreditReport)(nil)).Elem()
	vdlTypeEnum6 = vdl.TypeOf((*Tdh)(nil))
	vdlTypeStruct7 = vdl.TypeOf((*ExperianCreditReport)(nil)).Elem()
	vdlTypeSet8 = vdl.TypeOf((*map[Tdh]struct{})(nil))
	vdlTypeStruct9 = vdl.TypeOf((*TransUnionCreditReport)(nil)).Elem()
	vdlTypeMap10 = vdl.TypeOf((*map[string]int16)(nil))
	vdlTypeUnion11 = vdl.TypeOf((*AgencyReport)(nil))
	vdlTypeStruct12 = vdl.TypeOf((*CreditReport)(nil)).Elem()
	vdlTypeStruct13 = vdl.TypeOf((*Customer)(nil)).Elem()
	vdlTypeList14 = vdl.TypeOf((*[]AddressInfo)(nil))
	vdlTypeStruct15 = vdl.TypeOf((*Invoice)(nil)).Elem()
	vdlTypeStruct16 = vdl.TypeOf((*vdltime.Time)(nil)).Elem()
	vdlTypeStruct17 = vdl.TypeOf((*Numbers)(nil)).Elem()
	vdlTypeUnion18 = vdl.TypeOf((*TitleOrValueType)(nil))
	vdlTypeStruct19 = vdl.TypeOf((*BazType)(nil)).Elem()
	vdlTypeStruct20 = vdl.TypeOf((*BarType)(nil)).Elem()
	vdlTypeStruct21 = vdl.TypeOf((*FooType)(nil)).Elem()
	vdlTypeStruct22 = vdl.TypeOf((*K)(nil)).Elem()
	vdlTypeStruct23 = vdl.TypeOf((*V)(nil)).Elem()
	vdlTypeStruct24 = vdl.TypeOf((*FunWithMaps)(nil)).Elem()
	vdlTypeMap25 = vdl.TypeOf((*map[K]V)(nil))
	vdlTypeMap26 = vdl.TypeOf((*map[int16][]map[string]struct{})(nil))
	vdlTypeList27 = vdl.TypeOf((*[]map[string]struct{})(nil))
	vdlTypeSet28 = vdl.TypeOf((*map[string]struct{})(nil))
	vdlTypeStruct29 = vdl.TypeOf((*FunWithTypes)(nil)).Elem()
	vdlTypeStruct30 = vdl.TypeOf((*ManyMaps)(nil)).Elem()
	vdlTypeMap31 = vdl.TypeOf((*map[bool]string)(nil))
	vdlTypeMap32 = vdl.TypeOf((*map[byte]string)(nil))
	vdlTypeMap33 = vdl.TypeOf((*map[uint16]string)(nil))
	vdlTypeMap34 = vdl.TypeOf((*map[uint32]string)(nil))
	vdlTypeMap35 = vdl.TypeOf((*map[uint64]string)(nil))
	vdlTypeMap36 = vdl.TypeOf((*map[int16]string)(nil))
	vdlTypeMap37 = vdl.TypeOf((*map[int32]string)(nil))
	vdlTypeMap38 = vdl.TypeOf((*map[int64]string)(nil))
	vdlTypeMap39 = vdl.TypeOf((*map[float32]string)(nil))
	vdlTypeMap40 = vdl.TypeOf((*map[float64]string)(nil))
	vdlTypeMap41 = vdl.TypeOf((*map[string]string)(nil))
	vdlTypeMap42 = vdl.TypeOf((*map[string]map[string]string)(nil))
	vdlTypeMap43 = vdl.TypeOf((*map[time.Time]string)(nil))
	vdlTypeStruct44 = vdl.TypeOf((*ManySets)(nil)).Elem()
	vdlTypeSet45 = vdl.TypeOf((*map[bool]struct{})(nil))
	vdlTypeSet46 = vdl.TypeOf((*map[byte]struct{})(nil))
	vdlTypeSet47 = vdl.TypeOf((*map[uint16]struct{})(nil))
	vdlTypeSet48 = vdl.TypeOf((*map[uint32]struct{})(nil))
	vdlTypeSet49 = vdl.TypeOf((*map[uint64]struct{})(nil))
	vdlTypeSet50 = vdl.TypeOf((*map[int16]struct{})(nil))
	vdlTypeSet51 = vdl.TypeOf((*map[int32]struct{})(nil))
	vdlTypeSet52 = vdl.TypeOf((*map[int64]struct{})(nil))
	vdlTypeSet53 = vdl.TypeOf((*map[float32]struct{})(nil))
	vdlTypeSet54 = vdl.TypeOf((*map[float64]struct{})(nil))
	vdlTypeSet55 = vdl.TypeOf((*map[time.Time]struct{})(nil))
	vdlTypeStruct56 = vdl.TypeOf((*BigData)(nil)).Elem()

	return struct{}{}
}
