// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: testdata

package testdata

import (
	"fmt"
	"time"
	"v.io/v23/vdl"
	vdltime "v.io/v23/vdlroot/time"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

type AddressInfo struct {
	Street string
	City   string
	State  string
	Zip    string
}

func (AddressInfo) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.AddressInfo"`
}) {
}

func (x AddressInfo) VDLIsZero() bool {
	return x == AddressInfo{}
}

func (x AddressInfo) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_1); err != nil {
		return err
	}
	if x.Street != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Street); err != nil {
			return err
		}
	}
	if x.City != "" {
		if err := enc.NextFieldValueString(1, vdl.StringType, x.City); err != nil {
			return err
		}
	}
	if x.State != "" {
		if err := enc.NextFieldValueString(2, vdl.StringType, x.State); err != nil {
			return err
		}
	}
	if x.Zip != "" {
		if err := enc.NextFieldValueString(3, vdl.StringType, x.Zip); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *AddressInfo) VDLRead(dec vdl.Decoder) error {
	*x = AddressInfo{}
	if err := dec.StartValue(__VDLType_struct_1); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_1 {
			index = __VDLType_struct_1.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Street = value
			}
		case 1:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.City = value
			}
		case 2:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.State = value
			}
		case 3:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Zip = value
			}
		}
	}
}

type CreditAgency int

const (
	CreditAgencyEquifax CreditAgency = iota
	CreditAgencyExperian
	CreditAgencyTransUnion
)

// CreditAgencyAll holds all labels for CreditAgency.
var CreditAgencyAll = [...]CreditAgency{CreditAgencyEquifax, CreditAgencyExperian, CreditAgencyTransUnion}

// CreditAgencyFromString creates a CreditAgency from a string label.
func CreditAgencyFromString(label string) (x CreditAgency, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *CreditAgency) Set(label string) error {
	switch label {
	case "Equifax", "equifax":
		*x = CreditAgencyEquifax
		return nil
	case "Experian", "experian":
		*x = CreditAgencyExperian
		return nil
	case "TransUnion", "transunion":
		*x = CreditAgencyTransUnion
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.CreditAgency", label)
}

// String returns the string label of x.
func (x CreditAgency) String() string {
	switch x {
	case CreditAgencyEquifax:
		return "Equifax"
	case CreditAgencyExperian:
		return "Experian"
	case CreditAgencyTransUnion:
		return "TransUnion"
	}
	return ""
}

func (CreditAgency) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.CreditAgency"`
	Enum struct{ Equifax, Experian, TransUnion string }
}) {
}

func (x CreditAgency) VDLIsZero() bool {
	return x == CreditAgencyEquifax
}

func (x CreditAgency) VDLWrite(enc vdl.Encoder) error {
	if err := enc.WriteValueString(__VDLType_enum_2, x.String()); err != nil {
		return err
	}
	return nil
}

func (x *CreditAgency) VDLRead(dec vdl.Decoder) error {
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		if err := x.Set(value); err != nil {
			return err
		}
	}
	return nil
}

type ExperianRating int

const (
	ExperianRatingGood ExperianRating = iota
	ExperianRatingBad
)

// ExperianRatingAll holds all labels for ExperianRating.
var ExperianRatingAll = [...]ExperianRating{ExperianRatingGood, ExperianRatingBad}

// ExperianRatingFromString creates a ExperianRating from a string label.
func ExperianRatingFromString(label string) (x ExperianRating, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ExperianRating) Set(label string) error {
	switch label {
	case "Good", "good":
		*x = ExperianRatingGood
		return nil
	case "Bad", "bad":
		*x = ExperianRatingBad
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.ExperianRating", label)
}

// String returns the string label of x.
func (x ExperianRating) String() string {
	switch x {
	case ExperianRatingGood:
		return "Good"
	case ExperianRatingBad:
		return "Bad"
	}
	return ""
}

func (ExperianRating) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ExperianRating"`
	Enum struct{ Good, Bad string }
}) {
}

func (x ExperianRating) VDLIsZero() bool {
	return x == ExperianRatingGood
}

func (x ExperianRating) VDLWrite(enc vdl.Encoder) error {
	if err := enc.WriteValueString(__VDLType_enum_3, x.String()); err != nil {
		return err
	}
	return nil
}

func (x *ExperianRating) VDLRead(dec vdl.Decoder) error {
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		if err := x.Set(value); err != nil {
			return err
		}
	}
	return nil
}

type RatingsArray [4]int16

func (RatingsArray) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.RatingsArray"`
}) {
}

func (x RatingsArray) VDLIsZero() bool {
	return x == RatingsArray{}
}

func (x RatingsArray) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_array_4); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntryValueInt(vdl.Int16Type, int64(elem)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *RatingsArray) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(__VDLType_array_4); err != nil {
		return err
	}
	for index := 0; index < 4; index++ {
		switch done, elem, err := dec.NextEntryValueInt(16); {
		case err != nil:
			return err
		case done:
			return fmt.Errorf("short array, got len %d < 4 %T)", index, *x)
		default:
			x[index] = int16(elem)
		}
	}
	switch done, err := dec.NextEntry(); {
	case err != nil:
		return err
	case !done:
		return fmt.Errorf("long array, got len > 4 %T", *x)
	}
	return dec.FinishValue()
}

type EquifaxCreditReport struct {
	Rating           byte
	FourScoreRatings RatingsArray
}

func (EquifaxCreditReport) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.EquifaxCreditReport"`
}) {
}

func (x EquifaxCreditReport) VDLIsZero() bool {
	return x == EquifaxCreditReport{}
}

func (x EquifaxCreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_5); err != nil {
		return err
	}
	if x.Rating != 0 {
		if err := enc.NextFieldValueUint(0, vdl.ByteType, uint64(x.Rating)); err != nil {
			return err
		}
	}
	if x.FourScoreRatings != (RatingsArray{}) {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := x.FourScoreRatings.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *EquifaxCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = EquifaxCreditReport{}
	if err := dec.StartValue(__VDLType_struct_5); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_5 {
			index = __VDLType_struct_5.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueUint(8); {
			case err != nil:
				return err
			default:
				x.Rating = byte(value)
			}
		case 1:
			if err := x.FourScoreRatings.VDLRead(dec); err != nil {
				return err
			}
		}
	}
}

type Tdh int

const (
	TdhTom Tdh = iota
	TdhDick
	TdhHarry
)

// TdhAll holds all labels for Tdh.
var TdhAll = [...]Tdh{TdhTom, TdhDick, TdhHarry}

// TdhFromString creates a Tdh from a string label.
func TdhFromString(label string) (x Tdh, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *Tdh) Set(label string) error {
	switch label {
	case "Tom", "tom":
		*x = TdhTom
		return nil
	case "Dick", "dick":
		*x = TdhDick
		return nil
	case "Harry", "harry":
		*x = TdhHarry
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.Tdh", label)
}

// String returns the string label of x.
func (x Tdh) String() string {
	switch x {
	case TdhTom:
		return "Tom"
	case TdhDick:
		return "Dick"
	case TdhHarry:
		return "Harry"
	}
	return ""
}

func (Tdh) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Tdh"`
	Enum struct{ Tom, Dick, Harry string }
}) {
}

func (x Tdh) VDLIsZero() bool {
	return x == TdhTom
}

func (x Tdh) VDLWrite(enc vdl.Encoder) error {
	if err := enc.WriteValueString(__VDLType_enum_6, x.String()); err != nil {
		return err
	}
	return nil
}

func (x *Tdh) VDLRead(dec vdl.Decoder) error {
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		if err := x.Set(value); err != nil {
			return err
		}
	}
	return nil
}

type ExperianCreditReport struct {
	Rating       ExperianRating
	TdhApprovals map[Tdh]struct{}
	Auditor      Tdh
}

func (ExperianCreditReport) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ExperianCreditReport"`
}) {
}

func (x ExperianCreditReport) VDLIsZero() bool {
	if x.Rating != ExperianRatingGood {
		return false
	}
	if len(x.TdhApprovals) != 0 {
		return false
	}
	if x.Auditor != TdhTom {
		return false
	}
	return true
}

func (x ExperianCreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_7); err != nil {
		return err
	}
	if x.Rating != ExperianRatingGood {
		if err := enc.NextFieldValueString(0, __VDLType_enum_3, x.Rating.String()); err != nil {
			return err
		}
	}
	if len(x.TdhApprovals) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_1(enc, x.TdhApprovals); err != nil {
			return err
		}
	}
	if x.Auditor != TdhTom {
		if err := enc.NextFieldValueString(2, __VDLType_enum_6, x.Auditor.String()); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_1(enc vdl.Encoder, x map[Tdh]struct{}) error {
	if err := enc.StartValue(__VDLType_set_8); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueString(__VDLType_enum_6, key.String()); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ExperianCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = ExperianCreditReport{}
	if err := dec.StartValue(__VDLType_struct_7); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_7 {
			index = __VDLType_struct_7.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				if err := x.Rating.Set(value); err != nil {
					return err
				}
			}
		case 1:
			if err := __VDLReadAnon_set_1(dec, &x.TdhApprovals); err != nil {
				return err
			}
		case 2:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				if err := x.Auditor.Set(value); err != nil {
					return err
				}
			}
		}
	}
}

func __VDLReadAnon_set_1(dec vdl.Decoder, x *map[Tdh]struct{}) error {
	if err := dec.StartValue(__VDLType_set_8); err != nil {
		return err
	}
	var tmpMap map[Tdh]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[Tdh]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var keyEnum Tdh
			if err := keyEnum.Set(key); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[Tdh]struct{})
			}
			tmpMap[keyEnum] = struct{}{}
		}
	}
}

type TransUnionCreditReport struct {
	Rating          int16
	PreviousRatings map[string]int16
}

func (TransUnionCreditReport) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.TransUnionCreditReport"`
}) {
}

func (x TransUnionCreditReport) VDLIsZero() bool {
	if x.Rating != 0 {
		return false
	}
	if len(x.PreviousRatings) != 0 {
		return false
	}
	return true
}

func (x TransUnionCreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_9); err != nil {
		return err
	}
	if x.Rating != 0 {
		if err := enc.NextFieldValueInt(0, vdl.Int16Type, int64(x.Rating)); err != nil {
			return err
		}
	}
	if len(x.PreviousRatings) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_2(enc, x.PreviousRatings); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_2(enc vdl.Encoder, x map[string]int16) error {
	if err := enc.StartValue(__VDLType_map_10); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
		if err := enc.WriteValueInt(vdl.Int16Type, int64(elem)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *TransUnionCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = TransUnionCreditReport{}
	if err := dec.StartValue(__VDLType_struct_9); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_9 {
			index = __VDLType_struct_9.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueInt(16); {
			case err != nil:
				return err
			default:
				x.Rating = int16(value)
			}
		case 1:
			if err := __VDLReadAnon_map_2(dec, &x.PreviousRatings); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_2(dec vdl.Decoder, x *map[string]int16) error {
	if err := dec.StartValue(__VDLType_map_10); err != nil {
		return err
	}
	var tmpMap map[string]int16
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]int16, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem int16
			switch value, err := dec.ReadValueInt(16); {
			case err != nil:
				return err
			default:
				elem = int16(value)
			}
			if tmpMap == nil {
				tmpMap = make(map[string]int16)
			}
			tmpMap[key] = elem
		}
	}
}

type (
	// AgencyReport represents any single field of the AgencyReport union type.
	AgencyReport interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// VDLReflect describes the AgencyReport union type.
		VDLReflect(__AgencyReportReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// AgencyReportEquifaxReport represents field EquifaxReport of the AgencyReport union type.
	AgencyReportEquifaxReport struct{ Value EquifaxCreditReport }
	// AgencyReportExperianReport represents field ExperianReport of the AgencyReport union type.
	AgencyReportExperianReport struct{ Value ExperianCreditReport }
	// AgencyReportTransUnionReport represents field TransUnionReport of the AgencyReport union type.
	AgencyReportTransUnionReport struct{ Value TransUnionCreditReport }
	// __AgencyReportReflect describes the AgencyReport union type.
	__AgencyReportReflect struct {
		Name  string `vdl:"v.io/v23/query/engine/internal/testdata.AgencyReport"`
		Type  AgencyReport
		Union struct {
			EquifaxReport    AgencyReportEquifaxReport
			ExperianReport   AgencyReportExperianReport
			TransUnionReport AgencyReportTransUnionReport
		}
	}
)

func (x AgencyReportEquifaxReport) Index() int                       { return 0 }
func (x AgencyReportEquifaxReport) Interface() interface{}           { return x.Value }
func (x AgencyReportEquifaxReport) Name() string                     { return "EquifaxReport" }
func (x AgencyReportEquifaxReport) VDLReflect(__AgencyReportReflect) {}

func (x AgencyReportExperianReport) Index() int                       { return 1 }
func (x AgencyReportExperianReport) Interface() interface{}           { return x.Value }
func (x AgencyReportExperianReport) Name() string                     { return "ExperianReport" }
func (x AgencyReportExperianReport) VDLReflect(__AgencyReportReflect) {}

func (x AgencyReportTransUnionReport) Index() int                       { return 2 }
func (x AgencyReportTransUnionReport) Interface() interface{}           { return x.Value }
func (x AgencyReportTransUnionReport) Name() string                     { return "TransUnionReport" }
func (x AgencyReportTransUnionReport) VDLReflect(__AgencyReportReflect) {}

func (x AgencyReportEquifaxReport) VDLIsZero() bool {
	return x.Value == EquifaxCreditReport{}
}

func (x AgencyReportExperianReport) VDLIsZero() bool {
	return false
}

func (x AgencyReportTransUnionReport) VDLIsZero() bool {
	return false
}

func (x AgencyReportEquifaxReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_union_11); err != nil {
		return err
	}
	if err := enc.NextField(0); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x AgencyReportExperianReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_union_11); err != nil {
		return err
	}
	if err := enc.NextField(1); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x AgencyReportTransUnionReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_union_11); err != nil {
		return err
	}
	if err := enc.NextField(2); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadAgencyReport(dec vdl.Decoder, x *AgencyReport) error {
	if err := dec.StartValue(__VDLType_union_11); err != nil {
		return err
	}
	decType := dec.Type()
	index, err := dec.NextField()
	switch {
	case err != nil:
		return err
	case index == -1:
		return fmt.Errorf("missing field in union %T, from %v", x, decType)
	}
	if decType != __VDLType_union_11 {
		name := decType.Field(index).Name
		index = __VDLType_union_11.FieldIndexByName(name)
		if index == -1 {
			return fmt.Errorf("field %q not in union %T, from %v", name, x, decType)
		}
	}
	switch index {
	case 0:
		var field AgencyReportEquifaxReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 1:
		var field AgencyReportExperianReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 2:
		var field AgencyReportTransUnionReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	}
	switch index, err := dec.NextField(); {
	case err != nil:
		return err
	case index != -1:
		return fmt.Errorf("extra field %d in union %T, from %v", index, x, dec.Type())
	}
	return dec.FinishValue()
}

type CreditReport struct {
	Agency CreditAgency
	Report AgencyReport
}

func (CreditReport) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.CreditReport"`
}) {
}

func (x CreditReport) VDLIsZero() bool {
	if x.Agency != CreditAgencyEquifax {
		return false
	}
	if x.Report != nil && !x.Report.VDLIsZero() {
		return false
	}
	return true
}

func (x CreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_12); err != nil {
		return err
	}
	if x.Agency != CreditAgencyEquifax {
		if err := enc.NextFieldValueString(0, __VDLType_enum_2, x.Agency.String()); err != nil {
			return err
		}
	}
	if x.Report != nil && !x.Report.VDLIsZero() {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := x.Report.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *CreditReport) VDLRead(dec vdl.Decoder) error {
	*x = CreditReport{
		Report: AgencyReportEquifaxReport{},
	}
	if err := dec.StartValue(__VDLType_struct_12); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_12 {
			index = __VDLType_struct_12.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				if err := x.Agency.Set(value); err != nil {
					return err
				}
			}
		case 1:
			if err := VDLReadAgencyReport(dec, &x.Report); err != nil {
				return err
			}
		}
	}
}

type Customer struct {
	Name              string
	Id                int64
	Active            bool
	Address           AddressInfo
	PreviousAddresses []AddressInfo
	Credit            CreditReport
}

func (Customer) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Customer"`
}) {
}

func (x Customer) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if x.Id != 0 {
		return false
	}
	if x.Active {
		return false
	}
	if x.Address != (AddressInfo{}) {
		return false
	}
	if len(x.PreviousAddresses) != 0 {
		return false
	}
	if !x.Credit.VDLIsZero() {
		return false
	}
	return true
}

func (x Customer) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_13); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if x.Id != 0 {
		if err := enc.NextFieldValueInt(1, vdl.Int64Type, x.Id); err != nil {
			return err
		}
	}
	if x.Active {
		if err := enc.NextFieldValueBool(2, vdl.BoolType, x.Active); err != nil {
			return err
		}
	}
	if x.Address != (AddressInfo{}) {
		if err := enc.NextField(3); err != nil {
			return err
		}
		if err := x.Address.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.PreviousAddresses) != 0 {
		if err := enc.NextField(4); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_3(enc, x.PreviousAddresses); err != nil {
			return err
		}
	}
	if !x.Credit.VDLIsZero() {
		if err := enc.NextField(5); err != nil {
			return err
		}
		if err := x.Credit.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_3(enc vdl.Encoder, x []AddressInfo) error {
	if err := enc.StartValue(__VDLType_list_14); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Customer) VDLRead(dec vdl.Decoder) error {
	*x = Customer{
		Credit: CreditReport{
			Report: AgencyReportEquifaxReport{},
		},
	}
	if err := dec.StartValue(__VDLType_struct_13); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_13 {
			index = __VDLType_struct_13.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.Id = value
			}
		case 2:
			switch value, err := dec.ReadValueBool(); {
			case err != nil:
				return err
			default:
				x.Active = value
			}
		case 3:
			if err := x.Address.VDLRead(dec); err != nil {
				return err
			}
		case 4:
			if err := __VDLReadAnon_list_3(dec, &x.PreviousAddresses); err != nil {
				return err
			}
		case 5:
			if err := x.Credit.VDLRead(dec); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_3(dec vdl.Decoder, x *[]AddressInfo) error {
	if err := dec.StartValue(__VDLType_list_14); err != nil {
		return err
	}
	if len := dec.LenHint(); len > 0 {
		*x = make([]AddressInfo, 0, len)
	} else {
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		default:
			var elem AddressInfo
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
			*x = append(*x, elem)
		}
	}
}

type Invoice struct {
	CustId      int64
	InvoiceNum  int64
	InvoiceDate time.Time
	Amount      int64
	ShipTo      AddressInfo
}

func (Invoice) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Invoice"`
}) {
}

func (x Invoice) VDLIsZero() bool {
	if x.CustId != 0 {
		return false
	}
	if x.InvoiceNum != 0 {
		return false
	}
	if !x.InvoiceDate.IsZero() {
		return false
	}
	if x.Amount != 0 {
		return false
	}
	if x.ShipTo != (AddressInfo{}) {
		return false
	}
	return true
}

func (x Invoice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_15); err != nil {
		return err
	}
	if x.CustId != 0 {
		if err := enc.NextFieldValueInt(0, vdl.Int64Type, x.CustId); err != nil {
			return err
		}
	}
	if x.InvoiceNum != 0 {
		if err := enc.NextFieldValueInt(1, vdl.Int64Type, x.InvoiceNum); err != nil {
			return err
		}
	}
	if !x.InvoiceDate.IsZero() {
		if err := enc.NextField(2); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, x.InvoiceDate); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Amount != 0 {
		if err := enc.NextFieldValueInt(3, vdl.Int64Type, x.Amount); err != nil {
			return err
		}
	}
	if x.ShipTo != (AddressInfo{}) {
		if err := enc.NextField(4); err != nil {
			return err
		}
		if err := x.ShipTo.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Invoice) VDLRead(dec vdl.Decoder) error {
	*x = Invoice{}
	if err := dec.StartValue(__VDLType_struct_15); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_15 {
			index = __VDLType_struct_15.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.CustId = value
			}
		case 1:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.InvoiceNum = value
			}
		case 2:
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &x.InvoiceDate); err != nil {
				return err
			}
		case 3:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.Amount = value
			}
		case 4:
			if err := x.ShipTo.VDLRead(dec); err != nil {
				return err
			}
		}
	}
}

type Numbers struct {
	B    byte
	Ui16 uint16
	Ui32 uint32
	Ui64 uint64
	I16  int16
	I32  int32
	I64  int64
	F32  float32
	F64  float64
}

func (Numbers) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Numbers"`
}) {
}

func (x Numbers) VDLIsZero() bool {
	return x == Numbers{}
}

func (x Numbers) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_17); err != nil {
		return err
	}
	if x.B != 0 {
		if err := enc.NextFieldValueUint(0, vdl.ByteType, uint64(x.B)); err != nil {
			return err
		}
	}
	if x.Ui16 != 0 {
		if err := enc.NextFieldValueUint(1, vdl.Uint16Type, uint64(x.Ui16)); err != nil {
			return err
		}
	}
	if x.Ui32 != 0 {
		if err := enc.NextFieldValueUint(2, vdl.Uint32Type, uint64(x.Ui32)); err != nil {
			return err
		}
	}
	if x.Ui64 != 0 {
		if err := enc.NextFieldValueUint(3, vdl.Uint64Type, x.Ui64); err != nil {
			return err
		}
	}
	if x.I16 != 0 {
		if err := enc.NextFieldValueInt(4, vdl.Int16Type, int64(x.I16)); err != nil {
			return err
		}
	}
	if x.I32 != 0 {
		if err := enc.NextFieldValueInt(5, vdl.Int32Type, int64(x.I32)); err != nil {
			return err
		}
	}
	if x.I64 != 0 {
		if err := enc.NextFieldValueInt(6, vdl.Int64Type, x.I64); err != nil {
			return err
		}
	}
	if x.F32 != 0 {
		if err := enc.NextFieldValueFloat(7, vdl.Float32Type, float64(x.F32)); err != nil {
			return err
		}
	}
	if x.F64 != 0 {
		if err := enc.NextFieldValueFloat(8, vdl.Float64Type, x.F64); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Numbers) VDLRead(dec vdl.Decoder) error {
	*x = Numbers{}
	if err := dec.StartValue(__VDLType_struct_17); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_17 {
			index = __VDLType_struct_17.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueUint(8); {
			case err != nil:
				return err
			default:
				x.B = byte(value)
			}
		case 1:
			switch value, err := dec.ReadValueUint(16); {
			case err != nil:
				return err
			default:
				x.Ui16 = uint16(value)
			}
		case 2:
			switch value, err := dec.ReadValueUint(32); {
			case err != nil:
				return err
			default:
				x.Ui32 = uint32(value)
			}
		case 3:
			switch value, err := dec.ReadValueUint(64); {
			case err != nil:
				return err
			default:
				x.Ui64 = value
			}
		case 4:
			switch value, err := dec.ReadValueInt(16); {
			case err != nil:
				return err
			default:
				x.I16 = int16(value)
			}
		case 5:
			switch value, err := dec.ReadValueInt(32); {
			case err != nil:
				return err
			default:
				x.I32 = int32(value)
			}
		case 6:
			switch value, err := dec.ReadValueInt(64); {
			case err != nil:
				return err
			default:
				x.I64 = value
			}
		case 7:
			switch value, err := dec.ReadValueFloat(32); {
			case err != nil:
				return err
			default:
				x.F32 = float32(value)
			}
		case 8:
			switch value, err := dec.ReadValueFloat(64); {
			case err != nil:
				return err
			default:
				x.F64 = value
			}
		}
	}
}

type (
	// TitleOrValueType represents any single field of the TitleOrValueType union type.
	TitleOrValueType interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// VDLReflect describes the TitleOrValueType union type.
		VDLReflect(__TitleOrValueTypeReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// TitleOrValueTypeTitle represents field Title of the TitleOrValueType union type.
	TitleOrValueTypeTitle struct{ Value string }
	// TitleOrValueTypeValue represents field Value of the TitleOrValueType union type.
	TitleOrValueTypeValue struct{ Value int64 }
	// __TitleOrValueTypeReflect describes the TitleOrValueType union type.
	__TitleOrValueTypeReflect struct {
		Name  string `vdl:"v.io/v23/query/engine/internal/testdata.TitleOrValueType"`
		Type  TitleOrValueType
		Union struct {
			Title TitleOrValueTypeTitle
			Value TitleOrValueTypeValue
		}
	}
)

func (x TitleOrValueTypeTitle) Index() int                           { return 0 }
func (x TitleOrValueTypeTitle) Interface() interface{}               { return x.Value }
func (x TitleOrValueTypeTitle) Name() string                         { return "Title" }
func (x TitleOrValueTypeTitle) VDLReflect(__TitleOrValueTypeReflect) {}

func (x TitleOrValueTypeValue) Index() int                           { return 1 }
func (x TitleOrValueTypeValue) Interface() interface{}               { return x.Value }
func (x TitleOrValueTypeValue) Name() string                         { return "Value" }
func (x TitleOrValueTypeValue) VDLReflect(__TitleOrValueTypeReflect) {}

func (x TitleOrValueTypeTitle) VDLIsZero() bool {
	return x.Value == ""
}

func (x TitleOrValueTypeValue) VDLIsZero() bool {
	return false
}

func (x TitleOrValueTypeTitle) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_union_18); err != nil {
		return err
	}
	if err := enc.NextFieldValueString(0, vdl.StringType, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x TitleOrValueTypeValue) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_union_18); err != nil {
		return err
	}
	if err := enc.NextFieldValueInt(1, vdl.Int64Type, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadTitleOrValueType(dec vdl.Decoder, x *TitleOrValueType) error {
	if err := dec.StartValue(__VDLType_union_18); err != nil {
		return err
	}
	decType := dec.Type()
	index, err := dec.NextField()
	switch {
	case err != nil:
		return err
	case index == -1:
		return fmt.Errorf("missing field in union %T, from %v", x, decType)
	}
	if decType != __VDLType_union_18 {
		name := decType.Field(index).Name
		index = __VDLType_union_18.FieldIndexByName(name)
		if index == -1 {
			return fmt.Errorf("field %q not in union %T, from %v", name, x, decType)
		}
	}
	switch index {
	case 0:
		var field TitleOrValueTypeTitle
		switch value, err := dec.ReadValueString(); {
		case err != nil:
			return err
		default:
			field.Value = value
		}
		*x = field
	case 1:
		var field TitleOrValueTypeValue
		switch value, err := dec.ReadValueInt(64); {
		case err != nil:
			return err
		default:
			field.Value = value
		}
		*x = field
	}
	switch index, err := dec.NextField(); {
	case err != nil:
		return err
	case index != -1:
		return fmt.Errorf("extra field %d in union %T, from %v", index, x, dec.Type())
	}
	return dec.FinishValue()
}

type BazType struct {
	Name         string
	TitleOrValue TitleOrValueType
}

func (BazType) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BazType"`
}) {
}

func (x BazType) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if x.TitleOrValue != nil && !x.TitleOrValue.VDLIsZero() {
		return false
	}
	return true
}

func (x BazType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_19); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Name); err != nil {
			return err
		}
	}
	if x.TitleOrValue != nil && !x.TitleOrValue.VDLIsZero() {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := x.TitleOrValue.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BazType) VDLRead(dec vdl.Decoder) error {
	*x = BazType{
		TitleOrValue: TitleOrValueTypeTitle{},
	}
	if err := dec.StartValue(__VDLType_struct_19); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_19 {
			index = __VDLType_struct_19.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Name = value
			}
		case 1:
			if err := VDLReadTitleOrValueType(dec, &x.TitleOrValue); err != nil {
				return err
			}
		}
	}
}

type BarType struct {
	Baz BazType
}

func (BarType) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BarType"`
}) {
}

func (x BarType) VDLIsZero() bool {
	if !x.Baz.VDLIsZero() {
		return false
	}
	return true
}

func (x BarType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_20); err != nil {
		return err
	}
	if !x.Baz.VDLIsZero() {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := x.Baz.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BarType) VDLRead(dec vdl.Decoder) error {
	*x = BarType{
		Baz: BazType{
			TitleOrValue: TitleOrValueTypeTitle{},
		},
	}
	if err := dec.StartValue(__VDLType_struct_20); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_20 {
			index = __VDLType_struct_20.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			if err := x.Baz.VDLRead(dec); err != nil {
				return err
			}
		}
	}
}

type FooType struct {
	Bar BarType
}

func (FooType) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FooType"`
}) {
}

func (x FooType) VDLIsZero() bool {
	if !x.Bar.VDLIsZero() {
		return false
	}
	return true
}

func (x FooType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_21); err != nil {
		return err
	}
	if !x.Bar.VDLIsZero() {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := x.Bar.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FooType) VDLRead(dec vdl.Decoder) error {
	*x = FooType{
		Bar: BarType{
			Baz: BazType{
				TitleOrValue: TitleOrValueTypeTitle{},
			},
		},
	}
	if err := dec.StartValue(__VDLType_struct_21); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_21 {
			index = __VDLType_struct_21.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			if err := x.Bar.VDLRead(dec); err != nil {
				return err
			}
		}
	}
}

type K struct {
	A byte
	B string
}

func (K) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.K"`
}) {
}

func (x K) VDLIsZero() bool {
	return x == K{}
}

func (x K) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_22); err != nil {
		return err
	}
	if x.A != 0 {
		if err := enc.NextFieldValueUint(0, vdl.ByteType, uint64(x.A)); err != nil {
			return err
		}
	}
	if x.B != "" {
		if err := enc.NextFieldValueString(1, vdl.StringType, x.B); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *K) VDLRead(dec vdl.Decoder) error {
	*x = K{}
	if err := dec.StartValue(__VDLType_struct_22); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_22 {
			index = __VDLType_struct_22.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueUint(8); {
			case err != nil:
				return err
			default:
				x.A = byte(value)
			}
		case 1:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.B = value
			}
		}
	}
}

type V struct {
	A string
	B float32
}

func (V) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.V"`
}) {
}

func (x V) VDLIsZero() bool {
	return x == V{}
}

func (x V) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_23); err != nil {
		return err
	}
	if x.A != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.A); err != nil {
			return err
		}
	}
	if x.B != 0 {
		if err := enc.NextFieldValueFloat(1, vdl.Float32Type, float64(x.B)); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *V) VDLRead(dec vdl.Decoder) error {
	*x = V{}
	if err := dec.StartValue(__VDLType_struct_23); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_23 {
			index = __VDLType_struct_23.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.A = value
			}
		case 1:
			switch value, err := dec.ReadValueFloat(32); {
			case err != nil:
				return err
			default:
				x.B = float32(value)
			}
		}
	}
}

type FunWithMaps struct {
	Key       K
	Map       map[K]V
	Confusing map[int16][]map[string]struct{}
}

func (FunWithMaps) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FunWithMaps"`
}) {
}

func (x FunWithMaps) VDLIsZero() bool {
	if x.Key != (K{}) {
		return false
	}
	if len(x.Map) != 0 {
		return false
	}
	if len(x.Confusing) != 0 {
		return false
	}
	return true
}

func (x FunWithMaps) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_24); err != nil {
		return err
	}
	if x.Key != (K{}) {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := x.Key.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.Map) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_4(enc, x.Map); err != nil {
			return err
		}
	}
	if len(x.Confusing) != 0 {
		if err := enc.NextField(2); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_5(enc, x.Confusing); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_4(enc vdl.Encoder, x map[K]V) error {
	if err := enc.StartValue(__VDLType_map_25); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_5(enc vdl.Encoder, x map[int16][]map[string]struct{}) error {
	if err := enc.StartValue(__VDLType_map_26); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueInt(vdl.Int16Type, int64(key)); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_6(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_6(enc vdl.Encoder, x []map[string]struct{}) error {
	if err := enc.StartValue(__VDLType_list_27); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for _, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_7(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_7(enc vdl.Encoder, x map[string]struct{}) error {
	if err := enc.StartValue(__VDLType_set_28); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FunWithMaps) VDLRead(dec vdl.Decoder) error {
	*x = FunWithMaps{}
	if err := dec.StartValue(__VDLType_struct_24); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_24 {
			index = __VDLType_struct_24.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			if err := x.Key.VDLRead(dec); err != nil {
				return err
			}
		case 1:
			if err := __VDLReadAnon_map_4(dec, &x.Map); err != nil {
				return err
			}
		case 2:
			if err := __VDLReadAnon_map_5(dec, &x.Confusing); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_4(dec vdl.Decoder, x *map[K]V) error {
	if err := dec.StartValue(__VDLType_map_25); err != nil {
		return err
	}
	var tmpMap map[K]V
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[K]V, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var key K
			if err := key.VDLRead(dec); err != nil {
				return err
			}
			var elem V
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[K]V)
			}
			tmpMap[key] = elem
		}
	}
}

func __VDLReadAnon_map_5(dec vdl.Decoder, x *map[int16][]map[string]struct{}) error {
	if err := dec.StartValue(__VDLType_map_26); err != nil {
		return err
	}
	var tmpMap map[int16][]map[string]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int16][]map[string]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(16); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem []map[string]struct{}
			if err := __VDLReadAnon_list_6(dec, &elem); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[int16][]map[string]struct{})
			}
			tmpMap[int16(key)] = elem
		}
	}
}

func __VDLReadAnon_list_6(dec vdl.Decoder, x *[]map[string]struct{}) error {
	if err := dec.StartValue(__VDLType_list_27); err != nil {
		return err
	}
	if len := dec.LenHint(); len > 0 {
		*x = make([]map[string]struct{}, 0, len)
	} else {
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		default:
			var elem map[string]struct{}
			if err := __VDLReadAnon_set_7(dec, &elem); err != nil {
				return err
			}
			*x = append(*x, elem)
		}
	}
}

func __VDLReadAnon_set_7(dec vdl.Decoder, x *map[string]struct{}) error {
	if err := dec.StartValue(__VDLType_set_28); err != nil {
		return err
	}
	var tmpMap map[string]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[string]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

type FunWithTypes struct {
	T1 *vdl.Type
	T2 *vdl.Type
}

func (FunWithTypes) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FunWithTypes"`
}) {
}

func (x FunWithTypes) VDLIsZero() bool {
	if x.T1 != nil && x.T1 != vdl.AnyType {
		return false
	}
	if x.T2 != nil && x.T2 != vdl.AnyType {
		return false
	}
	return true
}

func (x FunWithTypes) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_29); err != nil {
		return err
	}
	if x.T1 != nil && x.T1 != vdl.AnyType {
		if err := enc.NextFieldValueTypeObject(0, x.T1); err != nil {
			return err
		}
	}
	if x.T2 != nil && x.T2 != vdl.AnyType {
		if err := enc.NextFieldValueTypeObject(1, x.T2); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FunWithTypes) VDLRead(dec vdl.Decoder) error {
	*x = FunWithTypes{
		T1: vdl.AnyType,
		T2: vdl.AnyType,
	}
	if err := dec.StartValue(__VDLType_struct_29); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_29 {
			index = __VDLType_struct_29.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueTypeObject(); {
			case err != nil:
				return err
			default:
				x.T1 = value
			}
		case 1:
			switch value, err := dec.ReadValueTypeObject(); {
			case err != nil:
				return err
			default:
				x.T2 = value
			}
		}
	}
}

type ManyMaps struct {
	B   map[bool]string
	By  map[byte]string
	U16 map[uint16]string
	U32 map[uint32]string
	U64 map[uint64]string
	I16 map[int16]string
	I32 map[int32]string
	I64 map[int64]string
	F32 map[float32]string
	F64 map[float64]string
	S   map[string]string
	Ms  map[string]map[string]string
	T   map[time.Time]string
}

func (ManyMaps) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ManyMaps"`
}) {
}

func (x ManyMaps) VDLIsZero() bool {
	if len(x.B) != 0 {
		return false
	}
	if len(x.By) != 0 {
		return false
	}
	if len(x.U16) != 0 {
		return false
	}
	if len(x.U32) != 0 {
		return false
	}
	if len(x.U64) != 0 {
		return false
	}
	if len(x.I16) != 0 {
		return false
	}
	if len(x.I32) != 0 {
		return false
	}
	if len(x.I64) != 0 {
		return false
	}
	if len(x.F32) != 0 {
		return false
	}
	if len(x.F64) != 0 {
		return false
	}
	if len(x.S) != 0 {
		return false
	}
	if len(x.Ms) != 0 {
		return false
	}
	if len(x.T) != 0 {
		return false
	}
	return true
}

func (x ManyMaps) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_30); err != nil {
		return err
	}
	if len(x.B) != 0 {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_8(enc, x.B); err != nil {
			return err
		}
	}
	if len(x.By) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_9(enc, x.By); err != nil {
			return err
		}
	}
	if len(x.U16) != 0 {
		if err := enc.NextField(2); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_10(enc, x.U16); err != nil {
			return err
		}
	}
	if len(x.U32) != 0 {
		if err := enc.NextField(3); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_11(enc, x.U32); err != nil {
			return err
		}
	}
	if len(x.U64) != 0 {
		if err := enc.NextField(4); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_12(enc, x.U64); err != nil {
			return err
		}
	}
	if len(x.I16) != 0 {
		if err := enc.NextField(5); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_13(enc, x.I16); err != nil {
			return err
		}
	}
	if len(x.I32) != 0 {
		if err := enc.NextField(6); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_14(enc, x.I32); err != nil {
			return err
		}
	}
	if len(x.I64) != 0 {
		if err := enc.NextField(7); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_15(enc, x.I64); err != nil {
			return err
		}
	}
	if len(x.F32) != 0 {
		if err := enc.NextField(8); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_16(enc, x.F32); err != nil {
			return err
		}
	}
	if len(x.F64) != 0 {
		if err := enc.NextField(9); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_17(enc, x.F64); err != nil {
			return err
		}
	}
	if len(x.S) != 0 {
		if err := enc.NextField(10); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_18(enc, x.S); err != nil {
			return err
		}
	}
	if len(x.Ms) != 0 {
		if err := enc.NextField(11); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_19(enc, x.Ms); err != nil {
			return err
		}
	}
	if len(x.T) != 0 {
		if err := enc.NextField(12); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_20(enc, x.T); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_8(enc vdl.Encoder, x map[bool]string) error {
	if err := enc.StartValue(__VDLType_map_31); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueBool(vdl.BoolType, key); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_9(enc vdl.Encoder, x map[byte]string) error {
	if err := enc.StartValue(__VDLType_map_32); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueUint(vdl.ByteType, uint64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_10(enc vdl.Encoder, x map[uint16]string) error {
	if err := enc.StartValue(__VDLType_map_33); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueUint(vdl.Uint16Type, uint64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_11(enc vdl.Encoder, x map[uint32]string) error {
	if err := enc.StartValue(__VDLType_map_34); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueUint(vdl.Uint32Type, uint64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_12(enc vdl.Encoder, x map[uint64]string) error {
	if err := enc.StartValue(__VDLType_map_35); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueUint(vdl.Uint64Type, key); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_13(enc vdl.Encoder, x map[int16]string) error {
	if err := enc.StartValue(__VDLType_map_36); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueInt(vdl.Int16Type, int64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_14(enc vdl.Encoder, x map[int32]string) error {
	if err := enc.StartValue(__VDLType_map_37); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueInt(vdl.Int32Type, int64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_15(enc vdl.Encoder, x map[int64]string) error {
	if err := enc.StartValue(__VDLType_map_38); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueInt(vdl.Int64Type, key); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_16(enc vdl.Encoder, x map[float32]string) error {
	if err := enc.StartValue(__VDLType_map_39); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueFloat(vdl.Float32Type, float64(key)); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_17(enc vdl.Encoder, x map[float64]string) error {
	if err := enc.StartValue(__VDLType_map_40); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueFloat(vdl.Float64Type, key); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_18(enc vdl.Encoder, x map[string]string) error {
	if err := enc.StartValue(__VDLType_map_41); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_19(enc vdl.Encoder, x map[string]map[string]string) error {
	if err := enc.StartValue(__VDLType_map_42); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_18(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_20(enc vdl.Encoder, x map[time.Time]string) error {
	if err := enc.StartValue(__VDLType_map_43); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, key); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ManyMaps) VDLRead(dec vdl.Decoder) error {
	*x = ManyMaps{}
	if err := dec.StartValue(__VDLType_struct_30); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_30 {
			index = __VDLType_struct_30.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			if err := __VDLReadAnon_map_8(dec, &x.B); err != nil {
				return err
			}
		case 1:
			if err := __VDLReadAnon_map_9(dec, &x.By); err != nil {
				return err
			}
		case 2:
			if err := __VDLReadAnon_map_10(dec, &x.U16); err != nil {
				return err
			}
		case 3:
			if err := __VDLReadAnon_map_11(dec, &x.U32); err != nil {
				return err
			}
		case 4:
			if err := __VDLReadAnon_map_12(dec, &x.U64); err != nil {
				return err
			}
		case 5:
			if err := __VDLReadAnon_map_13(dec, &x.I16); err != nil {
				return err
			}
		case 6:
			if err := __VDLReadAnon_map_14(dec, &x.I32); err != nil {
				return err
			}
		case 7:
			if err := __VDLReadAnon_map_15(dec, &x.I64); err != nil {
				return err
			}
		case 8:
			if err := __VDLReadAnon_map_16(dec, &x.F32); err != nil {
				return err
			}
		case 9:
			if err := __VDLReadAnon_map_17(dec, &x.F64); err != nil {
				return err
			}
		case 10:
			if err := __VDLReadAnon_map_18(dec, &x.S); err != nil {
				return err
			}
		case 11:
			if err := __VDLReadAnon_map_19(dec, &x.Ms); err != nil {
				return err
			}
		case 12:
			if err := __VDLReadAnon_map_20(dec, &x.T); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_8(dec vdl.Decoder, x *map[bool]string) error {
	if err := dec.StartValue(__VDLType_map_31); err != nil {
		return err
	}
	var tmpMap map[bool]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[bool]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueBool(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[bool]string)
			}
			tmpMap[key] = elem
		}
	}
}

func __VDLReadAnon_map_9(dec vdl.Decoder, x *map[byte]string) error {
	if err := dec.StartValue(__VDLType_map_32); err != nil {
		return err
	}
	var tmpMap map[byte]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[byte]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(8); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[byte]string)
			}
			tmpMap[byte(key)] = elem
		}
	}
}

func __VDLReadAnon_map_10(dec vdl.Decoder, x *map[uint16]string) error {
	if err := dec.StartValue(__VDLType_map_33); err != nil {
		return err
	}
	var tmpMap map[uint16]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint16]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(16); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[uint16]string)
			}
			tmpMap[uint16(key)] = elem
		}
	}
}

func __VDLReadAnon_map_11(dec vdl.Decoder, x *map[uint32]string) error {
	if err := dec.StartValue(__VDLType_map_34); err != nil {
		return err
	}
	var tmpMap map[uint32]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint32]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[uint32]string)
			}
			tmpMap[uint32(key)] = elem
		}
	}
}

func __VDLReadAnon_map_12(dec vdl.Decoder, x *map[uint64]string) error {
	if err := dec.StartValue(__VDLType_map_35); err != nil {
		return err
	}
	var tmpMap map[uint64]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint64]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[uint64]string)
			}
			tmpMap[key] = elem
		}
	}
}

func __VDLReadAnon_map_13(dec vdl.Decoder, x *map[int16]string) error {
	if err := dec.StartValue(__VDLType_map_36); err != nil {
		return err
	}
	var tmpMap map[int16]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int16]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(16); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[int16]string)
			}
			tmpMap[int16(key)] = elem
		}
	}
}

func __VDLReadAnon_map_14(dec vdl.Decoder, x *map[int32]string) error {
	if err := dec.StartValue(__VDLType_map_37); err != nil {
		return err
	}
	var tmpMap map[int32]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int32]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[int32]string)
			}
			tmpMap[int32(key)] = elem
		}
	}
}

func __VDLReadAnon_map_15(dec vdl.Decoder, x *map[int64]string) error {
	if err := dec.StartValue(__VDLType_map_38); err != nil {
		return err
	}
	var tmpMap map[int64]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int64]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[int64]string)
			}
			tmpMap[key] = elem
		}
	}
}

func __VDLReadAnon_map_16(dec vdl.Decoder, x *map[float32]string) error {
	if err := dec.StartValue(__VDLType_map_39); err != nil {
		return err
	}
	var tmpMap map[float32]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float32]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueFloat(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[float32]string)
			}
			tmpMap[float32(key)] = elem
		}
	}
}

func __VDLReadAnon_map_17(dec vdl.Decoder, x *map[float64]string) error {
	if err := dec.StartValue(__VDLType_map_40); err != nil {
		return err
	}
	var tmpMap map[float64]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float64]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueFloat(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[float64]string)
			}
			tmpMap[key] = elem
		}
	}
}

func __VDLReadAnon_map_18(dec vdl.Decoder, x *map[string]string) error {
	if err := dec.StartValue(__VDLType_map_41); err != nil {
		return err
	}
	var tmpMap map[string]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[string]string)
			}
			tmpMap[key] = elem
		}
	}
}

func __VDLReadAnon_map_19(dec vdl.Decoder, x *map[string]map[string]string) error {
	if err := dec.StartValue(__VDLType_map_42); err != nil {
		return err
	}
	var tmpMap map[string]map[string]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]map[string]string, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem map[string]string
			if err := __VDLReadAnon_map_18(dec, &elem); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[string]map[string]string)
			}
			tmpMap[key] = elem
		}
	}
}

func __VDLReadAnon_map_20(dec vdl.Decoder, x *map[time.Time]string) error {
	if err := dec.StartValue(__VDLType_map_43); err != nil {
		return err
	}
	var tmpMap map[time.Time]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[time.Time]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var key time.Time
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &key); err != nil {
				return err
			}
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(map[time.Time]string)
			}
			tmpMap[key] = elem
		}
	}
}

type ManySets struct {
	B   map[bool]struct{}
	By  map[byte]struct{}
	U16 map[uint16]struct{}
	U32 map[uint32]struct{}
	U64 map[uint64]struct{}
	I16 map[int16]struct{}
	I32 map[int32]struct{}
	I64 map[int64]struct{}
	F32 map[float32]struct{}
	F64 map[float64]struct{}
	S   map[string]struct{}
	T   map[time.Time]struct{}
}

func (ManySets) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ManySets"`
}) {
}

func (x ManySets) VDLIsZero() bool {
	if len(x.B) != 0 {
		return false
	}
	if len(x.By) != 0 {
		return false
	}
	if len(x.U16) != 0 {
		return false
	}
	if len(x.U32) != 0 {
		return false
	}
	if len(x.U64) != 0 {
		return false
	}
	if len(x.I16) != 0 {
		return false
	}
	if len(x.I32) != 0 {
		return false
	}
	if len(x.I64) != 0 {
		return false
	}
	if len(x.F32) != 0 {
		return false
	}
	if len(x.F64) != 0 {
		return false
	}
	if len(x.S) != 0 {
		return false
	}
	if len(x.T) != 0 {
		return false
	}
	return true
}

func (x ManySets) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_44); err != nil {
		return err
	}
	if len(x.B) != 0 {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_21(enc, x.B); err != nil {
			return err
		}
	}
	if len(x.By) != 0 {
		if err := enc.NextField(1); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_22(enc, x.By); err != nil {
			return err
		}
	}
	if len(x.U16) != 0 {
		if err := enc.NextField(2); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_23(enc, x.U16); err != nil {
			return err
		}
	}
	if len(x.U32) != 0 {
		if err := enc.NextField(3); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_24(enc, x.U32); err != nil {
			return err
		}
	}
	if len(x.U64) != 0 {
		if err := enc.NextField(4); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_25(enc, x.U64); err != nil {
			return err
		}
	}
	if len(x.I16) != 0 {
		if err := enc.NextField(5); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_26(enc, x.I16); err != nil {
			return err
		}
	}
	if len(x.I32) != 0 {
		if err := enc.NextField(6); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_27(enc, x.I32); err != nil {
			return err
		}
	}
	if len(x.I64) != 0 {
		if err := enc.NextField(7); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_28(enc, x.I64); err != nil {
			return err
		}
	}
	if len(x.F32) != 0 {
		if err := enc.NextField(8); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_29(enc, x.F32); err != nil {
			return err
		}
	}
	if len(x.F64) != 0 {
		if err := enc.NextField(9); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_30(enc, x.F64); err != nil {
			return err
		}
	}
	if len(x.S) != 0 {
		if err := enc.NextField(10); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_7(enc, x.S); err != nil {
			return err
		}
	}
	if len(x.T) != 0 {
		if err := enc.NextField(11); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_31(enc, x.T); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_21(enc vdl.Encoder, x map[bool]struct{}) error {
	if err := enc.StartValue(__VDLType_set_45); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueBool(vdl.BoolType, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_22(enc vdl.Encoder, x map[byte]struct{}) error {
	if err := enc.StartValue(__VDLType_set_46); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueUint(vdl.ByteType, uint64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_23(enc vdl.Encoder, x map[uint16]struct{}) error {
	if err := enc.StartValue(__VDLType_set_47); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueUint(vdl.Uint16Type, uint64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_24(enc vdl.Encoder, x map[uint32]struct{}) error {
	if err := enc.StartValue(__VDLType_set_48); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueUint(vdl.Uint32Type, uint64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_25(enc vdl.Encoder, x map[uint64]struct{}) error {
	if err := enc.StartValue(__VDLType_set_49); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueUint(vdl.Uint64Type, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_26(enc vdl.Encoder, x map[int16]struct{}) error {
	if err := enc.StartValue(__VDLType_set_50); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueInt(vdl.Int16Type, int64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_27(enc vdl.Encoder, x map[int32]struct{}) error {
	if err := enc.StartValue(__VDLType_set_51); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueInt(vdl.Int32Type, int64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_28(enc vdl.Encoder, x map[int64]struct{}) error {
	if err := enc.StartValue(__VDLType_set_52); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueInt(vdl.Int64Type, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_29(enc vdl.Encoder, x map[float32]struct{}) error {
	if err := enc.StartValue(__VDLType_set_53); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueFloat(vdl.Float32Type, float64(key)); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_30(enc vdl.Encoder, x map[float64]struct{}) error {
	if err := enc.StartValue(__VDLType_set_54); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueFloat(vdl.Float64Type, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_31(enc vdl.Encoder, x map[time.Time]struct{}) error {
	if err := enc.StartValue(__VDLType_set_55); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, key); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ManySets) VDLRead(dec vdl.Decoder) error {
	*x = ManySets{}
	if err := dec.StartValue(__VDLType_struct_44); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_44 {
			index = __VDLType_struct_44.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			if err := __VDLReadAnon_set_21(dec, &x.B); err != nil {
				return err
			}
		case 1:
			if err := __VDLReadAnon_set_22(dec, &x.By); err != nil {
				return err
			}
		case 2:
			if err := __VDLReadAnon_set_23(dec, &x.U16); err != nil {
				return err
			}
		case 3:
			if err := __VDLReadAnon_set_24(dec, &x.U32); err != nil {
				return err
			}
		case 4:
			if err := __VDLReadAnon_set_25(dec, &x.U64); err != nil {
				return err
			}
		case 5:
			if err := __VDLReadAnon_set_26(dec, &x.I16); err != nil {
				return err
			}
		case 6:
			if err := __VDLReadAnon_set_27(dec, &x.I32); err != nil {
				return err
			}
		case 7:
			if err := __VDLReadAnon_set_28(dec, &x.I64); err != nil {
				return err
			}
		case 8:
			if err := __VDLReadAnon_set_29(dec, &x.F32); err != nil {
				return err
			}
		case 9:
			if err := __VDLReadAnon_set_30(dec, &x.F64); err != nil {
				return err
			}
		case 10:
			if err := __VDLReadAnon_set_7(dec, &x.S); err != nil {
				return err
			}
		case 11:
			if err := __VDLReadAnon_set_31(dec, &x.T); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_set_21(dec vdl.Decoder, x *map[bool]struct{}) error {
	if err := dec.StartValue(__VDLType_set_45); err != nil {
		return err
	}
	var tmpMap map[bool]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[bool]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueBool(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[bool]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

func __VDLReadAnon_set_22(dec vdl.Decoder, x *map[byte]struct{}) error {
	if err := dec.StartValue(__VDLType_set_46); err != nil {
		return err
	}
	var tmpMap map[byte]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[byte]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(8); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[byte]struct{})
			}
			tmpMap[byte(key)] = struct{}{}
		}
	}
}

func __VDLReadAnon_set_23(dec vdl.Decoder, x *map[uint16]struct{}) error {
	if err := dec.StartValue(__VDLType_set_47); err != nil {
		return err
	}
	var tmpMap map[uint16]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint16]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(16); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[uint16]struct{})
			}
			tmpMap[uint16(key)] = struct{}{}
		}
	}
}

func __VDLReadAnon_set_24(dec vdl.Decoder, x *map[uint32]struct{}) error {
	if err := dec.StartValue(__VDLType_set_48); err != nil {
		return err
	}
	var tmpMap map[uint32]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint32]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[uint32]struct{})
			}
			tmpMap[uint32(key)] = struct{}{}
		}
	}
}

func __VDLReadAnon_set_25(dec vdl.Decoder, x *map[uint64]struct{}) error {
	if err := dec.StartValue(__VDLType_set_49); err != nil {
		return err
	}
	var tmpMap map[uint64]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint64]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueUint(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[uint64]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

func __VDLReadAnon_set_26(dec vdl.Decoder, x *map[int16]struct{}) error {
	if err := dec.StartValue(__VDLType_set_50); err != nil {
		return err
	}
	var tmpMap map[int16]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int16]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(16); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[int16]struct{})
			}
			tmpMap[int16(key)] = struct{}{}
		}
	}
}

func __VDLReadAnon_set_27(dec vdl.Decoder, x *map[int32]struct{}) error {
	if err := dec.StartValue(__VDLType_set_51); err != nil {
		return err
	}
	var tmpMap map[int32]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int32]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[int32]struct{})
			}
			tmpMap[int32(key)] = struct{}{}
		}
	}
}

func __VDLReadAnon_set_28(dec vdl.Decoder, x *map[int64]struct{}) error {
	if err := dec.StartValue(__VDLType_set_52); err != nil {
		return err
	}
	var tmpMap map[int64]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int64]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueInt(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[int64]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

func __VDLReadAnon_set_29(dec vdl.Decoder, x *map[float32]struct{}) error {
	if err := dec.StartValue(__VDLType_set_53); err != nil {
		return err
	}
	var tmpMap map[float32]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float32]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueFloat(32); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[float32]struct{})
			}
			tmpMap[float32(key)] = struct{}{}
		}
	}
}

func __VDLReadAnon_set_30(dec vdl.Decoder, x *map[float64]struct{}) error {
	if err := dec.StartValue(__VDLType_set_54); err != nil {
		return err
	}
	var tmpMap map[float64]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float64]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueFloat(64); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[float64]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

func __VDLReadAnon_set_31(dec vdl.Decoder, x *map[time.Time]struct{}) error {
	if err := dec.StartValue(__VDLType_set_55); err != nil {
		return err
	}
	var tmpMap map[time.Time]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[time.Time]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var key time.Time
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &key); err != nil {
				return err
			}
			if tmpMap == nil {
				tmpMap = make(map[time.Time]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

type BigData struct {
	Key string // A dup of the key stored in the value.
}

func (BigData) VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BigData"`
}) {
}

func (x BigData) VDLIsZero() bool {
	return x == BigData{}
}

func (x BigData) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_56); err != nil {
		return err
	}
	if x.Key != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.Key); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BigData) VDLRead(dec vdl.Decoder) error {
	*x = BigData{}
	if err := dec.StartValue(__VDLType_struct_56); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_56 {
			index = __VDLType_struct_56.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Key = value
			}
		}
	}
}

// Hold type definitions in package-level variables, for better performance.
var (
	__VDLType_struct_1  *vdl.Type
	__VDLType_enum_2    *vdl.Type
	__VDLType_enum_3    *vdl.Type
	__VDLType_array_4   *vdl.Type
	__VDLType_struct_5  *vdl.Type
	__VDLType_enum_6    *vdl.Type
	__VDLType_struct_7  *vdl.Type
	__VDLType_set_8     *vdl.Type
	__VDLType_struct_9  *vdl.Type
	__VDLType_map_10    *vdl.Type
	__VDLType_union_11  *vdl.Type
	__VDLType_struct_12 *vdl.Type
	__VDLType_struct_13 *vdl.Type
	__VDLType_list_14   *vdl.Type
	__VDLType_struct_15 *vdl.Type
	__VDLType_struct_16 *vdl.Type
	__VDLType_struct_17 *vdl.Type
	__VDLType_union_18  *vdl.Type
	__VDLType_struct_19 *vdl.Type
	__VDLType_struct_20 *vdl.Type
	__VDLType_struct_21 *vdl.Type
	__VDLType_struct_22 *vdl.Type
	__VDLType_struct_23 *vdl.Type
	__VDLType_struct_24 *vdl.Type
	__VDLType_map_25    *vdl.Type
	__VDLType_map_26    *vdl.Type
	__VDLType_list_27   *vdl.Type
	__VDLType_set_28    *vdl.Type
	__VDLType_struct_29 *vdl.Type
	__VDLType_struct_30 *vdl.Type
	__VDLType_map_31    *vdl.Type
	__VDLType_map_32    *vdl.Type
	__VDLType_map_33    *vdl.Type
	__VDLType_map_34    *vdl.Type
	__VDLType_map_35    *vdl.Type
	__VDLType_map_36    *vdl.Type
	__VDLType_map_37    *vdl.Type
	__VDLType_map_38    *vdl.Type
	__VDLType_map_39    *vdl.Type
	__VDLType_map_40    *vdl.Type
	__VDLType_map_41    *vdl.Type
	__VDLType_map_42    *vdl.Type
	__VDLType_map_43    *vdl.Type
	__VDLType_struct_44 *vdl.Type
	__VDLType_set_45    *vdl.Type
	__VDLType_set_46    *vdl.Type
	__VDLType_set_47    *vdl.Type
	__VDLType_set_48    *vdl.Type
	__VDLType_set_49    *vdl.Type
	__VDLType_set_50    *vdl.Type
	__VDLType_set_51    *vdl.Type
	__VDLType_set_52    *vdl.Type
	__VDLType_set_53    *vdl.Type
	__VDLType_set_54    *vdl.Type
	__VDLType_set_55    *vdl.Type
	__VDLType_struct_56 *vdl.Type
)

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*AddressInfo)(nil))
	vdl.Register((*CreditAgency)(nil))
	vdl.Register((*ExperianRating)(nil))
	vdl.Register((*RatingsArray)(nil))
	vdl.Register((*EquifaxCreditReport)(nil))
	vdl.Register((*Tdh)(nil))
	vdl.Register((*ExperianCreditReport)(nil))
	vdl.Register((*TransUnionCreditReport)(nil))
	vdl.Register((*AgencyReport)(nil))
	vdl.Register((*CreditReport)(nil))
	vdl.Register((*Customer)(nil))
	vdl.Register((*Invoice)(nil))
	vdl.Register((*Numbers)(nil))
	vdl.Register((*TitleOrValueType)(nil))
	vdl.Register((*BazType)(nil))
	vdl.Register((*BarType)(nil))
	vdl.Register((*FooType)(nil))
	vdl.Register((*K)(nil))
	vdl.Register((*V)(nil))
	vdl.Register((*FunWithMaps)(nil))
	vdl.Register((*FunWithTypes)(nil))
	vdl.Register((*ManyMaps)(nil))
	vdl.Register((*ManySets)(nil))
	vdl.Register((*BigData)(nil))

	// Initialize type definitions.
	__VDLType_struct_1 = vdl.TypeOf((*AddressInfo)(nil)).Elem()
	__VDLType_enum_2 = vdl.TypeOf((*CreditAgency)(nil))
	__VDLType_enum_3 = vdl.TypeOf((*ExperianRating)(nil))
	__VDLType_array_4 = vdl.TypeOf((*RatingsArray)(nil))
	__VDLType_struct_5 = vdl.TypeOf((*EquifaxCreditReport)(nil)).Elem()
	__VDLType_enum_6 = vdl.TypeOf((*Tdh)(nil))
	__VDLType_struct_7 = vdl.TypeOf((*ExperianCreditReport)(nil)).Elem()
	__VDLType_set_8 = vdl.TypeOf((*map[Tdh]struct{})(nil))
	__VDLType_struct_9 = vdl.TypeOf((*TransUnionCreditReport)(nil)).Elem()
	__VDLType_map_10 = vdl.TypeOf((*map[string]int16)(nil))
	__VDLType_union_11 = vdl.TypeOf((*AgencyReport)(nil))
	__VDLType_struct_12 = vdl.TypeOf((*CreditReport)(nil)).Elem()
	__VDLType_struct_13 = vdl.TypeOf((*Customer)(nil)).Elem()
	__VDLType_list_14 = vdl.TypeOf((*[]AddressInfo)(nil))
	__VDLType_struct_15 = vdl.TypeOf((*Invoice)(nil)).Elem()
	__VDLType_struct_16 = vdl.TypeOf((*vdltime.Time)(nil)).Elem()
	__VDLType_struct_17 = vdl.TypeOf((*Numbers)(nil)).Elem()
	__VDLType_union_18 = vdl.TypeOf((*TitleOrValueType)(nil))
	__VDLType_struct_19 = vdl.TypeOf((*BazType)(nil)).Elem()
	__VDLType_struct_20 = vdl.TypeOf((*BarType)(nil)).Elem()
	__VDLType_struct_21 = vdl.TypeOf((*FooType)(nil)).Elem()
	__VDLType_struct_22 = vdl.TypeOf((*K)(nil)).Elem()
	__VDLType_struct_23 = vdl.TypeOf((*V)(nil)).Elem()
	__VDLType_struct_24 = vdl.TypeOf((*FunWithMaps)(nil)).Elem()
	__VDLType_map_25 = vdl.TypeOf((*map[K]V)(nil))
	__VDLType_map_26 = vdl.TypeOf((*map[int16][]map[string]struct{})(nil))
	__VDLType_list_27 = vdl.TypeOf((*[]map[string]struct{})(nil))
	__VDLType_set_28 = vdl.TypeOf((*map[string]struct{})(nil))
	__VDLType_struct_29 = vdl.TypeOf((*FunWithTypes)(nil)).Elem()
	__VDLType_struct_30 = vdl.TypeOf((*ManyMaps)(nil)).Elem()
	__VDLType_map_31 = vdl.TypeOf((*map[bool]string)(nil))
	__VDLType_map_32 = vdl.TypeOf((*map[byte]string)(nil))
	__VDLType_map_33 = vdl.TypeOf((*map[uint16]string)(nil))
	__VDLType_map_34 = vdl.TypeOf((*map[uint32]string)(nil))
	__VDLType_map_35 = vdl.TypeOf((*map[uint64]string)(nil))
	__VDLType_map_36 = vdl.TypeOf((*map[int16]string)(nil))
	__VDLType_map_37 = vdl.TypeOf((*map[int32]string)(nil))
	__VDLType_map_38 = vdl.TypeOf((*map[int64]string)(nil))
	__VDLType_map_39 = vdl.TypeOf((*map[float32]string)(nil))
	__VDLType_map_40 = vdl.TypeOf((*map[float64]string)(nil))
	__VDLType_map_41 = vdl.TypeOf((*map[string]string)(nil))
	__VDLType_map_42 = vdl.TypeOf((*map[string]map[string]string)(nil))
	__VDLType_map_43 = vdl.TypeOf((*map[time.Time]string)(nil))
	__VDLType_struct_44 = vdl.TypeOf((*ManySets)(nil)).Elem()
	__VDLType_set_45 = vdl.TypeOf((*map[bool]struct{})(nil))
	__VDLType_set_46 = vdl.TypeOf((*map[byte]struct{})(nil))
	__VDLType_set_47 = vdl.TypeOf((*map[uint16]struct{})(nil))
	__VDLType_set_48 = vdl.TypeOf((*map[uint32]struct{})(nil))
	__VDLType_set_49 = vdl.TypeOf((*map[uint64]struct{})(nil))
	__VDLType_set_50 = vdl.TypeOf((*map[int16]struct{})(nil))
	__VDLType_set_51 = vdl.TypeOf((*map[int32]struct{})(nil))
	__VDLType_set_52 = vdl.TypeOf((*map[int64]struct{})(nil))
	__VDLType_set_53 = vdl.TypeOf((*map[float32]struct{})(nil))
	__VDLType_set_54 = vdl.TypeOf((*map[float64]struct{})(nil))
	__VDLType_set_55 = vdl.TypeOf((*map[time.Time]struct{})(nil))
	__VDLType_struct_56 = vdl.TypeOf((*BigData)(nil)).Elem()

	return struct{}{}
}
