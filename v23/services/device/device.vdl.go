// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: device

// Package device defines interfaces for managing devices and their
// applications.
package device

import (
	"fmt"
	"io"
	"time"
	"v.io/v23"
	"v.io/v23/context"
	"v.io/v23/rpc"
	"v.io/v23/security"
	"v.io/v23/security/access"
	"v.io/v23/services/application"
	"v.io/v23/services/binary"
	"v.io/v23/services/permissions"
	"v.io/v23/services/tidyable"
	"v.io/v23/vdl"
	_ "v.io/v23/vdlroot/time"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// Config specifies app configuration that overrides what's in the envelope.
type Config map[string]string

func (Config) VDLReflect(struct {
	Name string `vdl:"v.io/v23/services/device.Config"`
}) {
}

func (x Config) VDLIsZero() bool {
	return len(x) == 0
}

func (x Config) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_map_1); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
		if err := enc.WriteValueString(vdl.StringType, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Config) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(__VDLType_map_1); err != nil {
		return err
	}
	var tmpMap Config
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(Config, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			var elem string
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				elem = value
			}
			if tmpMap == nil {
				tmpMap = make(Config)
			}
			tmpMap[key] = elem
		}
	}
}

// InstallationState describes the states that an installation can be in at any
// time.
type InstallationState int

const (
	InstallationStateActive InstallationState = iota
	InstallationStateUninstalled
)

// InstallationStateAll holds all labels for InstallationState.
var InstallationStateAll = [...]InstallationState{InstallationStateActive, InstallationStateUninstalled}

// InstallationStateFromString creates a InstallationState from a string label.
// nolint: deadcode, unused
func InstallationStateFromString(label string) (x InstallationState, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *InstallationState) Set(label string) error {
	switch label {
	case "Active", "active":
		*x = InstallationStateActive
		return nil
	case "Uninstalled", "uninstalled":
		*x = InstallationStateUninstalled
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in device.InstallationState", label)
}

// String returns the string label of x.
func (x InstallationState) String() string {
	switch x {
	case InstallationStateActive:
		return "Active"
	case InstallationStateUninstalled:
		return "Uninstalled"
	}
	return ""
}

func (InstallationState) VDLReflect(struct {
	Name string `vdl:"v.io/v23/services/device.InstallationState"`
	Enum struct{ Active, Uninstalled string }
}) {
}

func (x InstallationState) VDLIsZero() bool {
	return x == InstallationStateActive
}

func (x InstallationState) VDLWrite(enc vdl.Encoder) error {
	if err := enc.WriteValueString(__VDLType_enum_2, x.String()); err != nil {
		return err
	}
	return nil
}

func (x *InstallationState) VDLRead(dec vdl.Decoder) error {
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		if err := x.Set(value); err != nil {
			return err
		}
	}
	return nil
}

// InstanceState describes the states that an instance can be in at any
// time.
type InstanceState int

const (
	InstanceStateLaunching InstanceState = iota
	InstanceStateRunning
	InstanceStateDying
	InstanceStateNotRunning
	InstanceStateUpdating
	InstanceStateDeleted
)

// InstanceStateAll holds all labels for InstanceState.
var InstanceStateAll = [...]InstanceState{InstanceStateLaunching, InstanceStateRunning, InstanceStateDying, InstanceStateNotRunning, InstanceStateUpdating, InstanceStateDeleted}

// InstanceStateFromString creates a InstanceState from a string label.
// nolint: deadcode, unused
func InstanceStateFromString(label string) (x InstanceState, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *InstanceState) Set(label string) error {
	switch label {
	case "Launching", "launching":
		*x = InstanceStateLaunching
		return nil
	case "Running", "running":
		*x = InstanceStateRunning
		return nil
	case "Dying", "dying":
		*x = InstanceStateDying
		return nil
	case "NotRunning", "notrunning":
		*x = InstanceStateNotRunning
		return nil
	case "Updating", "updating":
		*x = InstanceStateUpdating
		return nil
	case "Deleted", "deleted":
		*x = InstanceStateDeleted
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in device.InstanceState", label)
}

// String returns the string label of x.
func (x InstanceState) String() string {
	switch x {
	case InstanceStateLaunching:
		return "Launching"
	case InstanceStateRunning:
		return "Running"
	case InstanceStateDying:
		return "Dying"
	case InstanceStateNotRunning:
		return "NotRunning"
	case InstanceStateUpdating:
		return "Updating"
	case InstanceStateDeleted:
		return "Deleted"
	}
	return ""
}

func (InstanceState) VDLReflect(struct {
	Name string `vdl:"v.io/v23/services/device.InstanceState"`
	Enum struct{ Launching, Running, Dying, NotRunning, Updating, Deleted string }
}) {
}

func (x InstanceState) VDLIsZero() bool {
	return x == InstanceStateLaunching
}

func (x InstanceState) VDLWrite(enc vdl.Encoder) error {
	if err := enc.WriteValueString(__VDLType_enum_3, x.String()); err != nil {
		return err
	}
	return nil
}

func (x *InstanceState) VDLRead(dec vdl.Decoder) error {
	switch value, err := dec.ReadValueString(); {
	case err != nil:
		return err
	default:
		if err := x.Set(value); err != nil {
			return err
		}
	}
	return nil
}

// InstanceStatus specifies the Status returned by the Application Status method
// for instance objects.
type InstanceStatus struct {
	State   InstanceState
	Version string
}

func (InstanceStatus) VDLReflect(struct {
	Name string `vdl:"v.io/v23/services/device.InstanceStatus"`
}) {
}

func (x InstanceStatus) VDLIsZero() bool {
	return x == InstanceStatus{}
}

func (x InstanceStatus) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_4); err != nil {
		return err
	}
	if x.State != InstanceStateLaunching {
		if err := enc.NextFieldValueString(0, __VDLType_enum_3, x.State.String()); err != nil {
			return err
		}
	}
	if x.Version != "" {
		if err := enc.NextFieldValueString(1, vdl.StringType, x.Version); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *InstanceStatus) VDLRead(dec vdl.Decoder) error {
	*x = InstanceStatus{}
	if err := dec.StartValue(__VDLType_struct_4); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_4 {
			index = __VDLType_struct_4.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				if err := x.State.Set(value); err != nil {
					return err
				}
			}
		case 1:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Version = value
			}
		}
	}
}

// InstallationStatus specifies the Status returned by the Application Status
// method for installation objects.
type InstallationStatus struct {
	State   InstallationState
	Version string
}

func (InstallationStatus) VDLReflect(struct {
	Name string `vdl:"v.io/v23/services/device.InstallationStatus"`
}) {
}

func (x InstallationStatus) VDLIsZero() bool {
	return x == InstallationStatus{}
}

func (x InstallationStatus) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_5); err != nil {
		return err
	}
	if x.State != InstallationStateActive {
		if err := enc.NextFieldValueString(0, __VDLType_enum_2, x.State.String()); err != nil {
			return err
		}
	}
	if x.Version != "" {
		if err := enc.NextFieldValueString(1, vdl.StringType, x.Version); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *InstallationStatus) VDLRead(dec vdl.Decoder) error {
	*x = InstallationStatus{}
	if err := dec.StartValue(__VDLType_struct_5); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_5 {
			index = __VDLType_struct_5.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				if err := x.State.Set(value); err != nil {
					return err
				}
			}
		case 1:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Version = value
			}
		}
	}
}

// DeviceStatus specifies the Status returned by the Application Status method
// for the device service object.
type DeviceStatus struct {
	State   InstanceState
	Version string
}

func (DeviceStatus) VDLReflect(struct {
	Name string `vdl:"v.io/v23/services/device.DeviceStatus"`
}) {
}

func (x DeviceStatus) VDLIsZero() bool {
	return x == DeviceStatus{}
}

func (x DeviceStatus) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_6); err != nil {
		return err
	}
	if x.State != InstanceStateLaunching {
		if err := enc.NextFieldValueString(0, __VDLType_enum_3, x.State.String()); err != nil {
			return err
		}
	}
	if x.Version != "" {
		if err := enc.NextFieldValueString(1, vdl.StringType, x.Version); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *DeviceStatus) VDLRead(dec vdl.Decoder) error {
	*x = DeviceStatus{}
	if err := dec.StartValue(__VDLType_struct_6); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_6 {
			index = __VDLType_struct_6.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				if err := x.State.Set(value); err != nil {
					return err
				}
			}
		case 1:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.Version = value
			}
		}
	}
}

type (
	// Status represents any single field of the Status union type.
	//
	// Status is returned by the Application Status method.
	Status interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// VDLReflect describes the Status union type.
		VDLReflect(__StatusReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// StatusInstance represents field Instance of the Status union type.
	StatusInstance struct{ Value InstanceStatus }
	// StatusInstallation represents field Installation of the Status union type.
	StatusInstallation struct{ Value InstallationStatus }
	// StatusDevice represents field Device of the Status union type.
	StatusDevice struct{ Value DeviceStatus }
	// __StatusReflect describes the Status union type.
	__StatusReflect struct {
		Name  string `vdl:"v.io/v23/services/device.Status"`
		Type  Status
		Union struct {
			Instance     StatusInstance
			Installation StatusInstallation
			Device       StatusDevice
		}
	}
)

func (x StatusInstance) Index() int                 { return 0 }
func (x StatusInstance) Interface() interface{}     { return x.Value }
func (x StatusInstance) Name() string               { return "Instance" }
func (x StatusInstance) VDLReflect(__StatusReflect) {}

func (x StatusInstallation) Index() int                 { return 1 }
func (x StatusInstallation) Interface() interface{}     { return x.Value }
func (x StatusInstallation) Name() string               { return "Installation" }
func (x StatusInstallation) VDLReflect(__StatusReflect) {}

func (x StatusDevice) Index() int                 { return 2 }
func (x StatusDevice) Interface() interface{}     { return x.Value }
func (x StatusDevice) Name() string               { return "Device" }
func (x StatusDevice) VDLReflect(__StatusReflect) {}

func (x StatusInstance) VDLIsZero() bool {
	return x.Value == InstanceStatus{}
}

func (x StatusInstallation) VDLIsZero() bool {
	return false
}

func (x StatusDevice) VDLIsZero() bool {
	return false
}

func (x StatusInstance) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_union_7); err != nil {
		return err
	}
	if err := enc.NextField(0); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x StatusInstallation) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_union_7); err != nil {
		return err
	}
	if err := enc.NextField(1); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x StatusDevice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_union_7); err != nil {
		return err
	}
	if err := enc.NextField(2); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadStatus(dec vdl.Decoder, x *Status) error {
	if err := dec.StartValue(__VDLType_union_7); err != nil {
		return err
	}
	decType := dec.Type()
	index, err := dec.NextField()
	switch {
	case err != nil:
		return err
	case index == -1:
		return fmt.Errorf("missing field in union %T, from %v", x, decType)
	}
	if decType != __VDLType_union_7 {
		name := decType.Field(index).Name
		index = __VDLType_union_7.FieldIndexByName(name)
		if index == -1 {
			return fmt.Errorf("field %q not in union %T, from %v", name, x, decType)
		}
	}
	switch index {
	case 0:
		var field StatusInstance
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 1:
		var field StatusInstallation
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case 2:
		var field StatusDevice
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	}
	switch index, err := dec.NextField(); {
	case err != nil:
		return err
	case index != -1:
		return fmt.Errorf("extra field %d in union %T, from %v", index, x, dec.Type())
	}
	return dec.FinishValue()
}

type (
	// BlessServerMessage represents any single field of the BlessServerMessage union type.
	//
	// BlessServerMessage is the data type that is streamed from the server to the
	// client during an Instantiate method call.
	// This is a union to enable backward compatible changes.
	BlessServerMessage interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// VDLReflect describes the BlessServerMessage union type.
		VDLReflect(__BlessServerMessageReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// BlessServerMessageInstancePublicKey represents field InstancePublicKey of the BlessServerMessage union type.
	//
	// The public key of the instance being blessed. The client must return
	// blessings for this key.
	BlessServerMessageInstancePublicKey struct{ Value []byte }
	// __BlessServerMessageReflect describes the BlessServerMessage union type.
	__BlessServerMessageReflect struct {
		Name  string `vdl:"v.io/v23/services/device.BlessServerMessage"`
		Type  BlessServerMessage
		Union struct {
			InstancePublicKey BlessServerMessageInstancePublicKey
		}
	}
)

func (x BlessServerMessageInstancePublicKey) Index() int                             { return 0 }
func (x BlessServerMessageInstancePublicKey) Interface() interface{}                 { return x.Value }
func (x BlessServerMessageInstancePublicKey) Name() string                           { return "InstancePublicKey" }
func (x BlessServerMessageInstancePublicKey) VDLReflect(__BlessServerMessageReflect) {}

func (x BlessServerMessageInstancePublicKey) VDLIsZero() bool {
	return len(x.Value) == 0
}

func (x BlessServerMessageInstancePublicKey) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_union_9); err != nil {
		return err
	}
	if err := enc.NextFieldValueBytes(0, __VDLType_list_8, x.Value); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadBlessServerMessage(dec vdl.Decoder, x *BlessServerMessage) error {
	if err := dec.StartValue(__VDLType_union_9); err != nil {
		return err
	}
	decType := dec.Type()
	index, err := dec.NextField()
	switch {
	case err != nil:
		return err
	case index == -1:
		return fmt.Errorf("missing field in union %T, from %v", x, decType)
	}
	if decType != __VDLType_union_9 {
		name := decType.Field(index).Name
		index = __VDLType_union_9.FieldIndexByName(name)
		if index == -1 {
			return fmt.Errorf("field %q not in union %T, from %v", name, x, decType)
		}
	}
	switch index {
	case 0:
		var field BlessServerMessageInstancePublicKey
		if err := dec.ReadValueBytes(-1, &field.Value); err != nil {
			return err
		}
		*x = field
	}
	switch index, err := dec.NextField(); {
	case err != nil:
		return err
	case index != -1:
		return fmt.Errorf("extra field %d in union %T, from %v", index, x, dec.Type())
	}
	return dec.FinishValue()
}

type (
	// BlessClientMessage represents any single field of the BlessClientMessage union type.
	//
	// BlessClientMessage is the data type that is streamed from the client to the
	// server during a Instantiate method call.
	// This is a union to enable backward compatible changes.
	BlessClientMessage interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// VDLReflect describes the BlessClientMessage union type.
		VDLReflect(__BlessClientMessageReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// BlessClientMessageAppBlessings represents field AppBlessings of the BlessClientMessage union type.
	//
	// Blessings for the application instance.
	BlessClientMessageAppBlessings struct{ Value security.Blessings }
	// __BlessClientMessageReflect describes the BlessClientMessage union type.
	__BlessClientMessageReflect struct {
		Name  string `vdl:"v.io/v23/services/device.BlessClientMessage"`
		Type  BlessClientMessage
		Union struct {
			AppBlessings BlessClientMessageAppBlessings
		}
	}
)

func (x BlessClientMessageAppBlessings) Index() int                             { return 0 }
func (x BlessClientMessageAppBlessings) Interface() interface{}                 { return x.Value }
func (x BlessClientMessageAppBlessings) Name() string                           { return "AppBlessings" }
func (x BlessClientMessageAppBlessings) VDLReflect(__BlessClientMessageReflect) {}

func (x BlessClientMessageAppBlessings) VDLIsZero() bool {
	return x.Value.IsZero()
}

func (x BlessClientMessageAppBlessings) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_union_11); err != nil {
		return err
	}
	if err := enc.NextField(0); err != nil {
		return err
	}
	var wire security.WireBlessings
	if err := security.WireBlessingsFromNative(&wire, x.Value); err != nil {
		return err
	}
	if err := wire.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadBlessClientMessage(dec vdl.Decoder, x *BlessClientMessage) error {
	if err := dec.StartValue(__VDLType_union_11); err != nil {
		return err
	}
	decType := dec.Type()
	index, err := dec.NextField()
	switch {
	case err != nil:
		return err
	case index == -1:
		return fmt.Errorf("missing field in union %T, from %v", x, decType)
	}
	if decType != __VDLType_union_11 {
		name := decType.Field(index).Name
		index = __VDLType_union_11.FieldIndexByName(name)
		if index == -1 {
			return fmt.Errorf("field %q not in union %T, from %v", name, x, decType)
		}
	}
	switch index {
	case 0:
		var field BlessClientMessageAppBlessings
		var wire security.WireBlessings
		if err := wire.VDLRead(dec); err != nil {
			return err
		}
		if err := security.WireBlessingsToNative(wire, &field.Value); err != nil {
			return err
		}
		*x = field
	}
	switch index, err := dec.NextField(); {
	case err != nil:
		return err
	case index != -1:
		return fmt.Errorf("extra field %d in union %T, from %v", index, x, dec.Type())
	}
	return dec.FinishValue()
}

// Description enumerates the profiles that a Device supports.
type Description struct {
	// Profiles is a set of names of supported profiles.	Each name can
	// either be an object name that resolves to a Profile, or can be the
	// profile's label, e.g.:
	//   "profiles/google/cluster/diskfull"
	//   "linux-media"
	//
	// Profiles for devices can be provided by hand, but they can also be
	// automatically derived by examining the device.
	Profiles map[string]struct{}
}

func (Description) VDLReflect(struct {
	Name string `vdl:"v.io/v23/services/device.Description"`
}) {
}

func (x Description) VDLIsZero() bool {
	return len(x.Profiles) == 0
}

func (x Description) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_12); err != nil {
		return err
	}
	if len(x.Profiles) != 0 {
		if err := enc.NextField(0); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_1(enc, x.Profiles); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_1(enc vdl.Encoder, x map[string]struct{}) error {
	if err := enc.StartValue(__VDLType_set_13); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntryValueString(vdl.StringType, key); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Description) VDLRead(dec vdl.Decoder) error {
	*x = Description{}
	if err := dec.StartValue(__VDLType_struct_12); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_12 {
			index = __VDLType_struct_12.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			if err := __VDLReadAnon_set_1(dec, &x.Profiles); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_set_1(dec vdl.Decoder, x *map[string]struct{}) error {
	if err := dec.StartValue(__VDLType_set_13); err != nil {
		return err
	}
	var tmpMap map[string]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]struct{}, len)
	}
	for {
		switch done, key, err := dec.NextEntryValueString(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		default:
			if tmpMap == nil {
				tmpMap = make(map[string]struct{})
			}
			tmpMap[key] = struct{}{}
		}
	}
}

// Association is a tuple containing an association between a Vanadium
// identity and a system account name.
type Association struct {
	IdentityName string
	AccountName  string
}

func (Association) VDLReflect(struct {
	Name string `vdl:"v.io/v23/services/device.Association"`
}) {
}

func (x Association) VDLIsZero() bool {
	return x == Association{}
}

func (x Association) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(__VDLType_struct_14); err != nil {
		return err
	}
	if x.IdentityName != "" {
		if err := enc.NextFieldValueString(0, vdl.StringType, x.IdentityName); err != nil {
			return err
		}
	}
	if x.AccountName != "" {
		if err := enc.NextFieldValueString(1, vdl.StringType, x.AccountName); err != nil {
			return err
		}
	}
	if err := enc.NextField(-1); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Association) VDLRead(dec vdl.Decoder) error {
	*x = Association{}
	if err := dec.StartValue(__VDLType_struct_14); err != nil {
		return err
	}
	decType := dec.Type()
	for {
		index, err := dec.NextField()
		switch {
		case err != nil:
			return err
		case index == -1:
			return dec.FinishValue()
		}
		if decType != __VDLType_struct_14 {
			index = __VDLType_struct_14.FieldIndexByName(decType.Field(index).Name)
			if index == -1 {
				if err := dec.SkipValue(); err != nil {
					return err
				}
				continue
			}
		}
		switch index {
		case 0:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.IdentityName = value
			}
		case 1:
			switch value, err := dec.ReadValueString(); {
			case err != nil:
				return err
			default:
				x.AccountName = value
			}
		}
	}
}

//////////////////////////////////////////////////
// Interface definitions

// ApplicationClientMethods is the client interface
// containing Application methods.
//
// Application can be used to manage applications on a device. This interface
// will be invoked using an object name that identifies the application and its
// installations and instances where applicable.
//
// An application is defined by a title.  An application can have multiple
// installations on a device.  The installations are grouped under the same
// application, but are otherwise independent of each other.  Each installation
// can have zero or more instances (which can be running or not).  The instances
// are independent of each other, and do not share state (like local storage).
// Interaction among instances should occur via Vanadium RPC, facilitated by the
// local mounttable.
//
// The device manager supports versioning of applications.  Each installation
// maintains a tree of versions, where a version is defined by a specific
// envelope.  The tree structure comes from 'previous version' references: each
// version (except the initial installation version) maintains a reference to
// the version that preceded it.  The installation maintains a current version
// reference that is used for new instances.  Each update operation on the
// installation creates a new version, sets the previous reference of the new
// version to the current version, and then updates the current version to refer
// to the new version.  Each revert operation on the installation sets the
// current version to the previous version of the current version.  Each
// instance maintains a current version reference that is used to run the
// instance.  The initial version of the instance is set to the current version
// of the installation at the time of instantiation.  Each update operation on
// the instance updates the instance's current version to the current version of
// the installation.  Each revert operation on the instance updates the
// instance's current version to the previous version of the instance's version.
//
// The Application interface methods can be divided based on their intended
// receiver:
//
// 1) Method receiver is an application:
//     - Install()
//
// 2) Method receiver is an application installation:
//     - Instantiate()
//     - Uninstall()
//
// 3) Method receiver is an application instance:
//     - Run()
//     - Kill()
//     - Delete()
//
// 4) Method receiver is an application installation or instance:
//     - Update()
//     - Revert()
//
// The following methods complement one another:
//     - Install() and Uninstall()
//     - Instantiate() and Delete()
//     - Run() and Kill()
//     - Update() and Revert()
//
//
//
// Examples:
//
// Install Google Maps on the device.
//     device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/0"
//
// Create and start an instance of the previously installed maps application
// installation.
//    device/apps/google maps/0.Instantiate() --> { "0" }
//    device/apps/google maps/0/0.Run()
//
// Create and start a second instance of the previously installed maps
// application installation.
//    device/apps/google maps/0.Instantiate() --> { "1" }
//    device/apps/google maps/0/1.Run()
//
// Kill and delete the first instance previously started.
//    device/apps/google maps/0/0.Kill()
//    device/apps/google maps/0/0.Delete()
//
// Install a second Google Maps installation.
//    device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/1"
//
// Update the second maps installation to the latest version available.
//    device/apps/google maps/1.Update()
//
// Update the first maps installation to a specific version.
//    device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
//
// Finally, an application installation instance can be in one of three abstract
// states: 1) "does not exist/deleted", 2) "running", or 3) "not-running". The
// interface methods transition between these abstract states using the
// following state machine:
//
//    apply(Instantiate(), "does not exist") = "not-running"
//    apply(Run(), "not-running") = "running"
//    apply(Kill(), "running") = "not-running"
//    apply(Delete(), "not-running") = "deleted"
type ApplicationClientMethods interface {
	// Object provides access control for Vanadium objects.
	//
	// Vanadium services implementing dynamic access control would typically embed
	// this interface and tag additional methods defined by the service with one of
	// Admin, Read, Write, Resolve etc. For example, the VDL definition of the
	// object would be:
	//
	//   package mypackage
	//
	//   import "v.io/v23/security/access"
	//   import "v.io/v23/services/permissions"
	//
	//   type MyObject interface {
	//     permissions.Object
	//     MyRead() (string, error) {access.Read}
	//     MyWrite(string) error    {access.Write}
	//   }
	//
	// If the set of pre-defined tags is insufficient, services may define their
	// own tag type and annotate all methods with this new type.
	//
	// Instead of embedding this Object interface, define SetPermissions and
	// GetPermissions in their own interface. Authorization policies will typically
	// respect annotations of a single type. For example, the VDL definition of an
	// object would be:
	//
	//  package mypackage
	//
	//  import "v.io/v23/security/access"
	//
	//  type MyTag string
	//
	//  const (
	//    Blue = MyTag("Blue")
	//    Red  = MyTag("Red")
	//  )
	//
	//  type MyObject interface {
	//    MyMethod() (string, error) {Blue}
	//
	//    // Allow clients to change access via the access.Object interface:
	//    SetPermissions(perms access.Permissions, version string) error         {Red}
	//    GetPermissions() (perms access.Permissions, version string, err error) {Blue}
	//  }
	permissions.ObjectClientMethods
	// Install installs the application identified by the first argument and
	// returns an object name suffix that identifies the new installation.
	//
	// The name argument should be an object name for an application
	// envelope.  The service it identifies must implement
	// repository.Application, and is expected to return either the
	// requested version (if the object name encodes a specific version), or
	// otherwise the latest available version, as appropriate.  This object
	// name will be used by default by the Update method, as a source for
	// updated application envelopes (can be overriden by setting
	// AppOriginConfigKey in the config).
	//
	// The config argument specifies config settings that will take
	// precedence over those present in the application envelope.
	//
	// The packages argument specifies packages to be installed in addition
	// to those specified in the envelope.  If a package in the envelope has
	// the same key, the package in the packages argument takes precedence.
	//
	// The returned suffix, when appended to the name used to reach the
	// receiver for Install, can be used to control the installation object.
	// The suffix will contain the title of the application as a prefix,
	// which can then be used to control all the installations of the given
	// application.
	// TODO(rjkroege): Use customized labels.
	Install(_ *context.T, name string, config Config, packages application.Packages, _ ...rpc.CallOpt) (string, error)
	// Uninstall uninstalls an application installation.
	// The installation must be in state Active.
	Uninstall(*context.T, ...rpc.CallOpt) error
	// Instantiate creates an instance of an application installation.
	// The installation must be in state Active.
	//
	// The server sends the application instance's Public Key on the stream.
	// When the client receives the Public Key it must send Blessings back
	// to the server. When the instance is created, the server returns the
	// instance name to the client.
	//
	// Client                       Server
	//  "object".Instantiate() -->
	//                         <--  InstancePublicKey
	//  AppBlessings           -->
	//                         <--  return InstanceName
	Instantiate(*context.T, ...rpc.CallOpt) (ApplicationInstantiateClientCall, error)
	// Delete deletes an instance.  Once deleted, the instance cannot be
	// revived.
	// The instance must be in state NotRunning.
	//
	// If called against a Device, causes the Device to shut itself down.
	Delete(*context.T, ...rpc.CallOpt) error
	// Run begins execution of an application instance.
	// The instance must be in state NotRunning.
	Run(*context.T, ...rpc.CallOpt) error
	// Kill attempts a clean shutdown an of application instance.
	// The instance must be in state Running.
	//
	// If the deadline is non-zero and the instance in question is still
	// running after the given deadline, shutdown of the instance is
	// enforced.
	//
	// If called against a Device, causes the Device to stop itself (which
	// may or may not result in a restart depending on the device manager
	// setup).
	Kill(_ *context.T, deadline time.Duration, _ ...rpc.CallOpt) error
	// Update updates an application installation's version to a new version
	// created from the envelope at the object name provided during Install.
	// If the new application envelope contains a different application
	// title, the update does not occur, and an error is returned.  The
	// installation must be in state Active.
	//
	// Update updates an application instance's version to the current
	// installation version.  The instance must be in state NotRunning.
	Update(*context.T, ...rpc.CallOpt) error
	// UpdateTo updates the application installation(s) to the application
	// specified by the object name argument.  If the new application
	// envelope contains a different application title, the update does not
	// occur, and an error is returned.
	// The installation must be in state Active.
	UpdateTo(_ *context.T, name string, _ ...rpc.CallOpt) error
	// Revert reverts an application installation's version to the previous
	// version of its current version.  The installation must be in state
	// Active.
	//
	// Revert reverts an application instance's version to the previous
	// version of its current version.  The instance must be in state
	// NotRunning.
	Revert(*context.T, ...rpc.CallOpt) error
	// Debug returns debug information about the application installation or
	// instance.  This is generally highly implementation-specific, and
	// presented in an unstructured form.  No guarantees are given about the
	// stability of the format, and parsing it programmatically is
	// specifically discouraged.
	Debug(*context.T, ...rpc.CallOpt) (string, error)
	// Status returns structured information about the application
	// installation or instance.
	Status(*context.T, ...rpc.CallOpt) (Status, error)
}

// ApplicationClientStub adds universal methods to ApplicationClientMethods.
type ApplicationClientStub interface {
	ApplicationClientMethods
	rpc.UniversalServiceMethods
}

// ApplicationClient returns a client stub for Application.
func ApplicationClient(name string) ApplicationClientStub {
	return implApplicationClientStub{name, permissions.ObjectClient(name)}
}

type implApplicationClientStub struct {
	name string

	permissions.ObjectClientStub
}

func (c implApplicationClientStub) Install(ctx *context.T, i0 string, i1 Config, i2 application.Packages, opts ...rpc.CallOpt) (o0 string, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Install", []interface{}{i0, i1, i2}, []interface{}{&o0}, opts...)
	return
}

func (c implApplicationClientStub) Uninstall(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Uninstall", nil, nil, opts...)
	return
}

func (c implApplicationClientStub) Instantiate(ctx *context.T, opts ...rpc.CallOpt) (ocall ApplicationInstantiateClientCall, err error) {
	var call rpc.ClientCall
	if call, err = v23.GetClient(ctx).StartCall(ctx, c.name, "Instantiate", nil, opts...); err != nil {
		return
	}
	ocall = &implApplicationInstantiateClientCall{ClientCall: call}
	return
}

func (c implApplicationClientStub) Delete(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Delete", nil, nil, opts...)
	return
}

func (c implApplicationClientStub) Run(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Run", nil, nil, opts...)
	return
}

func (c implApplicationClientStub) Kill(ctx *context.T, i0 time.Duration, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Kill", []interface{}{i0}, nil, opts...)
	return
}

func (c implApplicationClientStub) Update(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Update", nil, nil, opts...)
	return
}

func (c implApplicationClientStub) UpdateTo(ctx *context.T, i0 string, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "UpdateTo", []interface{}{i0}, nil, opts...)
	return
}

func (c implApplicationClientStub) Revert(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Revert", nil, nil, opts...)
	return
}

func (c implApplicationClientStub) Debug(ctx *context.T, opts ...rpc.CallOpt) (o0 string, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Debug", nil, []interface{}{&o0}, opts...)
	return
}

func (c implApplicationClientStub) Status(ctx *context.T, opts ...rpc.CallOpt) (o0 Status, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Status", nil, []interface{}{&o0}, opts...)
	return
}

// ApplicationInstantiateClientStream is the client stream for Application.Instantiate.
type ApplicationInstantiateClientStream interface {
	// RecvStream returns the receiver side of the Application.Instantiate client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() BlessServerMessage
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the Application.Instantiate client stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors
		// encountered while sending, or if Send is called after Close or
		// the stream has been canceled.  Blocks if there is no buffer
		// space; will unblock when buffer space is available or after
		// the stream has been canceled.
		Send(item BlessClientMessage) error
		// Close indicates to the server that no more items will be sent;
		// server Recv calls will receive io.EOF after all sent items.
		// This is an optional call - e.g. a client might call Close if it
		// needs to continue receiving items from the server after it's
		// done sending.  Returns errors encountered while closing, or if
		// Close is called after the stream has been canceled.  Like Send,
		// blocks if there is no buffer space available.
		Close() error
	}
}

// ApplicationInstantiateClientCall represents the call returned from Application.Instantiate.
type ApplicationInstantiateClientCall interface {
	ApplicationInstantiateClientStream
	// Finish performs the equivalent of SendStream().Close, then blocks until
	// the server is done, and returns the positional return values for the call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() (string, error)
}

type implApplicationInstantiateClientCall struct {
	rpc.ClientCall
	valRecv BlessServerMessage
	errRecv error
}

func (c *implApplicationInstantiateClientCall) RecvStream() interface {
	Advance() bool
	Value() BlessServerMessage
	Err() error
} {
	return implApplicationInstantiateClientCallRecv{c}
}

type implApplicationInstantiateClientCallRecv struct {
	c *implApplicationInstantiateClientCall
}

func (c implApplicationInstantiateClientCallRecv) Advance() bool {
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implApplicationInstantiateClientCallRecv) Value() BlessServerMessage {
	return c.c.valRecv
}
func (c implApplicationInstantiateClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implApplicationInstantiateClientCall) SendStream() interface {
	Send(item BlessClientMessage) error
	Close() error
} {
	return implApplicationInstantiateClientCallSend{c}
}

type implApplicationInstantiateClientCallSend struct {
	c *implApplicationInstantiateClientCall
}

func (c implApplicationInstantiateClientCallSend) Send(item BlessClientMessage) error {
	return c.c.Send(item)
}
func (c implApplicationInstantiateClientCallSend) Close() error {
	return c.c.CloseSend()
}
func (c *implApplicationInstantiateClientCall) Finish() (o0 string, err error) {
	err = c.ClientCall.Finish(&o0)
	return
}

// ApplicationServerMethods is the interface a server writer
// implements for Application.
//
// Application can be used to manage applications on a device. This interface
// will be invoked using an object name that identifies the application and its
// installations and instances where applicable.
//
// An application is defined by a title.  An application can have multiple
// installations on a device.  The installations are grouped under the same
// application, but are otherwise independent of each other.  Each installation
// can have zero or more instances (which can be running or not).  The instances
// are independent of each other, and do not share state (like local storage).
// Interaction among instances should occur via Vanadium RPC, facilitated by the
// local mounttable.
//
// The device manager supports versioning of applications.  Each installation
// maintains a tree of versions, where a version is defined by a specific
// envelope.  The tree structure comes from 'previous version' references: each
// version (except the initial installation version) maintains a reference to
// the version that preceded it.  The installation maintains a current version
// reference that is used for new instances.  Each update operation on the
// installation creates a new version, sets the previous reference of the new
// version to the current version, and then updates the current version to refer
// to the new version.  Each revert operation on the installation sets the
// current version to the previous version of the current version.  Each
// instance maintains a current version reference that is used to run the
// instance.  The initial version of the instance is set to the current version
// of the installation at the time of instantiation.  Each update operation on
// the instance updates the instance's current version to the current version of
// the installation.  Each revert operation on the instance updates the
// instance's current version to the previous version of the instance's version.
//
// The Application interface methods can be divided based on their intended
// receiver:
//
// 1) Method receiver is an application:
//     - Install()
//
// 2) Method receiver is an application installation:
//     - Instantiate()
//     - Uninstall()
//
// 3) Method receiver is an application instance:
//     - Run()
//     - Kill()
//     - Delete()
//
// 4) Method receiver is an application installation or instance:
//     - Update()
//     - Revert()
//
// The following methods complement one another:
//     - Install() and Uninstall()
//     - Instantiate() and Delete()
//     - Run() and Kill()
//     - Update() and Revert()
//
//
//
// Examples:
//
// Install Google Maps on the device.
//     device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/0"
//
// Create and start an instance of the previously installed maps application
// installation.
//    device/apps/google maps/0.Instantiate() --> { "0" }
//    device/apps/google maps/0/0.Run()
//
// Create and start a second instance of the previously installed maps
// application installation.
//    device/apps/google maps/0.Instantiate() --> { "1" }
//    device/apps/google maps/0/1.Run()
//
// Kill and delete the first instance previously started.
//    device/apps/google maps/0/0.Kill()
//    device/apps/google maps/0/0.Delete()
//
// Install a second Google Maps installation.
//    device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/1"
//
// Update the second maps installation to the latest version available.
//    device/apps/google maps/1.Update()
//
// Update the first maps installation to a specific version.
//    device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
//
// Finally, an application installation instance can be in one of three abstract
// states: 1) "does not exist/deleted", 2) "running", or 3) "not-running". The
// interface methods transition between these abstract states using the
// following state machine:
//
//    apply(Instantiate(), "does not exist") = "not-running"
//    apply(Run(), "not-running") = "running"
//    apply(Kill(), "running") = "not-running"
//    apply(Delete(), "not-running") = "deleted"
type ApplicationServerMethods interface {
	// Object provides access control for Vanadium objects.
	//
	// Vanadium services implementing dynamic access control would typically embed
	// this interface and tag additional methods defined by the service with one of
	// Admin, Read, Write, Resolve etc. For example, the VDL definition of the
	// object would be:
	//
	//   package mypackage
	//
	//   import "v.io/v23/security/access"
	//   import "v.io/v23/services/permissions"
	//
	//   type MyObject interface {
	//     permissions.Object
	//     MyRead() (string, error) {access.Read}
	//     MyWrite(string) error    {access.Write}
	//   }
	//
	// If the set of pre-defined tags is insufficient, services may define their
	// own tag type and annotate all methods with this new type.
	//
	// Instead of embedding this Object interface, define SetPermissions and
	// GetPermissions in their own interface. Authorization policies will typically
	// respect annotations of a single type. For example, the VDL definition of an
	// object would be:
	//
	//  package mypackage
	//
	//  import "v.io/v23/security/access"
	//
	//  type MyTag string
	//
	//  const (
	//    Blue = MyTag("Blue")
	//    Red  = MyTag("Red")
	//  )
	//
	//  type MyObject interface {
	//    MyMethod() (string, error) {Blue}
	//
	//    // Allow clients to change access via the access.Object interface:
	//    SetPermissions(perms access.Permissions, version string) error         {Red}
	//    GetPermissions() (perms access.Permissions, version string, err error) {Blue}
	//  }
	permissions.ObjectServerMethods
	// Install installs the application identified by the first argument and
	// returns an object name suffix that identifies the new installation.
	//
	// The name argument should be an object name for an application
	// envelope.  The service it identifies must implement
	// repository.Application, and is expected to return either the
	// requested version (if the object name encodes a specific version), or
	// otherwise the latest available version, as appropriate.  This object
	// name will be used by default by the Update method, as a source for
	// updated application envelopes (can be overriden by setting
	// AppOriginConfigKey in the config).
	//
	// The config argument specifies config settings that will take
	// precedence over those present in the application envelope.
	//
	// The packages argument specifies packages to be installed in addition
	// to those specified in the envelope.  If a package in the envelope has
	// the same key, the package in the packages argument takes precedence.
	//
	// The returned suffix, when appended to the name used to reach the
	// receiver for Install, can be used to control the installation object.
	// The suffix will contain the title of the application as a prefix,
	// which can then be used to control all the installations of the given
	// application.
	// TODO(rjkroege): Use customized labels.
	Install(_ *context.T, _ rpc.ServerCall, name string, config Config, packages application.Packages) (string, error)
	// Uninstall uninstalls an application installation.
	// The installation must be in state Active.
	Uninstall(*context.T, rpc.ServerCall) error
	// Instantiate creates an instance of an application installation.
	// The installation must be in state Active.
	//
	// The server sends the application instance's Public Key on the stream.
	// When the client receives the Public Key it must send Blessings back
	// to the server. When the instance is created, the server returns the
	// instance name to the client.
	//
	// Client                       Server
	//  "object".Instantiate() -->
	//                         <--  InstancePublicKey
	//  AppBlessings           -->
	//                         <--  return InstanceName
	Instantiate(*context.T, ApplicationInstantiateServerCall) (string, error)
	// Delete deletes an instance.  Once deleted, the instance cannot be
	// revived.
	// The instance must be in state NotRunning.
	//
	// If called against a Device, causes the Device to shut itself down.
	Delete(*context.T, rpc.ServerCall) error
	// Run begins execution of an application instance.
	// The instance must be in state NotRunning.
	Run(*context.T, rpc.ServerCall) error
	// Kill attempts a clean shutdown an of application instance.
	// The instance must be in state Running.
	//
	// If the deadline is non-zero and the instance in question is still
	// running after the given deadline, shutdown of the instance is
	// enforced.
	//
	// If called against a Device, causes the Device to stop itself (which
	// may or may not result in a restart depending on the device manager
	// setup).
	Kill(_ *context.T, _ rpc.ServerCall, deadline time.Duration) error
	// Update updates an application installation's version to a new version
	// created from the envelope at the object name provided during Install.
	// If the new application envelope contains a different application
	// title, the update does not occur, and an error is returned.  The
	// installation must be in state Active.
	//
	// Update updates an application instance's version to the current
	// installation version.  The instance must be in state NotRunning.
	Update(*context.T, rpc.ServerCall) error
	// UpdateTo updates the application installation(s) to the application
	// specified by the object name argument.  If the new application
	// envelope contains a different application title, the update does not
	// occur, and an error is returned.
	// The installation must be in state Active.
	UpdateTo(_ *context.T, _ rpc.ServerCall, name string) error
	// Revert reverts an application installation's version to the previous
	// version of its current version.  The installation must be in state
	// Active.
	//
	// Revert reverts an application instance's version to the previous
	// version of its current version.  The instance must be in state
	// NotRunning.
	Revert(*context.T, rpc.ServerCall) error
	// Debug returns debug information about the application installation or
	// instance.  This is generally highly implementation-specific, and
	// presented in an unstructured form.  No guarantees are given about the
	// stability of the format, and parsing it programmatically is
	// specifically discouraged.
	Debug(*context.T, rpc.ServerCall) (string, error)
	// Status returns structured information about the application
	// installation or instance.
	Status(*context.T, rpc.ServerCall) (Status, error)
}

// ApplicationServerStubMethods is the server interface containing
// Application methods, as expected by rpc.Server.
// The only difference between this interface and ApplicationServerMethods
// is the streaming methods.
type ApplicationServerStubMethods interface {
	// Object provides access control for Vanadium objects.
	//
	// Vanadium services implementing dynamic access control would typically embed
	// this interface and tag additional methods defined by the service with one of
	// Admin, Read, Write, Resolve etc. For example, the VDL definition of the
	// object would be:
	//
	//   package mypackage
	//
	//   import "v.io/v23/security/access"
	//   import "v.io/v23/services/permissions"
	//
	//   type MyObject interface {
	//     permissions.Object
	//     MyRead() (string, error) {access.Read}
	//     MyWrite(string) error    {access.Write}
	//   }
	//
	// If the set of pre-defined tags is insufficient, services may define their
	// own tag type and annotate all methods with this new type.
	//
	// Instead of embedding this Object interface, define SetPermissions and
	// GetPermissions in their own interface. Authorization policies will typically
	// respect annotations of a single type. For example, the VDL definition of an
	// object would be:
	//
	//  package mypackage
	//
	//  import "v.io/v23/security/access"
	//
	//  type MyTag string
	//
	//  const (
	//    Blue = MyTag("Blue")
	//    Red  = MyTag("Red")
	//  )
	//
	//  type MyObject interface {
	//    MyMethod() (string, error) {Blue}
	//
	//    // Allow clients to change access via the access.Object interface:
	//    SetPermissions(perms access.Permissions, version string) error         {Red}
	//    GetPermissions() (perms access.Permissions, version string, err error) {Blue}
	//  }
	permissions.ObjectServerStubMethods
	// Install installs the application identified by the first argument and
	// returns an object name suffix that identifies the new installation.
	//
	// The name argument should be an object name for an application
	// envelope.  The service it identifies must implement
	// repository.Application, and is expected to return either the
	// requested version (if the object name encodes a specific version), or
	// otherwise the latest available version, as appropriate.  This object
	// name will be used by default by the Update method, as a source for
	// updated application envelopes (can be overriden by setting
	// AppOriginConfigKey in the config).
	//
	// The config argument specifies config settings that will take
	// precedence over those present in the application envelope.
	//
	// The packages argument specifies packages to be installed in addition
	// to those specified in the envelope.  If a package in the envelope has
	// the same key, the package in the packages argument takes precedence.
	//
	// The returned suffix, when appended to the name used to reach the
	// receiver for Install, can be used to control the installation object.
	// The suffix will contain the title of the application as a prefix,
	// which can then be used to control all the installations of the given
	// application.
	// TODO(rjkroege): Use customized labels.
	Install(_ *context.T, _ rpc.ServerCall, name string, config Config, packages application.Packages) (string, error)
	// Uninstall uninstalls an application installation.
	// The installation must be in state Active.
	Uninstall(*context.T, rpc.ServerCall) error
	// Instantiate creates an instance of an application installation.
	// The installation must be in state Active.
	//
	// The server sends the application instance's Public Key on the stream.
	// When the client receives the Public Key it must send Blessings back
	// to the server. When the instance is created, the server returns the
	// instance name to the client.
	//
	// Client                       Server
	//  "object".Instantiate() -->
	//                         <--  InstancePublicKey
	//  AppBlessings           -->
	//                         <--  return InstanceName
	Instantiate(*context.T, *ApplicationInstantiateServerCallStub) (string, error)
	// Delete deletes an instance.  Once deleted, the instance cannot be
	// revived.
	// The instance must be in state NotRunning.
	//
	// If called against a Device, causes the Device to shut itself down.
	Delete(*context.T, rpc.ServerCall) error
	// Run begins execution of an application instance.
	// The instance must be in state NotRunning.
	Run(*context.T, rpc.ServerCall) error
	// Kill attempts a clean shutdown an of application instance.
	// The instance must be in state Running.
	//
	// If the deadline is non-zero and the instance in question is still
	// running after the given deadline, shutdown of the instance is
	// enforced.
	//
	// If called against a Device, causes the Device to stop itself (which
	// may or may not result in a restart depending on the device manager
	// setup).
	Kill(_ *context.T, _ rpc.ServerCall, deadline time.Duration) error
	// Update updates an application installation's version to a new version
	// created from the envelope at the object name provided during Install.
	// If the new application envelope contains a different application
	// title, the update does not occur, and an error is returned.  The
	// installation must be in state Active.
	//
	// Update updates an application instance's version to the current
	// installation version.  The instance must be in state NotRunning.
	Update(*context.T, rpc.ServerCall) error
	// UpdateTo updates the application installation(s) to the application
	// specified by the object name argument.  If the new application
	// envelope contains a different application title, the update does not
	// occur, and an error is returned.
	// The installation must be in state Active.
	UpdateTo(_ *context.T, _ rpc.ServerCall, name string) error
	// Revert reverts an application installation's version to the previous
	// version of its current version.  The installation must be in state
	// Active.
	//
	// Revert reverts an application instance's version to the previous
	// version of its current version.  The instance must be in state
	// NotRunning.
	Revert(*context.T, rpc.ServerCall) error
	// Debug returns debug information about the application installation or
	// instance.  This is generally highly implementation-specific, and
	// presented in an unstructured form.  No guarantees are given about the
	// stability of the format, and parsing it programmatically is
	// specifically discouraged.
	Debug(*context.T, rpc.ServerCall) (string, error)
	// Status returns structured information about the application
	// installation or instance.
	Status(*context.T, rpc.ServerCall) (Status, error)
}

// ApplicationServerStub adds universal methods to ApplicationServerStubMethods.
type ApplicationServerStub interface {
	ApplicationServerStubMethods
	// Describe the Application interfaces.
	Describe__() []rpc.InterfaceDesc
}

// ApplicationServer returns a server stub for Application.
// It converts an implementation of ApplicationServerMethods into
// an object that may be used by rpc.Server.
func ApplicationServer(impl ApplicationServerMethods) ApplicationServerStub {
	stub := implApplicationServerStub{
		impl:             impl,
		ObjectServerStub: permissions.ObjectServer(impl),
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implApplicationServerStub struct {
	impl ApplicationServerMethods
	permissions.ObjectServerStub
	gs *rpc.GlobState
}

func (s implApplicationServerStub) Install(ctx *context.T, call rpc.ServerCall, i0 string, i1 Config, i2 application.Packages) (string, error) {
	return s.impl.Install(ctx, call, i0, i1, i2)
}

func (s implApplicationServerStub) Uninstall(ctx *context.T, call rpc.ServerCall) error {
	return s.impl.Uninstall(ctx, call)
}

func (s implApplicationServerStub) Instantiate(ctx *context.T, call *ApplicationInstantiateServerCallStub) (string, error) {
	return s.impl.Instantiate(ctx, call)
}

func (s implApplicationServerStub) Delete(ctx *context.T, call rpc.ServerCall) error {
	return s.impl.Delete(ctx, call)
}

func (s implApplicationServerStub) Run(ctx *context.T, call rpc.ServerCall) error {
	return s.impl.Run(ctx, call)
}

func (s implApplicationServerStub) Kill(ctx *context.T, call rpc.ServerCall, i0 time.Duration) error {
	return s.impl.Kill(ctx, call, i0)
}

func (s implApplicationServerStub) Update(ctx *context.T, call rpc.ServerCall) error {
	return s.impl.Update(ctx, call)
}

func (s implApplicationServerStub) UpdateTo(ctx *context.T, call rpc.ServerCall, i0 string) error {
	return s.impl.UpdateTo(ctx, call, i0)
}

func (s implApplicationServerStub) Revert(ctx *context.T, call rpc.ServerCall) error {
	return s.impl.Revert(ctx, call)
}

func (s implApplicationServerStub) Debug(ctx *context.T, call rpc.ServerCall) (string, error) {
	return s.impl.Debug(ctx, call)
}

func (s implApplicationServerStub) Status(ctx *context.T, call rpc.ServerCall) (Status, error) {
	return s.impl.Status(ctx, call)
}

func (s implApplicationServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implApplicationServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{ApplicationDesc, permissions.ObjectDesc}
}

// ApplicationDesc describes the Application interface.
var ApplicationDesc rpc.InterfaceDesc = descApplication

// descApplication hides the desc to keep godoc clean.
var descApplication = rpc.InterfaceDesc{
	Name:    "Application",
	PkgPath: "v.io/v23/services/device",
	Doc:     "// Application can be used to manage applications on a device. This interface\n// will be invoked using an object name that identifies the application and its\n// installations and instances where applicable.\n//\n// An application is defined by a title.  An application can have multiple\n// installations on a device.  The installations are grouped under the same\n// application, but are otherwise independent of each other.  Each installation\n// can have zero or more instances (which can be running or not).  The instances\n// are independent of each other, and do not share state (like local storage).\n// Interaction among instances should occur via Vanadium RPC, facilitated by the\n// local mounttable.\n//\n// The device manager supports versioning of applications.  Each installation\n// maintains a tree of versions, where a version is defined by a specific\n// envelope.  The tree structure comes from 'previous version' references: each\n// version (except the initial installation version) maintains a reference to\n// the version that preceded it.  The installation maintains a current version\n// reference that is used for new instances.  Each update operation on the\n// installation creates a new version, sets the previous reference of the new\n// version to the current version, and then updates the current version to refer\n// to the new version.  Each revert operation on the installation sets the\n// current version to the previous version of the current version.  Each\n// instance maintains a current version reference that is used to run the\n// instance.  The initial version of the instance is set to the current version\n// of the installation at the time of instantiation.  Each update operation on\n// the instance updates the instance's current version to the current version of\n// the installation.  Each revert operation on the instance updates the\n// instance's current version to the previous version of the instance's version.\n//\n// The Application interface methods can be divided based on their intended\n// receiver:\n//\n// 1) Method receiver is an application:\n//     - Install()\n//\n// 2) Method receiver is an application installation:\n//     - Instantiate()\n//     - Uninstall()\n//\n// 3) Method receiver is an application instance:\n//     - Run()\n//     - Kill()\n//     - Delete()\n//\n// 4) Method receiver is an application installation or instance:\n//     - Update()\n//     - Revert()\n//\n// The following methods complement one another:\n//     - Install() and Uninstall()\n//     - Instantiate() and Delete()\n//     - Run() and Kill()\n//     - Update() and Revert()\n//\n//\n//\n// Examples:\n//\n// Install Google Maps on the device.\n//     device/apps.Install(\"/google.com/appstore/maps\", nil, nil) --> \"google maps/0\"\n//\n// Create and start an instance of the previously installed maps application\n// installation.\n//    device/apps/google maps/0.Instantiate() --> { \"0\" }\n//    device/apps/google maps/0/0.Run()\n//\n// Create and start a second instance of the previously installed maps\n// application installation.\n//    device/apps/google maps/0.Instantiate() --> { \"1\" }\n//    device/apps/google maps/0/1.Run()\n//\n// Kill and delete the first instance previously started.\n//    device/apps/google maps/0/0.Kill()\n//    device/apps/google maps/0/0.Delete()\n//\n// Install a second Google Maps installation.\n//    device/apps.Install(\"/google.com/appstore/maps\", nil, nil) --> \"google maps/1\"\n//\n// Update the second maps installation to the latest version available.\n//    device/apps/google maps/1.Update()\n//\n// Update the first maps installation to a specific version.\n//    device/apps/google maps/0.UpdateTo(\"/google.com/appstore/beta/maps\")\n//\n// Finally, an application installation instance can be in one of three abstract\n// states: 1) \"does not exist/deleted\", 2) \"running\", or 3) \"not-running\". The\n// interface methods transition between these abstract states using the\n// following state machine:\n//\n//    apply(Instantiate(), \"does not exist\") = \"not-running\"\n//    apply(Run(), \"not-running\") = \"running\"\n//    apply(Kill(), \"running\") = \"not-running\"\n//    apply(Delete(), \"not-running\") = \"deleted\"",
	Embeds: []rpc.EmbedDesc{
		{Name: "Object", PkgPath: "v.io/v23/services/permissions", Doc: "// Object provides access control for Vanadium objects.\n//\n// Vanadium services implementing dynamic access control would typically embed\n// this interface and tag additional methods defined by the service with one of\n// Admin, Read, Write, Resolve etc. For example, the VDL definition of the\n// object would be:\n//\n//   package mypackage\n//\n//   import \"v.io/v23/security/access\"\n//   import \"v.io/v23/services/permissions\"\n//\n//   type MyObject interface {\n//     permissions.Object\n//     MyRead() (string, error) {access.Read}\n//     MyWrite(string) error    {access.Write}\n//   }\n//\n// If the set of pre-defined tags is insufficient, services may define their\n// own tag type and annotate all methods with this new type.\n//\n// Instead of embedding this Object interface, define SetPermissions and\n// GetPermissions in their own interface. Authorization policies will typically\n// respect annotations of a single type. For example, the VDL definition of an\n// object would be:\n//\n//  package mypackage\n//\n//  import \"v.io/v23/security/access\"\n//\n//  type MyTag string\n//\n//  const (\n//    Blue = MyTag(\"Blue\")\n//    Red  = MyTag(\"Red\")\n//  )\n//\n//  type MyObject interface {\n//    MyMethod() (string, error) {Blue}\n//\n//    // Allow clients to change access via the access.Object interface:\n//    SetPermissions(perms access.Permissions, version string) error         {Red}\n//    GetPermissions() (perms access.Permissions, version string, err error) {Blue}\n//  }"},
	},
	Methods: []rpc.MethodDesc{
		{
			Name: "Install",
			Doc:  "// Install installs the application identified by the first argument and\n// returns an object name suffix that identifies the new installation.\n//\n// The name argument should be an object name for an application\n// envelope.  The service it identifies must implement\n// repository.Application, and is expected to return either the\n// requested version (if the object name encodes a specific version), or\n// otherwise the latest available version, as appropriate.  This object\n// name will be used by default by the Update method, as a source for\n// updated application envelopes (can be overriden by setting\n// AppOriginConfigKey in the config).\n//\n// The config argument specifies config settings that will take\n// precedence over those present in the application envelope.\n//\n// The packages argument specifies packages to be installed in addition\n// to those specified in the envelope.  If a package in the envelope has\n// the same key, the package in the packages argument takes precedence.\n//\n// The returned suffix, when appended to the name used to reach the\n// receiver for Install, can be used to control the installation object.\n// The suffix will contain the title of the application as a prefix,\n// which can then be used to control all the installations of the given\n// application.\n// TODO(rjkroege): Use customized labels.",
			InArgs: []rpc.ArgDesc{
				{Name: "name", Doc: ``},     // string
				{Name: "config", Doc: ``},   // Config
				{Name: "packages", Doc: ``}, // application.Packages
			},
			OutArgs: []rpc.ArgDesc{
				{Name: "", Doc: ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Write"))},
		},
		{
			Name: "Uninstall",
			Doc:  "// Uninstall uninstalls an application installation.\n// The installation must be in state Active.",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "Instantiate",
			Doc:  "// Instantiate creates an instance of an application installation.\n// The installation must be in state Active.\n//\n// The server sends the application instance's Public Key on the stream.\n// When the client receives the Public Key it must send Blessings back\n// to the server. When the instance is created, the server returns the\n// instance name to the client.\n//\n// Client                       Server\n//  \"object\".Instantiate() -->\n//                         <--  InstancePublicKey\n//  AppBlessings           -->\n//                         <--  return InstanceName",
			OutArgs: []rpc.ArgDesc{
				{Name: "", Doc: ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Read"))},
		},
		{
			Name: "Delete",
			Doc:  "// Delete deletes an instance.  Once deleted, the instance cannot be\n// revived.\n// The instance must be in state NotRunning.\n//\n// If called against a Device, causes the Device to shut itself down.",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "Run",
			Doc:  "// Run begins execution of an application instance.\n// The instance must be in state NotRunning.",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Write"))},
		},
		{
			Name: "Kill",
			Doc:  "// Kill attempts a clean shutdown an of application instance.\n// The instance must be in state Running.\n//\n// If the deadline is non-zero and the instance in question is still\n// running after the given deadline, shutdown of the instance is\n// enforced.\n//\n// If called against a Device, causes the Device to stop itself (which\n// may or may not result in a restart depending on the device manager\n// setup).",
			InArgs: []rpc.ArgDesc{
				{Name: "deadline", Doc: ``}, // time.Duration
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Write"))},
		},
		{
			Name: "Update",
			Doc:  "// Update updates an application installation's version to a new version\n// created from the envelope at the object name provided during Install.\n// If the new application envelope contains a different application\n// title, the update does not occur, and an error is returned.  The\n// installation must be in state Active.\n//\n// Update updates an application instance's version to the current\n// installation version.  The instance must be in state NotRunning.",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "UpdateTo",
			Doc:  "// UpdateTo updates the application installation(s) to the application\n// specified by the object name argument.  If the new application\n// envelope contains a different application title, the update does not\n// occur, and an error is returned.\n// The installation must be in state Active.",
			InArgs: []rpc.ArgDesc{
				{Name: "name", Doc: ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "Revert",
			Doc:  "// Revert reverts an application installation's version to the previous\n// version of its current version.  The installation must be in state\n// Active.\n//\n// Revert reverts an application instance's version to the previous\n// version of its current version.  The instance must be in state\n// NotRunning.",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "Debug",
			Doc:  "// Debug returns debug information about the application installation or\n// instance.  This is generally highly implementation-specific, and\n// presented in an unstructured form.  No guarantees are given about the\n// stability of the format, and parsing it programmatically is\n// specifically discouraged.",
			OutArgs: []rpc.ArgDesc{
				{Name: "", Doc: ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Debug"))},
		},
		{
			Name: "Status",
			Doc:  "// Status returns structured information about the application\n// installation or instance.",
			OutArgs: []rpc.ArgDesc{
				{Name: "", Doc: ``}, // Status
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Read"))},
		},
	},
}

// ApplicationInstantiateServerStream is the server stream for Application.Instantiate.
type ApplicationInstantiateServerStream interface {
	// RecvStream returns the receiver side of the Application.Instantiate server stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() BlessClientMessage
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the Application.Instantiate server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item BlessServerMessage) error
	}
}

// ApplicationInstantiateServerCall represents the context passed to Application.Instantiate.
type ApplicationInstantiateServerCall interface {
	rpc.ServerCall
	ApplicationInstantiateServerStream
}

// ApplicationInstantiateServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements ApplicationInstantiateServerCall.
type ApplicationInstantiateServerCallStub struct {
	rpc.StreamServerCall
	valRecv BlessClientMessage
	errRecv error
}

// Init initializes ApplicationInstantiateServerCallStub from rpc.StreamServerCall.
func (s *ApplicationInstantiateServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// RecvStream returns the receiver side of the Application.Instantiate server stream.
func (s *ApplicationInstantiateServerCallStub) RecvStream() interface {
	Advance() bool
	Value() BlessClientMessage
	Err() error
} {
	return implApplicationInstantiateServerCallRecv{s}
}

type implApplicationInstantiateServerCallRecv struct {
	s *ApplicationInstantiateServerCallStub
}

func (s implApplicationInstantiateServerCallRecv) Advance() bool {
	s.s.errRecv = s.s.Recv(&s.s.valRecv)
	return s.s.errRecv == nil
}
func (s implApplicationInstantiateServerCallRecv) Value() BlessClientMessage {
	return s.s.valRecv
}
func (s implApplicationInstantiateServerCallRecv) Err() error {
	if s.s.errRecv == io.EOF {
		return nil
	}
	return s.s.errRecv
}

// SendStream returns the send side of the Application.Instantiate server stream.
func (s *ApplicationInstantiateServerCallStub) SendStream() interface {
	Send(item BlessServerMessage) error
} {
	return implApplicationInstantiateServerCallSend{s}
}

type implApplicationInstantiateServerCallSend struct {
	s *ApplicationInstantiateServerCallStub
}

func (s implApplicationInstantiateServerCallSend) Send(item BlessServerMessage) error {
	return s.s.Send(item)
}

// ClaimableClientMethods is the client interface
// containing Claimable methods.
//
// Claimable represents an uninitialized device with no owner
// (i.e., a device that has no blessings).
//
// Claim is used to claim ownership by blessing the device's private key.
// Devices that have provided a pairing token to the claimer through an
// out-of-band communication channel (eg: display/email) would expect this
// pairing token to be replayed by the claimer.
//
// Once claimed, the device will export the "Device" interface and all methods
// will be restricted to the claimer.
//
// The blessings that the device is to be claimed with is provided
// via the ipc.Granter option in Go.
type ClaimableClientMethods interface {
	Claim(_ *context.T, pairingToken string, _ ...rpc.CallOpt) error
}

// ClaimableClientStub adds universal methods to ClaimableClientMethods.
type ClaimableClientStub interface {
	ClaimableClientMethods
	rpc.UniversalServiceMethods
}

// ClaimableClient returns a client stub for Claimable.
func ClaimableClient(name string) ClaimableClientStub {
	return implClaimableClientStub{name}
}

type implClaimableClientStub struct {
	name string
}

func (c implClaimableClientStub) Claim(ctx *context.T, i0 string, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Claim", []interface{}{i0}, nil, opts...)
	return
}

// ClaimableServerMethods is the interface a server writer
// implements for Claimable.
//
// Claimable represents an uninitialized device with no owner
// (i.e., a device that has no blessings).
//
// Claim is used to claim ownership by blessing the device's private key.
// Devices that have provided a pairing token to the claimer through an
// out-of-band communication channel (eg: display/email) would expect this
// pairing token to be replayed by the claimer.
//
// Once claimed, the device will export the "Device" interface and all methods
// will be restricted to the claimer.
//
// The blessings that the device is to be claimed with is provided
// via the ipc.Granter option in Go.
type ClaimableServerMethods interface {
	Claim(_ *context.T, _ rpc.ServerCall, pairingToken string) error
}

// ClaimableServerStubMethods is the server interface containing
// Claimable methods, as expected by rpc.Server.
// There is no difference between this interface and ClaimableServerMethods
// since there are no streaming methods.
type ClaimableServerStubMethods ClaimableServerMethods

// ClaimableServerStub adds universal methods to ClaimableServerStubMethods.
type ClaimableServerStub interface {
	ClaimableServerStubMethods
	// Describe the Claimable interfaces.
	Describe__() []rpc.InterfaceDesc
}

// ClaimableServer returns a server stub for Claimable.
// It converts an implementation of ClaimableServerMethods into
// an object that may be used by rpc.Server.
func ClaimableServer(impl ClaimableServerMethods) ClaimableServerStub {
	stub := implClaimableServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implClaimableServerStub struct {
	impl ClaimableServerMethods
	gs   *rpc.GlobState
}

func (s implClaimableServerStub) Claim(ctx *context.T, call rpc.ServerCall, i0 string) error {
	return s.impl.Claim(ctx, call, i0)
}

func (s implClaimableServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implClaimableServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{ClaimableDesc}
}

// ClaimableDesc describes the Claimable interface.
var ClaimableDesc rpc.InterfaceDesc = descClaimable

// descClaimable hides the desc to keep godoc clean.
var descClaimable = rpc.InterfaceDesc{
	Name:    "Claimable",
	PkgPath: "v.io/v23/services/device",
	Doc:     "// Claimable represents an uninitialized device with no owner\n// (i.e., a device that has no blessings).\n//\n// Claim is used to claim ownership by blessing the device's private key.\n// Devices that have provided a pairing token to the claimer through an\n// out-of-band communication channel (eg: display/email) would expect this\n// pairing token to be replayed by the claimer.\n//\n// Once claimed, the device will export the \"Device\" interface and all methods\n// will be restricted to the claimer.\n//\n// The blessings that the device is to be claimed with is provided\n// via the ipc.Granter option in Go.",
	Methods: []rpc.MethodDesc{
		{
			Name: "Claim",
			InArgs: []rpc.ArgDesc{
				{Name: "pairingToken", Doc: ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
	},
}

// DeviceClientMethods is the client interface
// containing Device methods.
//
// Device can be used to manage a device remotely using an object name that
// identifies it.
type DeviceClientMethods interface {
	// Application can be used to manage applications on a device. This interface
	// will be invoked using an object name that identifies the application and its
	// installations and instances where applicable.
	//
	// An application is defined by a title.  An application can have multiple
	// installations on a device.  The installations are grouped under the same
	// application, but are otherwise independent of each other.  Each installation
	// can have zero or more instances (which can be running or not).  The instances
	// are independent of each other, and do not share state (like local storage).
	// Interaction among instances should occur via Vanadium RPC, facilitated by the
	// local mounttable.
	//
	// The device manager supports versioning of applications.  Each installation
	// maintains a tree of versions, where a version is defined by a specific
	// envelope.  The tree structure comes from 'previous version' references: each
	// version (except the initial installation version) maintains a reference to
	// the version that preceded it.  The installation maintains a current version
	// reference that is used for new instances.  Each update operation on the
	// installation creates a new version, sets the previous reference of the new
	// version to the current version, and then updates the current version to refer
	// to the new version.  Each revert operation on the installation sets the
	// current version to the previous version of the current version.  Each
	// instance maintains a current version reference that is used to run the
	// instance.  The initial version of the instance is set to the current version
	// of the installation at the time of instantiation.  Each update operation on
	// the instance updates the instance's current version to the current version of
	// the installation.  Each revert operation on the instance updates the
	// instance's current version to the previous version of the instance's version.
	//
	// The Application interface methods can be divided based on their intended
	// receiver:
	//
	// 1) Method receiver is an application:
	//     - Install()
	//
	// 2) Method receiver is an application installation:
	//     - Instantiate()
	//     - Uninstall()
	//
	// 3) Method receiver is an application instance:
	//     - Run()
	//     - Kill()
	//     - Delete()
	//
	// 4) Method receiver is an application installation or instance:
	//     - Update()
	//     - Revert()
	//
	// The following methods complement one another:
	//     - Install() and Uninstall()
	//     - Instantiate() and Delete()
	//     - Run() and Kill()
	//     - Update() and Revert()
	//
	//
	//
	// Examples:
	//
	// Install Google Maps on the device.
	//     device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/0"
	//
	// Create and start an instance of the previously installed maps application
	// installation.
	//    device/apps/google maps/0.Instantiate() --> { "0" }
	//    device/apps/google maps/0/0.Run()
	//
	// Create and start a second instance of the previously installed maps
	// application installation.
	//    device/apps/google maps/0.Instantiate() --> { "1" }
	//    device/apps/google maps/0/1.Run()
	//
	// Kill and delete the first instance previously started.
	//    device/apps/google maps/0/0.Kill()
	//    device/apps/google maps/0/0.Delete()
	//
	// Install a second Google Maps installation.
	//    device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/1"
	//
	// Update the second maps installation to the latest version available.
	//    device/apps/google maps/1.Update()
	//
	// Update the first maps installation to a specific version.
	//    device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
	//
	// Finally, an application installation instance can be in one of three abstract
	// states: 1) "does not exist/deleted", 2) "running", or 3) "not-running". The
	// interface methods transition between these abstract states using the
	// following state machine:
	//
	//    apply(Instantiate(), "does not exist") = "not-running"
	//    apply(Run(), "not-running") = "running"
	//    apply(Kill(), "running") = "not-running"
	//    apply(Delete(), "not-running") = "deleted"
	ApplicationClientMethods
	// Tidyable specifies that a service can be tidied.
	tidyable.TidyableClientMethods
	// Describe generates a description of the device.
	Describe(*context.T, ...rpc.CallOpt) (Description, error)
	// IsRunnable checks if the device can execute the given binary.
	IsRunnable(_ *context.T, description binary.Description, _ ...rpc.CallOpt) (bool, error)
	// Reset resets the device. If the deadline is non-zero and the device
	// in question is still running after the given deadline expired,
	// reset of the device is enforced.
	Reset(_ *context.T, deadline time.Duration, _ ...rpc.CallOpt) error
	// AssociateAccount associates a local  system account name with the provided
	// Vanadium identities. It replaces the existing association if one already exists for that
	// identity. Setting an AccountName to "" removes the association for each
	// listed identity.
	AssociateAccount(_ *context.T, identityNames []string, accountName string, _ ...rpc.CallOpt) error
	// ListAssociations returns all of the associations between Vanadium identities
	// and system names.
	ListAssociations(*context.T, ...rpc.CallOpt) ([]Association, error)
}

// DeviceClientStub adds universal methods to DeviceClientMethods.
type DeviceClientStub interface {
	DeviceClientMethods
	rpc.UniversalServiceMethods
}

// DeviceClient returns a client stub for Device.
func DeviceClient(name string) DeviceClientStub {
	return implDeviceClientStub{name, ApplicationClient(name), tidyable.TidyableClient(name)}
}

type implDeviceClientStub struct {
	name string

	ApplicationClientStub
	tidyable.TidyableClientStub
}

func (c implDeviceClientStub) Describe(ctx *context.T, opts ...rpc.CallOpt) (o0 Description, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Describe", nil, []interface{}{&o0}, opts...)
	return
}

func (c implDeviceClientStub) IsRunnable(ctx *context.T, i0 binary.Description, opts ...rpc.CallOpt) (o0 bool, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "IsRunnable", []interface{}{i0}, []interface{}{&o0}, opts...)
	return
}

func (c implDeviceClientStub) Reset(ctx *context.T, i0 time.Duration, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "Reset", []interface{}{i0}, nil, opts...)
	return
}

func (c implDeviceClientStub) AssociateAccount(ctx *context.T, i0 []string, i1 string, opts ...rpc.CallOpt) (err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "AssociateAccount", []interface{}{i0, i1}, nil, opts...)
	return
}

func (c implDeviceClientStub) ListAssociations(ctx *context.T, opts ...rpc.CallOpt) (o0 []Association, err error) {
	err = v23.GetClient(ctx).Call(ctx, c.name, "ListAssociations", nil, []interface{}{&o0}, opts...)
	return
}

// DeviceServerMethods is the interface a server writer
// implements for Device.
//
// Device can be used to manage a device remotely using an object name that
// identifies it.
type DeviceServerMethods interface {
	// Application can be used to manage applications on a device. This interface
	// will be invoked using an object name that identifies the application and its
	// installations and instances where applicable.
	//
	// An application is defined by a title.  An application can have multiple
	// installations on a device.  The installations are grouped under the same
	// application, but are otherwise independent of each other.  Each installation
	// can have zero or more instances (which can be running or not).  The instances
	// are independent of each other, and do not share state (like local storage).
	// Interaction among instances should occur via Vanadium RPC, facilitated by the
	// local mounttable.
	//
	// The device manager supports versioning of applications.  Each installation
	// maintains a tree of versions, where a version is defined by a specific
	// envelope.  The tree structure comes from 'previous version' references: each
	// version (except the initial installation version) maintains a reference to
	// the version that preceded it.  The installation maintains a current version
	// reference that is used for new instances.  Each update operation on the
	// installation creates a new version, sets the previous reference of the new
	// version to the current version, and then updates the current version to refer
	// to the new version.  Each revert operation on the installation sets the
	// current version to the previous version of the current version.  Each
	// instance maintains a current version reference that is used to run the
	// instance.  The initial version of the instance is set to the current version
	// of the installation at the time of instantiation.  Each update operation on
	// the instance updates the instance's current version to the current version of
	// the installation.  Each revert operation on the instance updates the
	// instance's current version to the previous version of the instance's version.
	//
	// The Application interface methods can be divided based on their intended
	// receiver:
	//
	// 1) Method receiver is an application:
	//     - Install()
	//
	// 2) Method receiver is an application installation:
	//     - Instantiate()
	//     - Uninstall()
	//
	// 3) Method receiver is an application instance:
	//     - Run()
	//     - Kill()
	//     - Delete()
	//
	// 4) Method receiver is an application installation or instance:
	//     - Update()
	//     - Revert()
	//
	// The following methods complement one another:
	//     - Install() and Uninstall()
	//     - Instantiate() and Delete()
	//     - Run() and Kill()
	//     - Update() and Revert()
	//
	//
	//
	// Examples:
	//
	// Install Google Maps on the device.
	//     device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/0"
	//
	// Create and start an instance of the previously installed maps application
	// installation.
	//    device/apps/google maps/0.Instantiate() --> { "0" }
	//    device/apps/google maps/0/0.Run()
	//
	// Create and start a second instance of the previously installed maps
	// application installation.
	//    device/apps/google maps/0.Instantiate() --> { "1" }
	//    device/apps/google maps/0/1.Run()
	//
	// Kill and delete the first instance previously started.
	//    device/apps/google maps/0/0.Kill()
	//    device/apps/google maps/0/0.Delete()
	//
	// Install a second Google Maps installation.
	//    device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/1"
	//
	// Update the second maps installation to the latest version available.
	//    device/apps/google maps/1.Update()
	//
	// Update the first maps installation to a specific version.
	//    device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
	//
	// Finally, an application installation instance can be in one of three abstract
	// states: 1) "does not exist/deleted", 2) "running", or 3) "not-running". The
	// interface methods transition between these abstract states using the
	// following state machine:
	//
	//    apply(Instantiate(), "does not exist") = "not-running"
	//    apply(Run(), "not-running") = "running"
	//    apply(Kill(), "running") = "not-running"
	//    apply(Delete(), "not-running") = "deleted"
	ApplicationServerMethods
	// Tidyable specifies that a service can be tidied.
	tidyable.TidyableServerMethods
	// Describe generates a description of the device.
	Describe(*context.T, rpc.ServerCall) (Description, error)
	// IsRunnable checks if the device can execute the given binary.
	IsRunnable(_ *context.T, _ rpc.ServerCall, description binary.Description) (bool, error)
	// Reset resets the device. If the deadline is non-zero and the device
	// in question is still running after the given deadline expired,
	// reset of the device is enforced.
	Reset(_ *context.T, _ rpc.ServerCall, deadline time.Duration) error
	// AssociateAccount associates a local  system account name with the provided
	// Vanadium identities. It replaces the existing association if one already exists for that
	// identity. Setting an AccountName to "" removes the association for each
	// listed identity.
	AssociateAccount(_ *context.T, _ rpc.ServerCall, identityNames []string, accountName string) error
	// ListAssociations returns all of the associations between Vanadium identities
	// and system names.
	ListAssociations(*context.T, rpc.ServerCall) ([]Association, error)
}

// DeviceServerStubMethods is the server interface containing
// Device methods, as expected by rpc.Server.
// The only difference between this interface and DeviceServerMethods
// is the streaming methods.
type DeviceServerStubMethods interface {
	// Application can be used to manage applications on a device. This interface
	// will be invoked using an object name that identifies the application and its
	// installations and instances where applicable.
	//
	// An application is defined by a title.  An application can have multiple
	// installations on a device.  The installations are grouped under the same
	// application, but are otherwise independent of each other.  Each installation
	// can have zero or more instances (which can be running or not).  The instances
	// are independent of each other, and do not share state (like local storage).
	// Interaction among instances should occur via Vanadium RPC, facilitated by the
	// local mounttable.
	//
	// The device manager supports versioning of applications.  Each installation
	// maintains a tree of versions, where a version is defined by a specific
	// envelope.  The tree structure comes from 'previous version' references: each
	// version (except the initial installation version) maintains a reference to
	// the version that preceded it.  The installation maintains a current version
	// reference that is used for new instances.  Each update operation on the
	// installation creates a new version, sets the previous reference of the new
	// version to the current version, and then updates the current version to refer
	// to the new version.  Each revert operation on the installation sets the
	// current version to the previous version of the current version.  Each
	// instance maintains a current version reference that is used to run the
	// instance.  The initial version of the instance is set to the current version
	// of the installation at the time of instantiation.  Each update operation on
	// the instance updates the instance's current version to the current version of
	// the installation.  Each revert operation on the instance updates the
	// instance's current version to the previous version of the instance's version.
	//
	// The Application interface methods can be divided based on their intended
	// receiver:
	//
	// 1) Method receiver is an application:
	//     - Install()
	//
	// 2) Method receiver is an application installation:
	//     - Instantiate()
	//     - Uninstall()
	//
	// 3) Method receiver is an application instance:
	//     - Run()
	//     - Kill()
	//     - Delete()
	//
	// 4) Method receiver is an application installation or instance:
	//     - Update()
	//     - Revert()
	//
	// The following methods complement one another:
	//     - Install() and Uninstall()
	//     - Instantiate() and Delete()
	//     - Run() and Kill()
	//     - Update() and Revert()
	//
	//
	//
	// Examples:
	//
	// Install Google Maps on the device.
	//     device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/0"
	//
	// Create and start an instance of the previously installed maps application
	// installation.
	//    device/apps/google maps/0.Instantiate() --> { "0" }
	//    device/apps/google maps/0/0.Run()
	//
	// Create and start a second instance of the previously installed maps
	// application installation.
	//    device/apps/google maps/0.Instantiate() --> { "1" }
	//    device/apps/google maps/0/1.Run()
	//
	// Kill and delete the first instance previously started.
	//    device/apps/google maps/0/0.Kill()
	//    device/apps/google maps/0/0.Delete()
	//
	// Install a second Google Maps installation.
	//    device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/1"
	//
	// Update the second maps installation to the latest version available.
	//    device/apps/google maps/1.Update()
	//
	// Update the first maps installation to a specific version.
	//    device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
	//
	// Finally, an application installation instance can be in one of three abstract
	// states: 1) "does not exist/deleted", 2) "running", or 3) "not-running". The
	// interface methods transition between these abstract states using the
	// following state machine:
	//
	//    apply(Instantiate(), "does not exist") = "not-running"
	//    apply(Run(), "not-running") = "running"
	//    apply(Kill(), "running") = "not-running"
	//    apply(Delete(), "not-running") = "deleted"
	ApplicationServerStubMethods
	// Tidyable specifies that a service can be tidied.
	tidyable.TidyableServerStubMethods
	// Describe generates a description of the device.
	Describe(*context.T, rpc.ServerCall) (Description, error)
	// IsRunnable checks if the device can execute the given binary.
	IsRunnable(_ *context.T, _ rpc.ServerCall, description binary.Description) (bool, error)
	// Reset resets the device. If the deadline is non-zero and the device
	// in question is still running after the given deadline expired,
	// reset of the device is enforced.
	Reset(_ *context.T, _ rpc.ServerCall, deadline time.Duration) error
	// AssociateAccount associates a local  system account name with the provided
	// Vanadium identities. It replaces the existing association if one already exists for that
	// identity. Setting an AccountName to "" removes the association for each
	// listed identity.
	AssociateAccount(_ *context.T, _ rpc.ServerCall, identityNames []string, accountName string) error
	// ListAssociations returns all of the associations between Vanadium identities
	// and system names.
	ListAssociations(*context.T, rpc.ServerCall) ([]Association, error)
}

// DeviceServerStub adds universal methods to DeviceServerStubMethods.
type DeviceServerStub interface {
	DeviceServerStubMethods
	// Describe the Device interfaces.
	Describe__() []rpc.InterfaceDesc
}

// DeviceServer returns a server stub for Device.
// It converts an implementation of DeviceServerMethods into
// an object that may be used by rpc.Server.
func DeviceServer(impl DeviceServerMethods) DeviceServerStub {
	stub := implDeviceServerStub{
		impl:                  impl,
		ApplicationServerStub: ApplicationServer(impl),
		TidyableServerStub:    tidyable.TidyableServer(impl),
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implDeviceServerStub struct {
	impl DeviceServerMethods
	ApplicationServerStub
	tidyable.TidyableServerStub
	gs *rpc.GlobState
}

func (s implDeviceServerStub) Describe(ctx *context.T, call rpc.ServerCall) (Description, error) {
	return s.impl.Describe(ctx, call)
}

func (s implDeviceServerStub) IsRunnable(ctx *context.T, call rpc.ServerCall, i0 binary.Description) (bool, error) {
	return s.impl.IsRunnable(ctx, call, i0)
}

func (s implDeviceServerStub) Reset(ctx *context.T, call rpc.ServerCall, i0 time.Duration) error {
	return s.impl.Reset(ctx, call, i0)
}

func (s implDeviceServerStub) AssociateAccount(ctx *context.T, call rpc.ServerCall, i0 []string, i1 string) error {
	return s.impl.AssociateAccount(ctx, call, i0, i1)
}

func (s implDeviceServerStub) ListAssociations(ctx *context.T, call rpc.ServerCall) ([]Association, error) {
	return s.impl.ListAssociations(ctx, call)
}

func (s implDeviceServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implDeviceServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{DeviceDesc, ApplicationDesc, permissions.ObjectDesc, tidyable.TidyableDesc}
}

// DeviceDesc describes the Device interface.
var DeviceDesc rpc.InterfaceDesc = descDevice

// descDevice hides the desc to keep godoc clean.
var descDevice = rpc.InterfaceDesc{
	Name:    "Device",
	PkgPath: "v.io/v23/services/device",
	Doc:     "// Device can be used to manage a device remotely using an object name that\n// identifies it.",
	Embeds: []rpc.EmbedDesc{
		{Name: "Application", PkgPath: "v.io/v23/services/device", Doc: "// Application can be used to manage applications on a device. This interface\n// will be invoked using an object name that identifies the application and its\n// installations and instances where applicable.\n//\n// An application is defined by a title.  An application can have multiple\n// installations on a device.  The installations are grouped under the same\n// application, but are otherwise independent of each other.  Each installation\n// can have zero or more instances (which can be running or not).  The instances\n// are independent of each other, and do not share state (like local storage).\n// Interaction among instances should occur via Vanadium RPC, facilitated by the\n// local mounttable.\n//\n// The device manager supports versioning of applications.  Each installation\n// maintains a tree of versions, where a version is defined by a specific\n// envelope.  The tree structure comes from 'previous version' references: each\n// version (except the initial installation version) maintains a reference to\n// the version that preceded it.  The installation maintains a current version\n// reference that is used for new instances.  Each update operation on the\n// installation creates a new version, sets the previous reference of the new\n// version to the current version, and then updates the current version to refer\n// to the new version.  Each revert operation on the installation sets the\n// current version to the previous version of the current version.  Each\n// instance maintains a current version reference that is used to run the\n// instance.  The initial version of the instance is set to the current version\n// of the installation at the time of instantiation.  Each update operation on\n// the instance updates the instance's current version to the current version of\n// the installation.  Each revert operation on the instance updates the\n// instance's current version to the previous version of the instance's version.\n//\n// The Application interface methods can be divided based on their intended\n// receiver:\n//\n// 1) Method receiver is an application:\n//     - Install()\n//\n// 2) Method receiver is an application installation:\n//     - Instantiate()\n//     - Uninstall()\n//\n// 3) Method receiver is an application instance:\n//     - Run()\n//     - Kill()\n//     - Delete()\n//\n// 4) Method receiver is an application installation or instance:\n//     - Update()\n//     - Revert()\n//\n// The following methods complement one another:\n//     - Install() and Uninstall()\n//     - Instantiate() and Delete()\n//     - Run() and Kill()\n//     - Update() and Revert()\n//\n//\n//\n// Examples:\n//\n// Install Google Maps on the device.\n//     device/apps.Install(\"/google.com/appstore/maps\", nil, nil) --> \"google maps/0\"\n//\n// Create and start an instance of the previously installed maps application\n// installation.\n//    device/apps/google maps/0.Instantiate() --> { \"0\" }\n//    device/apps/google maps/0/0.Run()\n//\n// Create and start a second instance of the previously installed maps\n// application installation.\n//    device/apps/google maps/0.Instantiate() --> { \"1\" }\n//    device/apps/google maps/0/1.Run()\n//\n// Kill and delete the first instance previously started.\n//    device/apps/google maps/0/0.Kill()\n//    device/apps/google maps/0/0.Delete()\n//\n// Install a second Google Maps installation.\n//    device/apps.Install(\"/google.com/appstore/maps\", nil, nil) --> \"google maps/1\"\n//\n// Update the second maps installation to the latest version available.\n//    device/apps/google maps/1.Update()\n//\n// Update the first maps installation to a specific version.\n//    device/apps/google maps/0.UpdateTo(\"/google.com/appstore/beta/maps\")\n//\n// Finally, an application installation instance can be in one of three abstract\n// states: 1) \"does not exist/deleted\", 2) \"running\", or 3) \"not-running\". The\n// interface methods transition between these abstract states using the\n// following state machine:\n//\n//    apply(Instantiate(), \"does not exist\") = \"not-running\"\n//    apply(Run(), \"not-running\") = \"running\"\n//    apply(Kill(), \"running\") = \"not-running\"\n//    apply(Delete(), \"not-running\") = \"deleted\""},
		{Name: "Tidyable", PkgPath: "v.io/v23/services/tidyable", Doc: "// Tidyable specifies that a service can be tidied."},
	},
	Methods: []rpc.MethodDesc{
		{
			Name: "Describe",
			Doc:  "// Describe generates a description of the device.",
			OutArgs: []rpc.ArgDesc{
				{Name: "", Doc: ``}, // Description
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "IsRunnable",
			Doc:  "// IsRunnable checks if the device can execute the given binary.",
			InArgs: []rpc.ArgDesc{
				{Name: "description", Doc: ``}, // binary.Description
			},
			OutArgs: []rpc.ArgDesc{
				{Name: "", Doc: ``}, // bool
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "Reset",
			Doc:  "// Reset resets the device. If the deadline is non-zero and the device\n// in question is still running after the given deadline expired,\n// reset of the device is enforced.",
			InArgs: []rpc.ArgDesc{
				{Name: "deadline", Doc: ``}, // time.Duration
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "AssociateAccount",
			Doc:  "// AssociateAccount associates a local  system account name with the provided\n// Vanadium identities. It replaces the existing association if one already exists for that\n// identity. Setting an AccountName to \"\" removes the association for each\n// listed identity.",
			InArgs: []rpc.ArgDesc{
				{Name: "identityNames", Doc: ``}, // []string
				{Name: "accountName", Doc: ``},   // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "ListAssociations",
			Doc:  "// ListAssociations returns all of the associations between Vanadium identities\n// and system names.",
			OutArgs: []rpc.ArgDesc{
				{Name: "", Doc: ``}, // []Association
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
	},
}

// Hold type definitions in package-level variables, for better performance.
// nolint: unused
var (
	__VDLType_map_1     *vdl.Type
	__VDLType_enum_2    *vdl.Type
	__VDLType_enum_3    *vdl.Type
	__VDLType_struct_4  *vdl.Type
	__VDLType_struct_5  *vdl.Type
	__VDLType_struct_6  *vdl.Type
	__VDLType_union_7   *vdl.Type
	__VDLType_list_8    *vdl.Type
	__VDLType_union_9   *vdl.Type
	__VDLType_struct_10 *vdl.Type
	__VDLType_union_11  *vdl.Type
	__VDLType_struct_12 *vdl.Type
	__VDLType_set_13    *vdl.Type
	__VDLType_struct_14 *vdl.Type
)

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*Config)(nil))
	vdl.Register((*InstallationState)(nil))
	vdl.Register((*InstanceState)(nil))
	vdl.Register((*InstanceStatus)(nil))
	vdl.Register((*InstallationStatus)(nil))
	vdl.Register((*DeviceStatus)(nil))
	vdl.Register((*Status)(nil))
	vdl.Register((*BlessServerMessage)(nil))
	vdl.Register((*BlessClientMessage)(nil))
	vdl.Register((*Description)(nil))
	vdl.Register((*Association)(nil))

	// Initialize type definitions.
	__VDLType_map_1 = vdl.TypeOf((*Config)(nil))
	__VDLType_enum_2 = vdl.TypeOf((*InstallationState)(nil))
	__VDLType_enum_3 = vdl.TypeOf((*InstanceState)(nil))
	__VDLType_struct_4 = vdl.TypeOf((*InstanceStatus)(nil)).Elem()
	__VDLType_struct_5 = vdl.TypeOf((*InstallationStatus)(nil)).Elem()
	__VDLType_struct_6 = vdl.TypeOf((*DeviceStatus)(nil)).Elem()
	__VDLType_union_7 = vdl.TypeOf((*Status)(nil))
	__VDLType_list_8 = vdl.TypeOf((*[]byte)(nil))
	__VDLType_union_9 = vdl.TypeOf((*BlessServerMessage)(nil))
	__VDLType_struct_10 = vdl.TypeOf((*security.WireBlessings)(nil)).Elem()
	__VDLType_union_11 = vdl.TypeOf((*BlessClientMessage)(nil))
	__VDLType_struct_12 = vdl.TypeOf((*Description)(nil)).Elem()
	__VDLType_set_13 = vdl.TypeOf((*map[string]struct{})(nil))
	__VDLType_struct_14 = vdl.TypeOf((*Association)(nil)).Elem()

	return struct{}{}
}
